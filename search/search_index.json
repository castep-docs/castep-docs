{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CASTEP Documentation This is the CASTEP community documentation and tutorial site. For an overview of CASTEP, and to obtain a licence please see the castep website For the Dassault Syst\u00e8mes BIOVIA (Materials Studio) documentation for CASTEP see HTML documentation and a downloadable pdf user guide Contributors:","title":"Home"},{"location":"#castep-documentation","text":"This is the CASTEP community documentation and tutorial site. For an overview of CASTEP, and to obtain a licence please see the castep website For the Dassault Syst\u00e8mes BIOVIA (Materials Studio) documentation for CASTEP see HTML documentation and a downloadable pdf user guide","title":"CASTEP Documentation"},{"location":"#contributors","text":"","title":"Contributors:"},{"location":"documentation/EPR/overview/","text":"In crystalline materials, electron paramagnetic resonance (EPR) can be used to study paramagnetic defects. EPR spectra of spin \u00bd centers have two contributions: the hyperfine tensor {\\bf A} {\\bf A} and the g-tensor {\\bf g} {\\bf g} , which are defined through the following effective Hamiltonian \\begin{equation} H_{eff}=\\frac{\\alpha}{2}{\\bf S}\\cdot{\\bf g}\\cdot{\\bf B} + \\sum_I {\\bf S}\\cdot{\\bf A}_{I}\\cdot{\\bf I}_I \\end{equation} where \\alpha \\alpha is the fine structure constant and the summation I I runs over nuclei. The hyperfine tensor arises from the interaction of the nuclei with the ground-state spin density. This term has been calculated within the planewave-pseudopotential approach; indeed it was for this property that the PAW scheme was first introduced.\\cite{walle93} The g-tensor arises from the interaction of the electronic spin with the external magnetic field. This term plays an somewhat similar role to the shielding in NMR; induced electronic currents in the sample modify the g-tensor from its vacuum value. The GIPAW approach has been used to compute g-tensors in several crystalline materials including defects in \\alpha \\alpha -quartz and zirconia.","title":"EPR Overview"},{"location":"documentation/Geometry_Optimisation/constraints/","text":"Atomic constraints CASTEP can impose various forms of linear or non-linear constraints upon the positions of the atoms. This can be used with all forms of geometry optimization and molecular dynamics. Some simple short cuts exist, such as to keep all the atoms fixed: FIX_ALL_IONS : T or to fix the Centre of Mass: FIX_COM : T It is also possible to specify constraints on individual atoms, using the IONIC_CONSTRAINTS block. The simplest case is to control which atoms remain fixed during a geometry optimisation. e.g. %BLOCK IONIC_CONSTRAINTS fix: C 1 !fix position of atom C 1 %ENDBLOCK IONIC_CONSTRAINTS Some further examples include fix: all !fix all atoms\u2028 fix: C N !fix species C and N\u2028 fix: C 1 !fix position of atom C 1\u2028 fix: C{1,3,5-10} !fix positions of atoms C1, C3, C5,C6,C7,C8,C9,C10\u2028 fix: all unfix: H !fix positions of all atoms except H The last example in particularly useful in the case of molecular crystals, when you might want to allow the H atoms to move but keep all of the heavy atoms in the positions determined by diffraction. To fix the individual Cartesian components of an atom's position use the full syntax of the ionic_constraints block, where each constraint removes one degree of freedom. For example %BLOCK IONIC_CONSTRAINTS 1 W 1 1.0000000000 0.0000000000 0.0000000000 2 W 1 0.0000000000 1.0000000000 0.0000000000 3 W 1 0.0000000000 0.0000000000 1.0000000000 4 W 2 1.0000000000 0.0000000000 0.0000000000 %ENDBLOCK IONIC_CONSTRAINTS The 1 st line says that constraint number 1 is to fix the x coordinate of Tungston atom 1. The 2 nd line says that constraint number 2 is to fix the y coordinate of Tungston atom 1. etc. To fix an atom in 3D requires 3 constraints to remove all 3 degrees of freedom. The ionic_constraints block can also be used to impose any arbitary linear constraint, such as to restrict an atom to move in a plane or along a line, or to fix the centre of mass. A constraint may involve more than 1 atom, and hence can span mulitple lines, but each constraint operates on 1 degree of freedom. It cannot be used to fix a bond length - that is a non-linear constraint - see below for more details. The general syntax for constraint i i operating on atom j j of element X at position r^j r^j is %BLOCK IONIC_CONSTRAINTS ... i X j a1 a2 a3 ... %ENDBLOCK IONIC_CONSTRAINTS and the constraint is specfied as \\begin{equation} C^i={\\bf a^i}\\cdot{\\bf r^j} \\end{equation} where C^i C^i is given by the initial conditions. For example to fix the second S atom to move in the plane parallel to y=x y=x use this: %BLOCK IONIC_CONSTRAINTS 1 S 2 -1 1 0 %ENDBLOCK IONIC_CONSTRAINTS Cell Constraints Cell constraints can be used with all forms of geometry optimization and molecular dynamics that all the cell size/shape to vary. Some simple short cuts exist, such as to keep the unit cell fixed during the optimisation FIX_CELL : T To fix the volume of the unit cell FIX_VOL : T It is also possible to apply an arbitary set of constraints to the cell angles and cell lengths using the CELL_CONSTRAINTS block. %BLOCK CELL_CONSTRAINTS a b c alpha beta gamma %ENDBLOCK CELL_CONSTRAINTS Setting an element to zero means to keep it fixed. Two or more elements set to the same positive integer, means that these elements should be kept equal during the geometry optimisation. For example %BLOCK CELL_CONSTRAINTS 0 0 0 4 5 6 %ENDBLOCK CELL_CONSTRAINTS would keep all cell lengths fixed, and allow the three cell angles to vary independently, and %BLOCK CELL_CONSTRAINTS 0 0 0 4 4 6 %ENDBLOCK CELL_CONSTRAINTS would enforce \\alpha=\\beta\\neq\\gamma \\alpha=\\beta\\neq\\gamma and keep the cell lengths fixed. Symmetry The application of symmetry with constraints (for ionic positions and/or cell vectors) needs to be considered carefully. In general, if symmetry is on, then there is no need to add a constraint to explicitly impose a restriction that is implied by the symmetry. If there is a need for an additional restriction, then that can be added on top of the symmetry, but the user needs to be careful that the additional constraint does not conflict with symmetry. If in doubt, turn symmetry off and impose all the desired constraints explicitly. Non-linear Constraints CASTEP can also support non-linear constraints, such as fixed bond length, in both molecular dynamics and geometry optimization if using GEOM_METHOD=DELOCALISED : %BLOCK NONLINEAR_CONSTRAINTS constraint_type atom1 atom2 (atom3 (atom 4)) ... %ENDBLOCK NONLINEAR_CONSTRAINTS where the first element specifies a constraint type (distance, bend or torsion). Then depending on the type of constraint, either 2, 3 or 4 atoms need to be specified. As for ionic constraints, atoms are specified by species and number within that species. In addition, it is necessary to specify which periodic image of the cell the atom is located in (so constraints can straddle a cell boundary). For instance %BLOCK NONLINEAR_CONSTRAINTS distance H 4 0 0 0 O 2 0 1 0 bend H 5 0 0 0 C 1 1 0 1 H 2 0 0 0 torsion H 6 0 0 0 H 3 1 0 0 H 1 0 0 1 H 9 1 1 1 0 %ENDBLOCK NONLINEAR_CONSTRAINTS specifies: the distance between the 4 th hydrogen atom and the 2 nd oxygen atom in the adjacent ( 0 1 0 ) cell the bend angle defined by the 5 th hydrogen atom, the 1 st carbon atom in the ( 1 0 1 ) cell and the 2 nd hydrogen atom the torsion angle defined by 4 hydrogen atoms, etc.","title":"Constraints"},{"location":"documentation/Geometry_Optimisation/constraints/#atomic-constraints","text":"CASTEP can impose various forms of linear or non-linear constraints upon the positions of the atoms. This can be used with all forms of geometry optimization and molecular dynamics. Some simple short cuts exist, such as to keep all the atoms fixed: FIX_ALL_IONS : T or to fix the Centre of Mass: FIX_COM : T It is also possible to specify constraints on individual atoms, using the IONIC_CONSTRAINTS block. The simplest case is to control which atoms remain fixed during a geometry optimisation. e.g. %BLOCK IONIC_CONSTRAINTS fix: C 1 !fix position of atom C 1 %ENDBLOCK IONIC_CONSTRAINTS Some further examples include fix: all !fix all atoms\u2028 fix: C N !fix species C and N\u2028 fix: C 1 !fix position of atom C 1\u2028 fix: C{1,3,5-10} !fix positions of atoms C1, C3, C5,C6,C7,C8,C9,C10\u2028 fix: all unfix: H !fix positions of all atoms except H The last example in particularly useful in the case of molecular crystals, when you might want to allow the H atoms to move but keep all of the heavy atoms in the positions determined by diffraction. To fix the individual Cartesian components of an atom's position use the full syntax of the ionic_constraints block, where each constraint removes one degree of freedom. For example %BLOCK IONIC_CONSTRAINTS 1 W 1 1.0000000000 0.0000000000 0.0000000000 2 W 1 0.0000000000 1.0000000000 0.0000000000 3 W 1 0.0000000000 0.0000000000 1.0000000000 4 W 2 1.0000000000 0.0000000000 0.0000000000 %ENDBLOCK IONIC_CONSTRAINTS The 1 st line says that constraint number 1 is to fix the x coordinate of Tungston atom 1. The 2 nd line says that constraint number 2 is to fix the y coordinate of Tungston atom 1. etc. To fix an atom in 3D requires 3 constraints to remove all 3 degrees of freedom. The ionic_constraints block can also be used to impose any arbitary linear constraint, such as to restrict an atom to move in a plane or along a line, or to fix the centre of mass. A constraint may involve more than 1 atom, and hence can span mulitple lines, but each constraint operates on 1 degree of freedom. It cannot be used to fix a bond length - that is a non-linear constraint - see below for more details. The general syntax for constraint i i operating on atom j j of element X at position r^j r^j is %BLOCK IONIC_CONSTRAINTS ... i X j a1 a2 a3 ... %ENDBLOCK IONIC_CONSTRAINTS and the constraint is specfied as \\begin{equation} C^i={\\bf a^i}\\cdot{\\bf r^j} \\end{equation} where C^i C^i is given by the initial conditions. For example to fix the second S atom to move in the plane parallel to y=x y=x use this: %BLOCK IONIC_CONSTRAINTS 1 S 2 -1 1 0 %ENDBLOCK IONIC_CONSTRAINTS","title":"Atomic constraints"},{"location":"documentation/Geometry_Optimisation/constraints/#cell-constraints","text":"Cell constraints can be used with all forms of geometry optimization and molecular dynamics that all the cell size/shape to vary. Some simple short cuts exist, such as to keep the unit cell fixed during the optimisation FIX_CELL : T To fix the volume of the unit cell FIX_VOL : T It is also possible to apply an arbitary set of constraints to the cell angles and cell lengths using the CELL_CONSTRAINTS block. %BLOCK CELL_CONSTRAINTS a b c alpha beta gamma %ENDBLOCK CELL_CONSTRAINTS Setting an element to zero means to keep it fixed. Two or more elements set to the same positive integer, means that these elements should be kept equal during the geometry optimisation. For example %BLOCK CELL_CONSTRAINTS 0 0 0 4 5 6 %ENDBLOCK CELL_CONSTRAINTS would keep all cell lengths fixed, and allow the three cell angles to vary independently, and %BLOCK CELL_CONSTRAINTS 0 0 0 4 4 6 %ENDBLOCK CELL_CONSTRAINTS would enforce \\alpha=\\beta\\neq\\gamma \\alpha=\\beta\\neq\\gamma and keep the cell lengths fixed.","title":"Cell Constraints"},{"location":"documentation/Geometry_Optimisation/constraints/#symmetry","text":"The application of symmetry with constraints (for ionic positions and/or cell vectors) needs to be considered carefully. In general, if symmetry is on, then there is no need to add a constraint to explicitly impose a restriction that is implied by the symmetry. If there is a need for an additional restriction, then that can be added on top of the symmetry, but the user needs to be careful that the additional constraint does not conflict with symmetry. If in doubt, turn symmetry off and impose all the desired constraints explicitly.","title":"Symmetry"},{"location":"documentation/Geometry_Optimisation/constraints/#non-linear-constraints","text":"CASTEP can also support non-linear constraints, such as fixed bond length, in both molecular dynamics and geometry optimization if using GEOM_METHOD=DELOCALISED : %BLOCK NONLINEAR_CONSTRAINTS constraint_type atom1 atom2 (atom3 (atom 4)) ... %ENDBLOCK NONLINEAR_CONSTRAINTS where the first element specifies a constraint type (distance, bend or torsion). Then depending on the type of constraint, either 2, 3 or 4 atoms need to be specified. As for ionic constraints, atoms are specified by species and number within that species. In addition, it is necessary to specify which periodic image of the cell the atom is located in (so constraints can straddle a cell boundary). For instance %BLOCK NONLINEAR_CONSTRAINTS distance H 4 0 0 0 O 2 0 1 0 bend H 5 0 0 0 C 1 1 0 1 H 2 0 0 0 torsion H 6 0 0 0 H 3 1 0 0 H 1 0 0 1 H 9 1 1 1 0 %ENDBLOCK NONLINEAR_CONSTRAINTS specifies: the distance between the 4 th hydrogen atom and the 2 nd oxygen atom in the adjacent ( 0 1 0 ) cell the bend angle defined by the 5 th hydrogen atom, the 1 st carbon atom in the ( 1 0 1 ) cell and the 2 nd hydrogen atom the torsion angle defined by 4 hydrogen atoms, etc.","title":"Non-linear Constraints"},{"location":"documentation/Geometry_Optimisation/files/","text":".geom The .geom file is the primary output file, and contains the unit cell, positions of the atoms and the forces on the atoms for each step of the geometry optimisation. The format of this file is the same as the .md file () BEGIN header END header 0 F F F F <-- c -1.1089287934762380E+000 -1.1089287934762380E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 0.0000000000000000E+000 0.0000000000000000E+000 0.0000000000000000E+000 <-- R H 2 0.0000000000000000E+000 0.0000000000000000E+000 1.8897261258369291E+000 <-- R H 1 5.2328399876121735E-008 -1.0421543664521416E-007 7.0009877481903737E-002 <-- F H 2 -5.2328399876121735E-008 1.0421543664521414E-007 -7.0009877481903737E-002 <-- F 1 F F F T <-- c -1.1238786617585625E+000 -1.1238786617585625E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 9.4833861449528325E-008 -1.8886784811136898E-007 1.2687770000486739E-001 <-- R H 2 -9.4833861449528339E-008 1.8886784811136895E-007 1.7628484258320618E+000 <-- R H 1 -3.5821658412345467E-009 7.1341230429117867E-009 4.3459352502549203E-002 <-- F H 2 3.5821658412345467E-009 -7.1341230429117867E-009 -4.3459352502549203E-002 <-- F 5 T T T T <-- c -1.1282766172341445E+000 -1.1282766172341445E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 -3.9595146097124387E-007 7.8856409239690845E-007 2.1772199021621047E-001 <-- R H 2 3.9595146097124376E-007 -7.8856409239690845E-007 1.6720041356207189E+000 <-- R H 1 -8.2747158669639466E-009 1.6479675454026804E-008 1.5340573808683700E-006 <-- F H 2 8.2747158669639466E-009 -1.6479675454026804E-008 -1.5340573808683700E-006 <-- F All quantities are reported in atomic units (this cannot be changed by any parameter) <-- c Reports the iteration number and whether the convergence criteria are satisfied. <-- E Energy (total energy, enthalpy) <-- h Unit cell vectors <-- S Stress on unit cell (only reported if the cell is allowed to change) <-- R Cartesian positions of atoms <-- F Force on atoms The '\u2190 c' line also reports the status of 4 convergence flags (either F=false or T=true). These are (in order): dE - has the energy change/atom been below geom_energy_tol for at geom_convergence_win steps? Fmax - is the largest component of any force below geom_force_tol? dRmax - is the largest change in position for any atom below geom_disp_tol? Smax- is the largest component of the stress tensor below geom_stress_tol?","title":"Files"},{"location":"documentation/Geometry_Optimisation/files/#geom","text":"The .geom file is the primary output file, and contains the unit cell, positions of the atoms and the forces on the atoms for each step of the geometry optimisation. The format of this file is the same as the .md file () BEGIN header END header 0 F F F F <-- c -1.1089287934762380E+000 -1.1089287934762380E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 0.0000000000000000E+000 0.0000000000000000E+000 0.0000000000000000E+000 <-- R H 2 0.0000000000000000E+000 0.0000000000000000E+000 1.8897261258369291E+000 <-- R H 1 5.2328399876121735E-008 -1.0421543664521416E-007 7.0009877481903737E-002 <-- F H 2 -5.2328399876121735E-008 1.0421543664521414E-007 -7.0009877481903737E-002 <-- F 1 F F F T <-- c -1.1238786617585625E+000 -1.1238786617585625E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 9.4833861449528325E-008 -1.8886784811136898E-007 1.2687770000486739E-001 <-- R H 2 -9.4833861449528339E-008 1.8886784811136895E-007 1.7628484258320618E+000 <-- R H 1 -3.5821658412345467E-009 7.1341230429117867E-009 4.3459352502549203E-002 <-- F H 2 3.5821658412345467E-009 -7.1341230429117867E-009 -4.3459352502549203E-002 <-- F 5 T T T T <-- c -1.1282766172341445E+000 -1.1282766172341445E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 -3.9595146097124387E-007 7.8856409239690845E-007 2.1772199021621047E-001 <-- R H 2 3.9595146097124376E-007 -7.8856409239690845E-007 1.6720041356207189E+000 <-- R H 1 -8.2747158669639466E-009 1.6479675454026804E-008 1.5340573808683700E-006 <-- F H 2 8.2747158669639466E-009 -1.6479675454026804E-008 -1.5340573808683700E-006 <-- F All quantities are reported in atomic units (this cannot be changed by any parameter) <-- c Reports the iteration number and whether the convergence criteria are satisfied. <-- E Energy (total energy, enthalpy) <-- h Unit cell vectors <-- S Stress on unit cell (only reported if the cell is allowed to change) <-- R Cartesian positions of atoms <-- F Force on atoms The '\u2190 c' line also reports the status of 4 convergence flags (either F=false or T=true). These are (in order): dE - has the energy change/atom been below geom_energy_tol for at geom_convergence_win steps? Fmax - is the largest component of any force below geom_force_tol? dRmax - is the largest change in position for any atom below geom_disp_tol? Smax- is the largest component of the stress tensor below geom_stress_tol?","title":".geom"},{"location":"documentation/Geometry_Optimisation/keywords/","text":"To perform a geometry optimisation set the task parameter task : geomopt The convergence criteria have the following default values, each of which can be set independently. geom_energy_tol : Tolerance on energy change between iterations (default: 2.0e-5 eV) geom_force_tol : Tolerance on maximum force on each atom (default: 0.05 eV/ANG) geom_stress_tol : Tolerance on maximum stress on cell (default: 0.1 GPa) geom_disp_tol : Tolerance on change in atom positions between iterations (default: 0.001: Ang) geom_max_iter : Maximum number of iterations (default: 30) It is possible to change the optimisation method, and to choose a preconditioner. geom_method : LBFGS (default), BFGS, DAMPEDMD,TPSD geom_preconditioner : EXP / FF / ID # EXPonential, Force Field, Identity (default) It is useful to set the following two parameters in a geometry optimisation. These will cause CASTEP to write a new cell/cif file with the final optimised coordinates write_cell_structure : T write_cif_structure : T","title":"Keywords"},{"location":"documentation/Geometry_Optimisation/overview/","text":"The essence of the calculation is for the ions and electrons in the supercell to be moved around stepwise until the forces on the atoms and the change in total energy between steps fall below some predefined convergence tolerance. The ionic positions are optimised using quasi-Newton methods. For each configuration of the ionic positions the electronic configuration is optimised using the method of conjugate gradients. The flow of the calculation is thus; Move ions into new positions using geometry optimisation algorithm Find electronic energy and forces for this ionic configuration Compare total energy with previous configurations and check if forces within tolerance limits If structure not optimised start at (1) and generate new set of ionic positions This cycle is performed until the forces fall within the tolerance limit and the energy should then be a local minimum. With periodic boundary conditions (as used by CASTEP) it is also possible to change the size and shape of the cell, in addition to (or instead of) moving the ions. In this case, the stress is calculated in addition to the forces, and this is used to change the cell, until the stress falls within a given tolerance. Finally, when considering the change in the cell, it is also possible to apply an external pressure. Hence it is the enthalpy, which is the appropriate free energy in this scenario, which is minimised instead of the energy. Finite-basis set corrections It should be noted, that with a plane-wave basis set (as used by CASTEP) there is an important side-effect of changing the size and/or shape of the cell - it changes the basis set used for the electronic states. Many DFT programs ignore this effect, which means that if the cell vectors change by more than a few %, the final structure is evaluated with a non-self-consistent basis, with a different cut-off energy to that intended. In CASTEP, there are two choices here: to either keep the cut-off energy constant (which results in the number and meaning of the plane-waves used in the basis changing from step-to-step) or to keep the number of plane-waves constant (which results in a change in the cut-off energy and in the meaning of the plane-waves used from step-to-step). The constant-cutoff/variable-number of plane-waves approach is the CASTEP default as it is the most physically reasonable. The constant number of plane-waves approach means that the quality of the calculation is changing from step-to-step. The effect of changing lattice vectors on the basis set can also be corrected to first-order using the 'finite basis set correction'. This can be calculated by the change in total energy for a small change in the cut-off energy at the start of a calculation, and then used as a correction to the energy and the stress. This is especially important in variable-cell calculations, for which it is activated by default. Advanced settings For geometry optimisation, there are a variety of different algorithms available which can be selected by the geom_method parameter in the param file. The choices are: LBFGS - the low-memory version of BFGS - the default option BFGS - widely-used quasi-Newton minimization TPSD - two-point steepest descent DELOCALIZED - a BFGS-based minimizer using delocalized internal coordinates DMD - optimally damped MD FIRE - fast inertial relaxation engine - a modified MD approach NB These are all 'local optimisations', i.e. the final structure depends upon the initial configuration and is not the global minimum. For those interested in finding the global minimum, then there are associated projects using Genetic Algorithms and AIRSS. The first 3 methods can do variable-cell or fixed-cell optimization, whereas the last 3 are only fixed-cell (for now). LBFGS/BFGS is generally the fastest method, and since v19, LBFGS has supported new preconditioners which should make it generally faster still. TPSD (unlike LBFGS/BFGS) has no built-in history, so should be much slower - however, the CASTEP implementation has a very efficient preconditioner which makes up for this, and the lack of history means that variable-cell optimisation with additional cell constraints is much more efficient than the equivalent calculation in LBFGS/BFGS. The DELOCALIZED minimizer is the only supported method to use delocalized internal coordinates, as opposed to absolute or fractional coordinates, and as such, should be best for optimizing large structures such as molecule-in-a-box with many low-energy soft modes. The two MD-based methods are generally less efficient, but can handle arbitrary constraints well, and have sometimes out-performed other methods for very anisotropic systems, such as molecule-on-a-surface etc.","title":"Overview"},{"location":"documentation/Geometry_Optimisation/overview/#finite-basis-set-corrections","text":"It should be noted, that with a plane-wave basis set (as used by CASTEP) there is an important side-effect of changing the size and/or shape of the cell - it changes the basis set used for the electronic states. Many DFT programs ignore this effect, which means that if the cell vectors change by more than a few %, the final structure is evaluated with a non-self-consistent basis, with a different cut-off energy to that intended. In CASTEP, there are two choices here: to either keep the cut-off energy constant (which results in the number and meaning of the plane-waves used in the basis changing from step-to-step) or to keep the number of plane-waves constant (which results in a change in the cut-off energy and in the meaning of the plane-waves used from step-to-step). The constant-cutoff/variable-number of plane-waves approach is the CASTEP default as it is the most physically reasonable. The constant number of plane-waves approach means that the quality of the calculation is changing from step-to-step. The effect of changing lattice vectors on the basis set can also be corrected to first-order using the 'finite basis set correction'. This can be calculated by the change in total energy for a small change in the cut-off energy at the start of a calculation, and then used as a correction to the energy and the stress. This is especially important in variable-cell calculations, for which it is activated by default.","title":"Finite-basis set corrections"},{"location":"documentation/Geometry_Optimisation/overview/#advanced-settings","text":"For geometry optimisation, there are a variety of different algorithms available which can be selected by the geom_method parameter in the param file. The choices are: LBFGS - the low-memory version of BFGS - the default option BFGS - widely-used quasi-Newton minimization TPSD - two-point steepest descent DELOCALIZED - a BFGS-based minimizer using delocalized internal coordinates DMD - optimally damped MD FIRE - fast inertial relaxation engine - a modified MD approach NB These are all 'local optimisations', i.e. the final structure depends upon the initial configuration and is not the global minimum. For those interested in finding the global minimum, then there are associated projects using Genetic Algorithms and AIRSS. The first 3 methods can do variable-cell or fixed-cell optimization, whereas the last 3 are only fixed-cell (for now). LBFGS/BFGS is generally the fastest method, and since v19, LBFGS has supported new preconditioners which should make it generally faster still. TPSD (unlike LBFGS/BFGS) has no built-in history, so should be much slower - however, the CASTEP implementation has a very efficient preconditioner which makes up for this, and the lack of history means that variable-cell optimisation with additional cell constraints is much more efficient than the equivalent calculation in LBFGS/BFGS. The DELOCALIZED minimizer is the only supported method to use delocalized internal coordinates, as opposed to absolute or fractional coordinates, and as such, should be best for optimizing large structures such as molecule-in-a-box with many low-energy soft modes. The two MD-based methods are generally less efficient, but can handle arbitrary constraints well, and have sometimes out-performed other methods for very anisotropic systems, such as molecule-on-a-surface etc.","title":"Advanced settings"},{"location":"documentation/Geometry_Optimisation/tools/","text":"JMol can read a .geom file and animate the movement of atoms during the optimisation.","title":"Tools"},{"location":"documentation/Getting_Started/basic_cell_file/","text":"This is a basic overview of the cell file. See the full cell file page for more details. The cell file is one of CASTEP's two main input files. It contains all of the information about the crystal lattice and the atomic positions, as well as additional information such as Brillouin zone sampling ('k-points'), pseudopotentials, and atomic properties. The file itself is a free-format keyword-driven text file, consisting of keywords and blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. Most of the keywords and blocks are optional, but CASTEP requires two block entries: a block to specify the lattice, and another to specify the atomic elements and positions within the cell. Lattice There are two main ways to set the crystal lattice in the cell file. The lattice_abc block specifies the lattice constants in terms of the lengths of the lattice vectors ( \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} ) and angles (alpha, beta and gamma): %block lattice_abc a b c alpha beta gamma %endblock lattice_abc This doesn't specify how the cell is to be oriented in the Cartesian coordinate system, so CASTEP uses the convention that \\mathbf{a} \\mathbf{a} is along the x-axis, and \\mathbf{b} \\mathbf{b} is in the x-y plane. Alternatively, you can specify the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} directly in terms of their Cartesian components, using the lattice_cart block. Note that these are specified as row vectors: %block lattice_cart [unit] a_x a_y a_z b_x b_y b_z c_x c_y c_z %endblock lattice_cart The first line is optional, and specifies a length unit; the default is ang , meaning Angstroms. Atomic positions The positions of the atoms within a cell may be specified in either fractional coordinates (i.e. the coordinates in the basis of the lattice vectors) or Cartesian coordinates: %block positions_frac symbol u v w %endblock positions_frac where symbol is the chemical symbol for the atomic element, and u , v and w are the fractional components of the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} , respectively, such that the Cartesian positions vector of the atom, \\mathbf{r} \\mathbf{r} , is \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} To add a second atom, simply add a second line with the new information, and similarly for additional atoms. An alternative is to specify the atomic coordinates with reference to their absolute Cartesian coordinates: %block positions_abs [unit] symbol x y z %endblock positions_abs where [unit] is an optional length unit (default: ang , meaning Angstroms), symbol is the chemical symbol for the atomic element, and x , y and z are the Cartesian coordinates of the atom, such that the position vector, \\mathbf{r}=(x,y,z) \\mathbf{r}=(x,y,z) . Comments It can be convenient to add comments to a cell file, not only to explain why certain choices were made, but also as a way of disabling input lines without removing them from the file. Both ! and # are accepted as comment characters, and anything to the right of these will be ignored by CASTEP. For example, the cell section # Place a single atom at the origin %block positions_abs bohr C 0.00000000 0.00000000 0.00000000 !Si 0.00000000 0.00000000 0.00000000 %endblock positions_abs has a comment explaining the atomic coordinates, and a single carbon atom at the origin. The second atomic position is commented out, so CASTEP will ignore it.","title":"cell File"},{"location":"documentation/Getting_Started/basic_cell_file/#lattice","text":"There are two main ways to set the crystal lattice in the cell file. The lattice_abc block specifies the lattice constants in terms of the lengths of the lattice vectors ( \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} ) and angles (alpha, beta and gamma): %block lattice_abc a b c alpha beta gamma %endblock lattice_abc This doesn't specify how the cell is to be oriented in the Cartesian coordinate system, so CASTEP uses the convention that \\mathbf{a} \\mathbf{a} is along the x-axis, and \\mathbf{b} \\mathbf{b} is in the x-y plane. Alternatively, you can specify the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} directly in terms of their Cartesian components, using the lattice_cart block. Note that these are specified as row vectors: %block lattice_cart [unit] a_x a_y a_z b_x b_y b_z c_x c_y c_z %endblock lattice_cart The first line is optional, and specifies a length unit; the default is ang , meaning Angstroms.","title":"Lattice"},{"location":"documentation/Getting_Started/basic_cell_file/#atomic-positions","text":"The positions of the atoms within a cell may be specified in either fractional coordinates (i.e. the coordinates in the basis of the lattice vectors) or Cartesian coordinates: %block positions_frac symbol u v w %endblock positions_frac where symbol is the chemical symbol for the atomic element, and u , v and w are the fractional components of the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} , respectively, such that the Cartesian positions vector of the atom, \\mathbf{r} \\mathbf{r} , is \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} To add a second atom, simply add a second line with the new information, and similarly for additional atoms. An alternative is to specify the atomic coordinates with reference to their absolute Cartesian coordinates: %block positions_abs [unit] symbol x y z %endblock positions_abs where [unit] is an optional length unit (default: ang , meaning Angstroms), symbol is the chemical symbol for the atomic element, and x , y and z are the Cartesian coordinates of the atom, such that the position vector, \\mathbf{r}=(x,y,z) \\mathbf{r}=(x,y,z) .","title":"Atomic positions"},{"location":"documentation/Getting_Started/basic_cell_file/#comments","text":"It can be convenient to add comments to a cell file, not only to explain why certain choices were made, but also as a way of disabling input lines without removing them from the file. Both ! and # are accepted as comment characters, and anything to the right of these will be ignored by CASTEP. For example, the cell section # Place a single atom at the origin %block positions_abs bohr C 0.00000000 0.00000000 0.00000000 !Si 0.00000000 0.00000000 0.00000000 %endblock positions_abs has a comment explaining the atomic coordinates, and a single carbon atom at the origin. The second atomic position is commented out, so CASTEP will ignore it.","title":"Comments"},{"location":"documentation/Getting_Started/basic_param_file/","text":"This is a basic overview of the param file. See the full param file page for more details. The param file is one of CASTEP's two main input files. It contains all of the information about the kind of simulation your wish CASTEP to perform, as well as details of how CASTEP should perform them and additional simulations and analyses. The file itself is a free-format keyword-driven text file, consisting largely of single-line keywords, although there are a small number of blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. All of the keywords and blocks are optional, but you will almost always want to change at least some. Task This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file . Cut-off energy The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV. XC functional Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"param File"},{"location":"documentation/Getting_Started/basic_param_file/#task","text":"This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file .","title":"Task"},{"location":"documentation/Getting_Started/basic_param_file/#cut-off-energy","text":"The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV.","title":"Cut-off energy"},{"location":"documentation/Getting_Started/basic_param_file/#xc-functional","text":"Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"XC functional"},{"location":"documentation/Getting_Started/built_in_help/","text":"CASTEP has an in-built help option to assist with using particular keywords. Information on using CASTEP can be seen by using: castep -h To get more information on a particular input file keyword (e.g. kpoint_mp_grid ) use: castep -h kpoint_mp_grid If you don't know the keyword you need to use, then you can search on a particular keyword. This returns a list of keywords that you might be interested in, e.g. to look at all keywords which contain a reference to symmetry. castep -s symmetry Finally, to list all keywords, use: castep -h all To find out which version of CASTEP you have, use: castep -v","title":"Command line help"},{"location":"documentation/Getting_Started/intro/","text":"CASTEP is a software package to calculate the properties of materials. It is based on quantum mechanics, in a form known as density functional theory, and can simulate a wide range of materials proprieties including energetics, structure at the atomic level, vibrational properties, and many experimental characterisation methods, such as infra-red and Raman spectra, NMR, and core-level spectra. This documentation This documentation focuses on using CASTEP at the command-line, as a stand-alone program. You can build two versions of CASTEP: a \"serial\" version called castep.serial , which is primarily designed to run on a single CPU core; or a parallel version called castep.mpi , which uses the message passing interface (MPI) to run on more than one core. Most of this documentation applies equally to both versions, but for simplicity we will focus on the serial version in most of the examples. We will refer to the CASTEP command itself as castep , which you will need to change to castep.serial or castep.mpi , as appropriate. In this documentation, anything in a fixed width font like this is text to type, either on the command-line or in a CASTEP input file. For CASTEP's input files, there is sometimes a choice between different settings, and this will be indicated using the | symbol, meaning \"or\". For example, setting : choice_1|choice_2|choice_3 If some of the entries are optional, they will have square brackets around them [like this] , for example: setting : choice_1|choice_2|choice_3 [unit of choice]","title":"Introduction"},{"location":"documentation/Getting_Started/intro/#this-documentation","text":"This documentation focuses on using CASTEP at the command-line, as a stand-alone program. You can build two versions of CASTEP: a \"serial\" version called castep.serial , which is primarily designed to run on a single CPU core; or a parallel version called castep.mpi , which uses the message passing interface (MPI) to run on more than one core. Most of this documentation applies equally to both versions, but for simplicity we will focus on the serial version in most of the examples. We will refer to the CASTEP command itself as castep , which you will need to change to castep.serial or castep.mpi , as appropriate. In this documentation, anything in a fixed width font like this is text to type, either on the command-line or in a CASTEP input file. For CASTEP's input files, there is sometimes a choice between different settings, and this will be indicated using the | symbol, meaning \"or\". For example, setting : choice_1|choice_2|choice_3 If some of the entries are optional, they will have square brackets around them [like this] , for example: setting : choice_1|choice_2|choice_3 [unit of choice]","title":"This documentation"},{"location":"documentation/Getting_Started/restarting/","text":"Checkpointing and Restarting CASTEP provides a mechanism for saving intermediate and final states of the calculation and for restarting or continuing from a saved state. At the end of every calculation which completes normally, CASTEP writes two files <seed>.check and <seed>.castep_bin which are binary-format files containing a complete state of the calculation including input parameters, cell variables, electron densities and any results or intermediate quantities whose calculation has completed. All inputs and results reported in the .castep file are saved to the checkpoint: indeed a lost .castep file from a completed calculation may be (mostly) regenerated using a minimal continuation run. .check vs .castep_bin The only difference between .check and .castep_bin is that the .check file contains the converged ground-state wavefunctions but .castep_bin does not, and therefore requires much less disk space to store. This makes it useful for purposes of archiving a calculation. When continuing from a .castep_bin CASTEP will regenerate the ground state wavefunctions non-selfconsistently using the ground-state density from the file. Checkpointing during a calculation An incomplete calculation can be completed in a new run by adding the parameters keyword continuation : default in the .param file and rerunning CASTEP as before with the same <seed> command-line argument. This is the usual way of continuing a run interrupted, for example, by the job time limit on a batch scheduling system. To benefit from continuation, a checkpoint file must have been written in the original run. There are three parameters keywords which may be used to do this: num_backup_iter <n> write a checkpoint every <n> (default 5) geometry MD or phonon steps backup_interval <s> write a checkpoint every <s> seconds run_time <s> write a checkpoint and exit at the first opportunity after <s> seconds have elapsed. These may be used to periodically checkpoint many lengthy post-SCF tasks including geometry optimization, MD, phonon calculations, but checkpointing of spectral and magres tasks is not supported via this mechanism. Neither is checkpointing possible within an extremely lengthy SCF calculation, but see the next section for an alternative. Checkpoint files are portable, and independent of data-distribution, so the continuation run may use a different number of parallel nodes, data distribution, OpenMP etc. They are also portable across computers, so a run may be started on one computer and finished on another, which may be helpful to balance use of computer resources. Advanced keywords One additional related parameters keyword which finds occasional use is a simple one-liner stop which can be added to the .param file while a run is in progress. CASTEP rereads the .param file at every checkpoint opportunity and if this is present will perform a graceful exit after writing the checkpoint files. Which periodic and end-of-run checkpoint files are written may be controlled by the parameters keyword write_checkpoint which takes values none : to suppress checkpoints completely minimal writes only .castep_bin all : writes both .check and .castep_bin Continuing from completed calculations The checkpoint/restart mechanism may also be used to \"chain\" runs or initialise a modified run with the results of a previous one. The .param file of the new run should contain continuation : <oldseed>.check Parameters values stored in and read from <oldseed>.check will be used, unless overridden by the new .param file, which therefore needs only a minimal number of entries. The .cell file is usually just copy of the original, but may also be modified if needed. Modifying task is a good way to \"chain\" calculations, for example performing a geometry optimisation followed by a spectral calculation. Info Not all parameter or cell keywords can be overridden upon continuation. castep --help <parameter-name> will report whether a variable is modifiable on continuation","title":"Checkpoint and Restart"},{"location":"documentation/Getting_Started/restarting/#checkpointing-and-restarting","text":"CASTEP provides a mechanism for saving intermediate and final states of the calculation and for restarting or continuing from a saved state. At the end of every calculation which completes normally, CASTEP writes two files <seed>.check and <seed>.castep_bin which are binary-format files containing a complete state of the calculation including input parameters, cell variables, electron densities and any results or intermediate quantities whose calculation has completed. All inputs and results reported in the .castep file are saved to the checkpoint: indeed a lost .castep file from a completed calculation may be (mostly) regenerated using a minimal continuation run. .check vs .castep_bin The only difference between .check and .castep_bin is that the .check file contains the converged ground-state wavefunctions but .castep_bin does not, and therefore requires much less disk space to store. This makes it useful for purposes of archiving a calculation. When continuing from a .castep_bin CASTEP will regenerate the ground state wavefunctions non-selfconsistently using the ground-state density from the file.","title":"Checkpointing and Restarting"},{"location":"documentation/Getting_Started/restarting/#checkpointing-during-a-calculation","text":"An incomplete calculation can be completed in a new run by adding the parameters keyword continuation : default in the .param file and rerunning CASTEP as before with the same <seed> command-line argument. This is the usual way of continuing a run interrupted, for example, by the job time limit on a batch scheduling system. To benefit from continuation, a checkpoint file must have been written in the original run. There are three parameters keywords which may be used to do this: num_backup_iter <n> write a checkpoint every <n> (default 5) geometry MD or phonon steps backup_interval <s> write a checkpoint every <s> seconds run_time <s> write a checkpoint and exit at the first opportunity after <s> seconds have elapsed. These may be used to periodically checkpoint many lengthy post-SCF tasks including geometry optimization, MD, phonon calculations, but checkpointing of spectral and magres tasks is not supported via this mechanism. Neither is checkpointing possible within an extremely lengthy SCF calculation, but see the next section for an alternative. Checkpoint files are portable, and independent of data-distribution, so the continuation run may use a different number of parallel nodes, data distribution, OpenMP etc. They are also portable across computers, so a run may be started on one computer and finished on another, which may be helpful to balance use of computer resources. Advanced keywords One additional related parameters keyword which finds occasional use is a simple one-liner stop which can be added to the .param file while a run is in progress. CASTEP rereads the .param file at every checkpoint opportunity and if this is present will perform a graceful exit after writing the checkpoint files. Which periodic and end-of-run checkpoint files are written may be controlled by the parameters keyword write_checkpoint which takes values none : to suppress checkpoints completely minimal writes only .castep_bin all : writes both .check and .castep_bin","title":"Checkpointing during a calculation"},{"location":"documentation/Getting_Started/restarting/#continuing-from-completed-calculations","text":"The checkpoint/restart mechanism may also be used to \"chain\" runs or initialise a modified run with the results of a previous one. The .param file of the new run should contain continuation : <oldseed>.check Parameters values stored in and read from <oldseed>.check will be used, unless overridden by the new .param file, which therefore needs only a minimal number of entries. The .cell file is usually just copy of the original, but may also be modified if needed. Modifying task is a good way to \"chain\" calculations, for example performing a geometry optimisation followed by a spectral calculation. Info Not all parameter or cell keywords can be overridden upon continuation. castep --help <parameter-name> will report whether a variable is modifiable on continuation","title":"Continuing from completed calculations"},{"location":"documentation/Getting_Started/running_castep/","text":"CASTEP has two main input files, called the cell file and the param file . The cell file defines the structure of the material (or molecule) you wish to study, and the param file defines the kind of simulation CASTEP should perform. The cell and param files should be named using the same prefix, which CASTEP calls the \"seedname\", with the extensions .cell and .param , respectively. For example, for a calculation called mytest , you need the input files mytest.cell mytest.param and the calculation is run with the command castep mytest The main CASTEP output file will be names using the same seedname and the .castep extension, i.e. in the above example it would be called mytest.castep . If this file already exists, CASTEP will append its output to it. When CASTEP completes successfully, it writes additional files such as the .bib file, which contains references to key papers for the theory and methods CASTEP used. If CASTEP encounters a serious problem, it will stop and write an error message to a .err file. If you are using the parallel version of CASTEP on many cores, you may see error files from each of these cores. They are named using the same seedname, but with the numeric process ID added, e.g. if CASTEP is run on 2 cores and a serious problem occurs, you might see the files mytest.0001.err mytest.0002.err These files contain useful information about what went wrong, so it is always worth looking at them. See the Troubleshooting Guide for details of how to find and fix common problems.","title":"Running CASTEP"},{"location":"documentation/Groundstate/dftd/","text":"Long-range dispersion corrections TODOS do the TSSURF and TSSCS schemes work/do anything? are the aperiodic versions of TSSCS and MBD still a thing? What elements are supported for D3? General recommendations for types of systems -- are these ok? Add others? Check note about small cells and the TS, XDM abd MBD methods. Is the solution just to use a bigger supercell? Rule of thumb? Background Why and when are long range-dispersion methods needed? van der Waals (vdW) interactions are ubiquitous in nature but aren't accounted for by standard local and semilocal density functional approximations (i.e. LDA or GGAs). In particular, the long-range attractive part of the vdW interaction between system components (London dispersion interaction) is not captured. Including such dispersion effects is essential for accurately describing certain systems, especially for systems that are not bound ionically or covalently, e.g. gas molecules. The use of a dispersion method is strongly recommended when intermolecular interactions are expected to play a key role such as in molecular crystals, stacked 2D materials, and generally any weakly-bound system. Types of correction schemes There are several families of dispersion methods. A good summary of these can be found in the 2016 review by Grimme et al. We will summarise these categories here and, for those implemented in CASTEP, link to the relevant keywords. Semiempirical/semiclassical treatments Here the dispersion energy is calculated atom-wise (typically pair-wise) and is added to the DFT energy of the underlying functional. Note that a specific damping parameter (and function) is usually used to combine a given underlying functional (e.g. PBE) with a dispersion correction (e.g. D3). This means, for example, that the D3 correction to the PBE functional may be different to the D3 correction to HSE. Methods include: The Tkatchenko\u2212Scheffler scheme ( TS ) The TS-based many-body dispersion scheme ( MBD ) Grimme's D2 and D3 methods The exchange-dipole moment model ( XDM ) Nonlocal density-based treatments (not implemented in CASTEP) Here non-local functionals of the electronic density are constructed. Methods include the van der Waals functionals (e.g. vdW-DF2 and vdW-DF-cx ) and Vydrov and Van Voorhis functionals (e.g. VV10 ). Effective one-electron potentials (not implemented in CASTEP) Finally, the many-body correlated motion of electrons can be, to some extent, captured empiricially by using effective one-electron potentials. Examples of these include: semi-local functionals such as the Minnesota functionals (e.g. M06 ) and external potentials such as the dispersion-corrected atom-centered potentials (see e.g. van Santen 2015 ). General recommendations TODO -- check these Every application will have its own set of important features and it is not possible to say with certainty which density functional approximation will be the most appropriate. With that said, here are some suggestions for different types of materials: Molecular crystals: D3/D3-BJ/XDM/MBD in combination with GGA or hybrid functionals ( Dolgonos et al. 2019 ). Metals: vdW-DFs developed with solid state materials in mind (see e.g. Klime\u0161 et al. 2011 ). TODO: what about methods available in CASTEP? Interactions between molecules and surfaces of metals: vdW-DFs or dispersion methods that include screening, e.g. TSSCS MOFs: dispersion corrected (e.g. TS, D3, etc.) GGAs Layered vdW materials: Beyond pairwise appraches, e.g. D3 ^* ^* or MBD. TODO: others? ^* ^* See note below for how to include the three-body terms in the CASTEP D3 correction. Again, please do your own testing and consult relevant reviews and benchmarking papers. For the TS, MBD and XDM methods you may get a warning if your unit cell is small (where the lattice constants are comparable to the vdW radii). In such cases, try to use larger unit cells until your dispersion correction converges. TODO: any other solutions? Not all XC_FUNCTIONAL values are supported for all schemes - if in doubt use PBE. Each scheme has default parameters defined for a subset of elements (see table below). For other elements you need to define custom parameters using the SEDC_CUSTOM_PARAMS keyword in the .cell file. Using dispersion corrections in CASTEP .param file keywords In the .param file, set: SEDC_APPLY : true turns on dispersion correction. SEDC_SCHEME : The semi-empirical dispersion/van der Waals correction scheme to use. Default is NONE , other possible values listed in the table below. SEDC_SCHEME Available from CASTEP version Compatible XC functionals Elements supported Stresses Phonons * TS Predates 2012 PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Up to Z=54 with first row Lanthanides Analytic DFPT & FD TSSURF Not sure if working TSSCS Not sure if working Up to Z=54 with first row Lanthanides Analytic MBD (Alias: MBD*) 2015? Rewritten (and fixed) for CASTEP 18 PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Up to Z=54 with first row Lanthanides Numeric FD G06 (= D2) Predates 2012 PBE, BLYP, BP86, B3LYP, TPSS Up to Z= 54 Analytic DFPT & FD D3 CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD D3-BJ CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD OBS Predates 2012 LDA, PW91 Up to Z=57 Analytic DFPT & FD JCHS Predates 2012 PBE, BLYP, B3LYP, TPSS H, C, N, O, F, Cl, Br Analytic DFPT & FD XDM CASTEP 20 PBE Up to Z=102 Analytic FD * DFPT: Density functional perturbation theory; FD: finite displacement. All of the above methods support analytic forces. .cell file keywords In the .cell file you can optionally set custom parameters for each species: C6 (eV \u00c5 ^6 ^6 ): Available for TS, MBD*, and Grimme schemes. R0 (\u00c5): Available for TS, MBD*, and Grimme schemes. alpha (\u00c5 ^3 ^3 ): Available for TS, MBD*, and OBS schemes. I (eV): Available for the OBS scheme. Rvdw (\u00c5): Available for the OBS scheme. You set them like this: %BLOCK SEDC_CUSTOM_PARAMS ! example values for test purposes only - don't use these... ! He C6:1.00 R0:2.00 Ne C6:10.00 R0:4.00 %ENDBLOCK SEDC_CUSTOM_PARAMS Method details and customisation Tkatchenko\u2212Scheffler schemes A density-dependent, atom pairwise dispersion-correction scheme. SEDC_SCHEME : TS Phys. Rev. Lett.,102, 073005 (2009) Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Elements up to Z=54 (Xe) together with first row Lanthanides are supported. SEDC_SCHEME : TSSCS # TS with self-consistent screening Phys. Rev. Lett., 108, 236402 (2012) SEDC_SCHEME : TSSURF Phys. Rev. Lett., 108, 146103 (2012) Customisation keywords for all TS schemes .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the TS methods, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised. Many-body dispersion Beyond what can be included in simple pairwise dispersion approaches, MBD introduces: (1) many-body energy (Axilrod-Teller and higher-order) and (2) long-range Coulomb response (screening) that serves to modify the polarizabilities of interacting species. SEDC_SCHEME : MBD # (Alias: MBD*) Phys. Rev. Lett., 108, 236402 (2012) J. Chem. Phys. 140, 18A508 (2014) Note that the two aliases MBD and MBD* both refer to the revised version of MBD which employs range-separation (rs) of the self-consistent screening (SCS) of polarizabilities and the calculation of the long-range correlation energy, i.e. the MBD@rs-scs method. TODO : in older versions of CASTEP was this the case? From what version can be rely on that info? Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Elements up to Z=54 (Xe) together with first row Lanthanides are supported. Note that in the current implementation, only numeric stresses are available. Customisation keywords for MBD scheme .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping functionin the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the MBD method, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised. Grimme D corrections D2 Note that default D2 parameters are available only for the PBE, BLYP, BP86, B3LYP, TPSS functionals. You can also customise the correction parameters using the following keywords: SEDC_SCHEME : G06 # This is CASTEP's name for the Grimme D2 correction J. Comput. Chem. 27, 1787, (2006) Customisation keywords G06 .param file SEDC_S6_G06 Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_G06 Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For Grimme's D2 method, C6 (eV \u00c5 ^6 ^6 ) and R0 (\u00c5) can be customised. D3 Grimme's DFT-D3 method. The D3 scheme with Becke-Johnson damping (D3-BJ) is generally more accurate than the 'zero-damping' method (D3). Restrictions: Default D3 parameters are available for the PBE, PBE0 and HF functionals. TODO: what elements are supported? By default the three-body term is not included . To include it, set d3_threebody: True within a devel_code block in the .param file. Turn on IPRINT > 1 to get more information on what has been included in the D3 correction. In the current implementation, users cannot supply custom parameters for this correction scheme. SEDC_SCHEME : D3 J. Chem. Phys. 132, 154104 (2010) SEDC_SCHEME : D3-BJ J. Comput. Chem. 32, 1456 (2011) This is the Grimme D3 scheme with Becke-Johnson damping. Note When running a D3-BJ calculation with IPRINT > 1 , you might see Dispersion version: D4 in the .castep output file. Confusingly, this does not mean the Grimme D4 method has been used, it's just an interal CASTEP version label for this correction scheme. Compilation flags: for the D3 correction, CASTEP must be compiled with GRIMMED3 := compile Note that for the D3 correction to work, CASTEP must be compiled with the following flag: # Grimme D3 library support. Options are none or compile GRIMMED3 := compile in the Makefile For CASTEP 20, the D3 library is included in the distribution and the setting the flag above should be sufficient. Exchange-dipole moment (XDM) method SEDC_SCHEME : XDM A unified density-functional treatment of dynamical, nondynamical, and dispersion correlations. J. Chem. Phys. 127, 124108 (2007) To use this correction with the PBE functional, you need to set: SEDC_APPLY = TRUE SEDC_SCHEME = XDM SEDC_SC_XDM = 1.0 where the SEDC_SC_XDM parameter is a global scaling factor. For other functionals you need to specify the following additional parameters: Customisation keywords for XDM .param file SEDC_A1_XDM Type: Real (float) Level: Expert Description: Customisable A1 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_A2_XDM Type: Physical (float) Level: Expert Description: Customisable A2 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SC_XDM Type: Real (float) Level: Expert Description: Customisable SC value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_C9_XDM Type: Logical Level: Basic Description: Specifies whether three-body dispersion coefficients are to be computed in the XDM semi-empirical dispersion/ van der Waals correction scheme. Modifiable: restart and on the fly Allowed values: TRUE or FALSE Default is FALSE Note that the specific parameters found here: http://schooner.chem.dal.ca/wiki/XDM are might not be directly transferable to CASTEP and careful further testing is necessary. Other Schemes SEDC_SCHEME : OBS # (Ortmann, Bechstedt and Schmidt) Semiempirical van der Waals correction to the density functional description of solids and molecular structures Phys. Rev. B 73, 205101, (2006) Customisation keywords \" SEDC_LAMBDA_OBS \" Type: Real (float) Level: Expert Description: Customisable lambda value for damping function in the the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . \" SEDC_N_OBS \" Type: Real (float) Level: Expert Description: Customisable n value for the damping function in the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SCHEME : JCHS # (Jure\u010dka, \u010cern\u00fd, Hobza and Salahub) J. Comput. Chem. 28, 555, (2007) Customisation keywords SEDC_SR_JCHS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_S6_JCHS Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_JCHS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL .","title":"Dispersion Corrections"},{"location":"documentation/Groundstate/dftd/#long-range-dispersion-corrections","text":"TODOS do the TSSURF and TSSCS schemes work/do anything? are the aperiodic versions of TSSCS and MBD still a thing? What elements are supported for D3? General recommendations for types of systems -- are these ok? Add others? Check note about small cells and the TS, XDM abd MBD methods. Is the solution just to use a bigger supercell? Rule of thumb?","title":"Long-range dispersion corrections"},{"location":"documentation/Groundstate/dftd/#background","text":"","title":"Background"},{"location":"documentation/Groundstate/dftd/#why-and-when-are-long-range-dispersion-methods-needed","text":"van der Waals (vdW) interactions are ubiquitous in nature but aren't accounted for by standard local and semilocal density functional approximations (i.e. LDA or GGAs). In particular, the long-range attractive part of the vdW interaction between system components (London dispersion interaction) is not captured. Including such dispersion effects is essential for accurately describing certain systems, especially for systems that are not bound ionically or covalently, e.g. gas molecules. The use of a dispersion method is strongly recommended when intermolecular interactions are expected to play a key role such as in molecular crystals, stacked 2D materials, and generally any weakly-bound system.","title":"Why and when are long range-dispersion methods needed?"},{"location":"documentation/Groundstate/dftd/#types-of-correction-schemes","text":"There are several families of dispersion methods. A good summary of these can be found in the 2016 review by Grimme et al. We will summarise these categories here and, for those implemented in CASTEP, link to the relevant keywords. Semiempirical/semiclassical treatments Here the dispersion energy is calculated atom-wise (typically pair-wise) and is added to the DFT energy of the underlying functional. Note that a specific damping parameter (and function) is usually used to combine a given underlying functional (e.g. PBE) with a dispersion correction (e.g. D3). This means, for example, that the D3 correction to the PBE functional may be different to the D3 correction to HSE. Methods include: The Tkatchenko\u2212Scheffler scheme ( TS ) The TS-based many-body dispersion scheme ( MBD ) Grimme's D2 and D3 methods The exchange-dipole moment model ( XDM ) Nonlocal density-based treatments (not implemented in CASTEP) Here non-local functionals of the electronic density are constructed. Methods include the van der Waals functionals (e.g. vdW-DF2 and vdW-DF-cx ) and Vydrov and Van Voorhis functionals (e.g. VV10 ). Effective one-electron potentials (not implemented in CASTEP) Finally, the many-body correlated motion of electrons can be, to some extent, captured empiricially by using effective one-electron potentials. Examples of these include: semi-local functionals such as the Minnesota functionals (e.g. M06 ) and external potentials such as the dispersion-corrected atom-centered potentials (see e.g. van Santen 2015 ).","title":"Types of correction schemes"},{"location":"documentation/Groundstate/dftd/#general-recommendations","text":"TODO -- check these Every application will have its own set of important features and it is not possible to say with certainty which density functional approximation will be the most appropriate. With that said, here are some suggestions for different types of materials: Molecular crystals: D3/D3-BJ/XDM/MBD in combination with GGA or hybrid functionals ( Dolgonos et al. 2019 ). Metals: vdW-DFs developed with solid state materials in mind (see e.g. Klime\u0161 et al. 2011 ). TODO: what about methods available in CASTEP? Interactions between molecules and surfaces of metals: vdW-DFs or dispersion methods that include screening, e.g. TSSCS MOFs: dispersion corrected (e.g. TS, D3, etc.) GGAs Layered vdW materials: Beyond pairwise appraches, e.g. D3 ^* ^* or MBD. TODO: others? ^* ^* See note below for how to include the three-body terms in the CASTEP D3 correction. Again, please do your own testing and consult relevant reviews and benchmarking papers. For the TS, MBD and XDM methods you may get a warning if your unit cell is small (where the lattice constants are comparable to the vdW radii). In such cases, try to use larger unit cells until your dispersion correction converges. TODO: any other solutions? Not all XC_FUNCTIONAL values are supported for all schemes - if in doubt use PBE. Each scheme has default parameters defined for a subset of elements (see table below). For other elements you need to define custom parameters using the SEDC_CUSTOM_PARAMS keyword in the .cell file.","title":"General recommendations"},{"location":"documentation/Groundstate/dftd/#using-dispersion-corrections-in-castep","text":"","title":"Using dispersion corrections in CASTEP"},{"location":"documentation/Groundstate/dftd/#param-file-keywords","text":"In the .param file, set: SEDC_APPLY : true turns on dispersion correction. SEDC_SCHEME : The semi-empirical dispersion/van der Waals correction scheme to use. Default is NONE , other possible values listed in the table below. SEDC_SCHEME Available from CASTEP version Compatible XC functionals Elements supported Stresses Phonons * TS Predates 2012 PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Up to Z=54 with first row Lanthanides Analytic DFPT & FD TSSURF Not sure if working TSSCS Not sure if working Up to Z=54 with first row Lanthanides Analytic MBD (Alias: MBD*) 2015? Rewritten (and fixed) for CASTEP 18 PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Up to Z=54 with first row Lanthanides Numeric FD G06 (= D2) Predates 2012 PBE, BLYP, BP86, B3LYP, TPSS Up to Z= 54 Analytic DFPT & FD D3 CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD D3-BJ CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD OBS Predates 2012 LDA, PW91 Up to Z=57 Analytic DFPT & FD JCHS Predates 2012 PBE, BLYP, B3LYP, TPSS H, C, N, O, F, Cl, Br Analytic DFPT & FD XDM CASTEP 20 PBE Up to Z=102 Analytic FD * DFPT: Density functional perturbation theory; FD: finite displacement. All of the above methods support analytic forces.","title":".param file keywords"},{"location":"documentation/Groundstate/dftd/#cell-file-keywords","text":"In the .cell file you can optionally set custom parameters for each species: C6 (eV \u00c5 ^6 ^6 ): Available for TS, MBD*, and Grimme schemes. R0 (\u00c5): Available for TS, MBD*, and Grimme schemes. alpha (\u00c5 ^3 ^3 ): Available for TS, MBD*, and OBS schemes. I (eV): Available for the OBS scheme. Rvdw (\u00c5): Available for the OBS scheme. You set them like this: %BLOCK SEDC_CUSTOM_PARAMS ! example values for test purposes only - don't use these... ! He C6:1.00 R0:2.00 Ne C6:10.00 R0:4.00 %ENDBLOCK SEDC_CUSTOM_PARAMS","title":".cell file keywords"},{"location":"documentation/Groundstate/dftd/#method-details-and-customisation","text":"","title":"Method details and customisation"},{"location":"documentation/Groundstate/dftd/#tkatchenkoscheffler-schemes","text":"A density-dependent, atom pairwise dispersion-correction scheme. SEDC_SCHEME : TS Phys. Rev. Lett.,102, 073005 (2009) Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Elements up to Z=54 (Xe) together with first row Lanthanides are supported. SEDC_SCHEME : TSSCS # TS with self-consistent screening Phys. Rev. Lett., 108, 236402 (2012) SEDC_SCHEME : TSSURF Phys. Rev. Lett., 108, 146103 (2012) Customisation keywords for all TS schemes .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the TS methods, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised.","title":"Tkatchenko\u2212Scheffler schemes"},{"location":"documentation/Groundstate/dftd/#many-body-dispersion","text":"Beyond what can be included in simple pairwise dispersion approaches, MBD introduces: (1) many-body energy (Axilrod-Teller and higher-order) and (2) long-range Coulomb response (screening) that serves to modify the polarizabilities of interacting species. SEDC_SCHEME : MBD # (Alias: MBD*) Phys. Rev. Lett., 108, 236402 (2012) J. Chem. Phys. 140, 18A508 (2014) Note that the two aliases MBD and MBD* both refer to the revised version of MBD which employs range-separation (rs) of the self-consistent screening (SCS) of polarizabilities and the calculation of the long-range correlation energy, i.e. the MBD@rs-scs method. TODO : in older versions of CASTEP was this the case? From what version can be rely on that info? Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Elements up to Z=54 (Xe) together with first row Lanthanides are supported. Note that in the current implementation, only numeric stresses are available. Customisation keywords for MBD scheme .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping functionin the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the MBD method, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised.","title":"Many-body dispersion "},{"location":"documentation/Groundstate/dftd/#grimme-d-corrections","text":"D2 Note that default D2 parameters are available only for the PBE, BLYP, BP86, B3LYP, TPSS functionals. You can also customise the correction parameters using the following keywords: SEDC_SCHEME : G06 # This is CASTEP's name for the Grimme D2 correction J. Comput. Chem. 27, 1787, (2006) Customisation keywords G06 .param file SEDC_S6_G06 Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_G06 Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For Grimme's D2 method, C6 (eV \u00c5 ^6 ^6 ) and R0 (\u00c5) can be customised. D3 Grimme's DFT-D3 method. The D3 scheme with Becke-Johnson damping (D3-BJ) is generally more accurate than the 'zero-damping' method (D3). Restrictions: Default D3 parameters are available for the PBE, PBE0 and HF functionals. TODO: what elements are supported? By default the three-body term is not included . To include it, set d3_threebody: True within a devel_code block in the .param file. Turn on IPRINT > 1 to get more information on what has been included in the D3 correction. In the current implementation, users cannot supply custom parameters for this correction scheme. SEDC_SCHEME : D3 J. Chem. Phys. 132, 154104 (2010) SEDC_SCHEME : D3-BJ J. Comput. Chem. 32, 1456 (2011) This is the Grimme D3 scheme with Becke-Johnson damping. Note When running a D3-BJ calculation with IPRINT > 1 , you might see Dispersion version: D4 in the .castep output file. Confusingly, this does not mean the Grimme D4 method has been used, it's just an interal CASTEP version label for this correction scheme. Compilation flags: for the D3 correction, CASTEP must be compiled with GRIMMED3 := compile Note that for the D3 correction to work, CASTEP must be compiled with the following flag: # Grimme D3 library support. Options are none or compile GRIMMED3 := compile in the Makefile For CASTEP 20, the D3 library is included in the distribution and the setting the flag above should be sufficient.","title":"Grimme D corrections"},{"location":"documentation/Groundstate/dftd/#exchange-dipole-moment-xdm-method","text":"SEDC_SCHEME : XDM A unified density-functional treatment of dynamical, nondynamical, and dispersion correlations. J. Chem. Phys. 127, 124108 (2007) To use this correction with the PBE functional, you need to set: SEDC_APPLY = TRUE SEDC_SCHEME = XDM SEDC_SC_XDM = 1.0 where the SEDC_SC_XDM parameter is a global scaling factor. For other functionals you need to specify the following additional parameters: Customisation keywords for XDM .param file SEDC_A1_XDM Type: Real (float) Level: Expert Description: Customisable A1 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_A2_XDM Type: Physical (float) Level: Expert Description: Customisable A2 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SC_XDM Type: Real (float) Level: Expert Description: Customisable SC value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_C9_XDM Type: Logical Level: Basic Description: Specifies whether three-body dispersion coefficients are to be computed in the XDM semi-empirical dispersion/ van der Waals correction scheme. Modifiable: restart and on the fly Allowed values: TRUE or FALSE Default is FALSE Note that the specific parameters found here: http://schooner.chem.dal.ca/wiki/XDM are might not be directly transferable to CASTEP and careful further testing is necessary.","title":"Exchange-dipole moment (XDM) method "},{"location":"documentation/Groundstate/dftd/#other-schemes","text":"SEDC_SCHEME : OBS # (Ortmann, Bechstedt and Schmidt) Semiempirical van der Waals correction to the density functional description of solids and molecular structures Phys. Rev. B 73, 205101, (2006) Customisation keywords \" SEDC_LAMBDA_OBS \" Type: Real (float) Level: Expert Description: Customisable lambda value for damping function in the the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . \" SEDC_N_OBS \" Type: Real (float) Level: Expert Description: Customisable n value for the damping function in the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SCHEME : JCHS # (Jure\u010dka, \u010cern\u00fd, Hobza and Salahub) J. Comput. Chem. 28, 555, (2007) Customisation keywords SEDC_SR_JCHS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_S6_JCHS Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_JCHS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL .","title":"Other Schemes"},{"location":"documentation/Groundstate/intro/","text":"One of the most fundamental tasks for CASTEP is to take a crystal lattice and set of atomic positions, and compute the electronic density and total energy. Once the lattice and atomic positions have been specified, you can tell CASTEP to compute the energy by setting the task keyword in the param file : task : energy Your cell and param files should be named using the same prefix, which CASTEP calls the \"seedname\", and the extensions .cell and .param , respectively. For example, for a calculation called mytest , you need the input files mytest.cell mytest.param and the calculation is run with the command castep mytest CASTEP computes the energy by solving the Kohn-Sham equations iteratively, using the 'self-consistent field' (SCF) method.","title":"Overview"},{"location":"documentation/Groundstate/nlxc/","text":"","title":"Nlxc"},{"location":"documentation/Groundstate/soc/","text":"keywords For a calculation of a non-spin polarised system with spin orbit coupling (e.g. GaAs) the following keywords should be set in the param file spin_treatment : vector spin_orbit_coupling : true spin_polarised : false relativistic_treatment : dirac If the system has a spin density (e.g. a ferromagnet or antiferromagnet) then the following keywords should be set in the para file spin_treatment : vector spin_orbit_coupling : true spin_polarised : true relativistic_treatment : dirac As the spin-orbit coupling is transmitted via the pseudopotential is is necessary to use j-dependent pseudopotentials. These can be read from file (UPF or uspso) or generated on the fly. At the moment the SOC19 set of OTFG norm-conserving potentials are suitable. These can be specified with the following block in the cell file ``` %block species_pot SOC19 %endblock species_pot Limitations","title":"Spin Orbit Coupling"},{"location":"documentation/Groundstate/soc/#keywords","text":"For a calculation of a non-spin polarised system with spin orbit coupling (e.g. GaAs) the following keywords should be set in the param file spin_treatment : vector spin_orbit_coupling : true spin_polarised : false relativistic_treatment : dirac If the system has a spin density (e.g. a ferromagnet or antiferromagnet) then the following keywords should be set in the para file spin_treatment : vector spin_orbit_coupling : true spin_polarised : true relativistic_treatment : dirac As the spin-orbit coupling is transmitted via the pseudopotential is is necessary to use j-dependent pseudopotentials. These can be read from file (UPF or uspso) or generated on the fly. At the moment the SOC19 set of OTFG norm-conserving potentials are suitable. These can be specified with the following block in the cell file ``` %block species_pot SOC19 %endblock species_pot","title":"keywords"},{"location":"documentation/Groundstate/soc/#limitations","text":"","title":"Limitations"},{"location":"documentation/Groundstate/xc/","text":"","title":"Xc"},{"location":"documentation/Input_Files/cell_file/","text":"This is a detailed description of options for CASTEP's cell file. See the basic cell file page for an overview. This page has the most frequently-used cell file options, but for a full set use CASTEP's built-in help . There is also a concise table of cell keywords . The cell file is one of CASTEP's two main input files. It contains all of the information about the crystal lattice and the atomic positions, as well as additional information such as Brillouin zone sampling ('k-points'), pseudopotentials, cell symmetry, external pressure, constraints on motion of the atoms or cell, and atomic properties such as the mass of each species. The file itself is a free-format keyword-driven text file, consisting of keywords and blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. Most of the keywords and blocks are optional, but CASTEP requires two block entries: a block to specify the lattice, and another to specify the atomic elements and positions within the cell. At the very least, the cell lattice vectors and ionic positions must be specified. Reasonable defaults are chosen for anything else not specified. For the purposes of the following definitions, all variables represented by R R are defined to be real numbers, those represented by I I are defined to be integers and those represented by C C are characters. Cell Lattice Vectors The cell lattice vectors may be specified in Cartesian coordinates or in terms of the lattice vector magnitudes and the angles between them ( a, b, c, \\alpha, \\beta, \\gamma a, b, c, \\alpha, \\beta, \\gamma ). Only one of LATTICE_CART and LATTICE_ABC may occur in a cell definition file. The definitions of these keywords are as follows: %BLOCK LATTICE_CART [units] a_x a_y a_z b_x b_y b_z c_x c_y c_z %ENDBLOCK LATTICE_CART Here a_x is the x-component of the first lattice vector, \\mathbf{a} \\mathbf{a} , b_y b_y is the y-component of the second lattice vector, \\mathbf{b} \\mathbf{b} , etc. [units] specifies the units in which the lattice vectors are defined. If not present, the default is \u00c5. %BLOCK LATTICE_ABC [units] a b c alpha beta gamma %ENDBLOCK LATTICE_ABC Here a is the value of the lattice constant \\vert\\mathbf{a}\\vert \\vert\\mathbf{a}\\vert , gamma is the value of the cell angle \\gamma \\gamma (in degrees) etc. If the lattice is specified in this manner, the absolute orientation is arbitrary. In this case the orientation is defined by applying the following constraints: \\mathbf{a} \\mathbf{a} lies along the x-axis \\mathbf{b} \\mathbf{b} lies in the xy plane \\mathbf{c} \\mathbf{c} forms a right-handed set with \\mathbf{a} \\mathbf{a} and \\mathbf{b} \\mathbf{b} [units] specifies the units in which the lattice vector magnitudes are defined. If not present, the default is \u00c5. Angles should be specified in degrees. Ionic Positions The ionic positions may be specified in fractional coordinates relative to the lattice vectors of the unit cell, or in absolute coordinates. Only one of POSITIONS_FRAC and POSITIONS_ABS may occur in a cell definition file. %BLOCK POSITIONS_FRAC CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK END POSITIONS_FRAC The first entry on a line is the symbol of the species (chemical element). Alternatively, the atomic number may be given instead, in which case CASTEP will be look up for chemical symbol. A symbol can have a maximum of three characters. The first alphabetical characters identify the element, from which default values for atomic mass etc. The next three entries on a line in POSITIONS_FRAC are real numbers representing the position of the ion in fractions of the unit cell lattice vectors. If the optional flag SPIN is present on a line, this sets the spin polarisation ( N^\\uparrow-N^\\downarrow N^\\uparrow-N^\\downarrow ) of the atom for initialisation of the spin density; for non-collinear spin calculations, the vector spin is specified as three numbers. If this flag is not present a non-spin polarised state will be assumed. %BLOCK POSITIONS_ABS [units] CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK POSITIONS_ABS The first entry on a line is the symbol or atomic number of the ionic species, as for POSITIONS_FRAC . The next three entries are real numbers representing the position of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5. The optional flag SPIN is defined above under POSITIONS_FRAC . Brillouin Zone Sampling (k-points) (N.B. in the following section the keywords with the prefixes KPOINT_ and KPOINTS_ are synonymous. KPOINT_ is the preferred usage.) The k-points at which the Brillouin zone is to be sampled during a self consistent calculation to find the electronic ground state may be defined either by specifying a list of k-points or a Monkhorst-Pack grid in terms of the dimensions of the k-point mesh or a minimum k-point density. The origin of the Monkhorst-Pack grid may be offset by a vector from the origin of the Brillouin zone. If no k-points are specified, the default will be a Monkhorst-Pack grid with a maximum spacing of 0.1\u00c5 ^{-1} ^{-1} and no offset of the origin. The KPOINT_LIST , KPOINT_MP_GRID and KPOINT_MP_SPACING keywords are mutually exclusive. KPOINT_MP_OFFSET may be specified in combination with either KPOINT_MP_GRID or KPOINT_MP_SPACING . %BLOCK KPOINT_LIST \\begin{array}{cccc} R_{1i} R_{1j} R_{1k} R_{1w} R_{2i} R_{2j} R_{2k} R_{2w} ... %ENDBLOCK KPOINT_LIST The first three entries on a line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The final entry on a line is the weight of the k-point relative to the others specified. The sum of the weights must be equal to 1. KPOINT_MP_GRID I_i I_j I_k This specifies the dimensions of the Monkhorst-Pack grid requested in the directions of the reciprocal space lattice vectors. The generated grid will be I_i\\times I_j\\times I_k I_i\\times I_j\\times I_k ; any symmetries generated (or supplied) will be used to reduce this number, when computing the irreducible wedge. KPOINT_MP_SPACING R [units] The single entry is the maximum distance between k-points on the Monkhorst-Pack grid. The dimensions of the grid will be chosen such that the maximum separation of k-points is less than this. [units] specifies the units in which the k-point spacing is defined, although note that the actual units used are 2\\pi 2\\pi units . If not present, the default is ang-1 , such that the spacing is in 2\\pi \u00c5^{-1} 2\\pi \u00c5^{-1} . KPOINT_MP_OFFSET R_i R_j R_k This specifies the offset of the Monkhorst-Pack grid with respect to the origin of the Brillouin zone. The three entries are the offset in fractional coordinates relative to the reciprocal lattice vectors. The k-point set for performing spectral calculations can be specified in the same manner, using version of the keywords above with SPECTRAL_ prepended. The same restrictions regarding mutually exclusive keywords apply. For a non-self-consistent spectral calculation, the k-points may be defined along a path through reciprocal space or a list of k-points. %BLOCK SPECTRAL_KPOINT_PATH R_{1i} R_{1j} R_{1k} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK SPECTRAL_KPOINT_PATH The three numbers on each line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The k-points define a continuous sequence of straight line segments, unless the keyword BREAK appears on a separate line within the sequence of k-points. In this case the continuous path will end at the k-point immediately preceding the BREAK keyword and resume at the k-point immediately following. The path will be open unless the first and last point in the list are identical . The maximum spacing of the points sampled along each line segment is defined by the keyword SPECTRAL_KPOINT_PATH_SPACING (default value 0.1 \\times 2\\pi 0.1 \\times 2\\pi \u00c5 ^{-1} ^{-1} ). If necessary, the actual spacing used may be smaller than this in order to ensure that the length of the line segment is an integer multiple of the spacing between points on that segment. Alternatively, the k-point set for performing a band structure calculation can be specified in the same manner as the main k-point set, using version of the keywords above with BS_ prepended. The same restrictions regarding mutually exclusive keywords apply. In this case, the k-point weight in SPECTRAL_KPOINT_LIST is optional. If omitted, the weights for each k-point are assumed to be equal. For a phonon spectrum calculation, the k-points may be defined along a path through reciprocal space or a list of k-points, in the same manner as for a spectral calculation. The corresponding keywords are identical to those for the band structure specification with the initial SPECTRAL_ replaced by PHONON_ , e.g. PHONON_KPOINT_PATH , PHONON_KPOINT_PATH_SPACING and PHONON_KPOINT_LIST . The same restrictions regarding mutually exclusive keywords apply. The block keyword PHONON_GAMMA_DIRECTIONS specifies the directions in which the gamma point will be approached when calculating the non-analytic terms of the LO/TO splitting. Each line in this block will consist of a 3-vector specifying a direction in the basis of reciprocal lattice vectors. If this keyword is not present, the default will be a single vector determined as follows: If the gamma point is q_i = 0 q_i = 0 and there is a successor kpoint q_{i+1} q_{i+1} in the list, then it is q_{i+1} q_{i+1} . Otherwise if the gamma point is q_i =0 q_i =0 and there is a predecessor kpoint q_{i-1} q_{i-1} in the list then it is q_{i-1} q_{i-1} . Otherwise (i.e. a Gamma point only calculation) the a-axis of the reciprocal cell. For backwards compatibility the keywords beginning BS_ and OPTICS_ are synonyms for SPECTRAL_KPOINT_ and similarly those beginning. Cell Symmetry If no symmetry is specified in the cell definition file, the default is for no symmetry to be applied. SYMMETRY_GENERATE If this keyword is present in the cell, the highest symmetry group that applies to the structure of the cell will be found and the corresponding symmetry operations generated. SYMMETRY_TOL R [units] This parameter is the tolerance within which symmetry will be considered to be satisfied. If an ion is found within this distance of its symmetric position, the symmetry will be considered to be satisfied. [units] specifies the units in which the tolerance is defined. If not present, the default is \u00c5. Alternatively, the symmetry operations may be provided directly in a SYMMETRY_OPS block. The symmetry of the cell is represented as a series of symmetry operations under which the unit cell is invariant. Each operation is represented as a 3\\times 3 3\\times 3 array. %BLOCK SYMMETRY_OPS R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 ... %ENDBLOCK SYMMETRY_OPS Each of the first three lines contains 3 entries representing a row of a 3\\times3 3\\times3 array. These represent one symmetry rotation. The three entries on the following line contain the translation associated with this rotation. Constraints The movement of ions or the unit cell during a relaxation or molecular dynamics run may be constrained. The constraints on the ionic motion may by specified as a set of linear constraints. Each constraint is specified as a series of coefficients a_{ijk} a_{ijk} such that: $$ \\sum_{k=1}^{\\tt N_\\mathrm{species}} \\quad \\sum_{j=1}^{\\mathrm{N_\\mathrm{ions}}(k)} \\quad \\sum_{i=1}^{3} a_{ijk} \\verb#ionic_positions(i,j,k)# = constant $$ where \\mathrm{N_\\mathrm{ions}}(k) \\mathrm{N_\\mathrm{ions}}(k) is the number of ions in species k k . The change in the shape of the unit cell may also be constrained using the keyword CELL_CONSTRAINTS . The special case of constraining the centre of mass of the ions to remain fixed is supported by a logical keyword FIX_COM . Also all ionic positions or cell parameters may be fixed by specifying the keywords FIX_ALL_IONS or FIX_ALL_CELL to be TRUE respectively. If no ionic or cell constraints are specified in the cell definition file, the default is to fix the centre of mass. %BLOCK IONIC_CONSTRAINTS I_1 CCC_{1s} I_{1s} I_{n1} R_{1i} R_{1j} R_{1k} I_2 CCC_{2s} I_{2s} I_{n2} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK IONIC_CONSTRAINTS The first element on each line is an integer specifying the number of the constraint being specified. The second entry is either the symbol or atomic number of the species of the ion to which this constraint applies. The third element is the number of the ion within the species. The ordering of the ions in a species is the order in which they appear in the POSITIONS_FRAC or POSITIONS_ABS block in the cell definition file. The final three numbers are real numbers representing the coefficients of the Cartesian coordinates of the ionic position in the constraint sum. All coefficients in the sum not explicitly specified will be zero. On reading this data, the matrix of ionic constraints will be orthogonalised. %BLOCK CELL_CONSTRAINTS I_a I_b I_c I_alpha I_beta I_gamma %ENDBLOCK CELL_CONSTRAINTS The first three entries relate to the magnitude of the three lattice vectors a,b,c a,b,c and the second set of three entries to the angles \\alpha, \\beta, \\gamma \\alpha, \\beta, \\gamma . If the value of the entry corresponding to a magnitude or angle is zero, this quantity will remain fixed. If two or three entries contain the same integer, the corresponding quantities will be constrained to have the same value. If a positive integer greater than 0 occurs in entries 1 through 3 the same integer cannot occur in entries 4 through 6 as this would imply that a vector length and angle must have the same value. Species Characteristics The mass of a species, the pseudopotential which represents the ion and the size of the LCAO basis set used for population anslsyis may be specified in the cell definition file. %BLOCK SPECIES_MASS [units] CCC_1 I_1 R_1 CCC_2 I_2 R_2 ... %ENDBLOCK SPECIES_MASS [units] specifies the units in which the masses are defined. If not present, the default is atomic mass units. The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the mass of that species. Not all species need appear in the SPECIES_MASS block, any not present will assume the default mass for that species. If the initial alphabetical symbol specified for a species is not a standard element symbol in the periodic table, the mass of the species must be specified. %BLOCK SPECIES_POT CCC_1 I_1 <filename> CCC_2 I_2 <filename> ... %ENDBLOCK SPECIES_POT The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the filename of the file containing the definition of the pseudopotential representing the ionic species. The file to which this refers may be a definition of the parameters of the pseudopotential which is to be generated at runtime, or an old-style pseudopotential definition containing the data for the pseudopotential. Not all species need appear in the SPECIES_POT block. If a pseudopotential is not specified, the default pseudopotential parameters will be used to generate a pseudopotential for the element specified. If the initial alphabetical characters of a species label is not a standard element symbol in the periodic table, the potential for the species must be specified. The charge on the ion for each species will be derived from the pseudopotential corresponding to that ion. %BLOCK SPECIES_LCAO_STATES CCC_1 I_1 I_{B1} CCC_2 I_2 I_{B2} ... %ENDBLOCK SPECIES_LCAO_STATES The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second number is the number of angular momentum channels to use in the LCAO basis set for the species when performing population analysis. For example, to use the 2s and 2p states for C (The 1s state is a core state) this should be 2. By default, the number of states will be the appropriate number to complete the valence shell to the next noble gas. If shallow core states are excluded from a pseudopotential, the value of SPECIES_LCAO_STATES for that species should be included in the cell file to ensure a meaningful basis set is used. External Pressure An external pressure may be applied to the unit cell by specifying a pressure tensor. %BLOCK EXTERNAL_PRESSURE [units] R_{xx} R_{xy} R_{xz} R_{yy} R_{yz} R_{zz} %ENDBLOCK EXTERNAL_PRESSURE [units] specifies the units in which the pressure is defined. If not present, the default is GPa. Entry R_{xx} R_{xx} is the xx xx -component of the pressure, R_{xy} R_{xy} the xy xy -component etc. The default is to apply no external pressure. Ionic Velocities The initial ionic velocities may be specified in Cartesian coordinates in a cell definition file. %BLOCK IONIC_VELOCITIES [units] CCC_1 V_{1x} V_{1y} V_{1z} CCC_2 V_{2x} V_{2y} V_{2z} ... %ENDBLOCK IONIC_VELOCITIES The first entry on a line is the chemical symbol (or atomic number) of the ionic species. The correct symbol will be looked up for the atomic species if the atomic number is specified. A symbol can have a maximum of three characters. The next three entries are real numbers representing the velocity of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5/ps. If this keyword is not present and a molecular dynamics calculation is performed, the ionic velocities will be randomly initialised with the appropriate temperature.","title":"cell file"},{"location":"documentation/Input_Files/cell_file/#cell-lattice-vectors","text":"The cell lattice vectors may be specified in Cartesian coordinates or in terms of the lattice vector magnitudes and the angles between them ( a, b, c, \\alpha, \\beta, \\gamma a, b, c, \\alpha, \\beta, \\gamma ). Only one of LATTICE_CART and LATTICE_ABC may occur in a cell definition file. The definitions of these keywords are as follows: %BLOCK LATTICE_CART [units] a_x a_y a_z b_x b_y b_z c_x c_y c_z %ENDBLOCK LATTICE_CART Here a_x is the x-component of the first lattice vector, \\mathbf{a} \\mathbf{a} , b_y b_y is the y-component of the second lattice vector, \\mathbf{b} \\mathbf{b} , etc. [units] specifies the units in which the lattice vectors are defined. If not present, the default is \u00c5. %BLOCK LATTICE_ABC [units] a b c alpha beta gamma %ENDBLOCK LATTICE_ABC Here a is the value of the lattice constant \\vert\\mathbf{a}\\vert \\vert\\mathbf{a}\\vert , gamma is the value of the cell angle \\gamma \\gamma (in degrees) etc. If the lattice is specified in this manner, the absolute orientation is arbitrary. In this case the orientation is defined by applying the following constraints: \\mathbf{a} \\mathbf{a} lies along the x-axis \\mathbf{b} \\mathbf{b} lies in the xy plane \\mathbf{c} \\mathbf{c} forms a right-handed set with \\mathbf{a} \\mathbf{a} and \\mathbf{b} \\mathbf{b} [units] specifies the units in which the lattice vector magnitudes are defined. If not present, the default is \u00c5. Angles should be specified in degrees.","title":"Cell Lattice Vectors"},{"location":"documentation/Input_Files/cell_file/#ionic-positions","text":"The ionic positions may be specified in fractional coordinates relative to the lattice vectors of the unit cell, or in absolute coordinates. Only one of POSITIONS_FRAC and POSITIONS_ABS may occur in a cell definition file. %BLOCK POSITIONS_FRAC CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK END POSITIONS_FRAC The first entry on a line is the symbol of the species (chemical element). Alternatively, the atomic number may be given instead, in which case CASTEP will be look up for chemical symbol. A symbol can have a maximum of three characters. The first alphabetical characters identify the element, from which default values for atomic mass etc. The next three entries on a line in POSITIONS_FRAC are real numbers representing the position of the ion in fractions of the unit cell lattice vectors. If the optional flag SPIN is present on a line, this sets the spin polarisation ( N^\\uparrow-N^\\downarrow N^\\uparrow-N^\\downarrow ) of the atom for initialisation of the spin density; for non-collinear spin calculations, the vector spin is specified as three numbers. If this flag is not present a non-spin polarised state will be assumed. %BLOCK POSITIONS_ABS [units] CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK POSITIONS_ABS The first entry on a line is the symbol or atomic number of the ionic species, as for POSITIONS_FRAC . The next three entries are real numbers representing the position of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5. The optional flag SPIN is defined above under POSITIONS_FRAC .","title":"Ionic Positions"},{"location":"documentation/Input_Files/cell_file/#brillouin-zone-sampling-k-points","text":"(N.B. in the following section the keywords with the prefixes KPOINT_ and KPOINTS_ are synonymous. KPOINT_ is the preferred usage.) The k-points at which the Brillouin zone is to be sampled during a self consistent calculation to find the electronic ground state may be defined either by specifying a list of k-points or a Monkhorst-Pack grid in terms of the dimensions of the k-point mesh or a minimum k-point density. The origin of the Monkhorst-Pack grid may be offset by a vector from the origin of the Brillouin zone. If no k-points are specified, the default will be a Monkhorst-Pack grid with a maximum spacing of 0.1\u00c5 ^{-1} ^{-1} and no offset of the origin. The KPOINT_LIST , KPOINT_MP_GRID and KPOINT_MP_SPACING keywords are mutually exclusive. KPOINT_MP_OFFSET may be specified in combination with either KPOINT_MP_GRID or KPOINT_MP_SPACING . %BLOCK KPOINT_LIST \\begin{array}{cccc} R_{1i} R_{1j} R_{1k} R_{1w} R_{2i} R_{2j} R_{2k} R_{2w} ... %ENDBLOCK KPOINT_LIST The first three entries on a line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The final entry on a line is the weight of the k-point relative to the others specified. The sum of the weights must be equal to 1. KPOINT_MP_GRID I_i I_j I_k This specifies the dimensions of the Monkhorst-Pack grid requested in the directions of the reciprocal space lattice vectors. The generated grid will be I_i\\times I_j\\times I_k I_i\\times I_j\\times I_k ; any symmetries generated (or supplied) will be used to reduce this number, when computing the irreducible wedge. KPOINT_MP_SPACING R [units] The single entry is the maximum distance between k-points on the Monkhorst-Pack grid. The dimensions of the grid will be chosen such that the maximum separation of k-points is less than this. [units] specifies the units in which the k-point spacing is defined, although note that the actual units used are 2\\pi 2\\pi units . If not present, the default is ang-1 , such that the spacing is in 2\\pi \u00c5^{-1} 2\\pi \u00c5^{-1} . KPOINT_MP_OFFSET R_i R_j R_k This specifies the offset of the Monkhorst-Pack grid with respect to the origin of the Brillouin zone. The three entries are the offset in fractional coordinates relative to the reciprocal lattice vectors. The k-point set for performing spectral calculations can be specified in the same manner, using version of the keywords above with SPECTRAL_ prepended. The same restrictions regarding mutually exclusive keywords apply. For a non-self-consistent spectral calculation, the k-points may be defined along a path through reciprocal space or a list of k-points. %BLOCK SPECTRAL_KPOINT_PATH R_{1i} R_{1j} R_{1k} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK SPECTRAL_KPOINT_PATH The three numbers on each line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The k-points define a continuous sequence of straight line segments, unless the keyword BREAK appears on a separate line within the sequence of k-points. In this case the continuous path will end at the k-point immediately preceding the BREAK keyword and resume at the k-point immediately following. The path will be open unless the first and last point in the list are identical . The maximum spacing of the points sampled along each line segment is defined by the keyword SPECTRAL_KPOINT_PATH_SPACING (default value 0.1 \\times 2\\pi 0.1 \\times 2\\pi \u00c5 ^{-1} ^{-1} ). If necessary, the actual spacing used may be smaller than this in order to ensure that the length of the line segment is an integer multiple of the spacing between points on that segment. Alternatively, the k-point set for performing a band structure calculation can be specified in the same manner as the main k-point set, using version of the keywords above with BS_ prepended. The same restrictions regarding mutually exclusive keywords apply. In this case, the k-point weight in SPECTRAL_KPOINT_LIST is optional. If omitted, the weights for each k-point are assumed to be equal. For a phonon spectrum calculation, the k-points may be defined along a path through reciprocal space or a list of k-points, in the same manner as for a spectral calculation. The corresponding keywords are identical to those for the band structure specification with the initial SPECTRAL_ replaced by PHONON_ , e.g. PHONON_KPOINT_PATH , PHONON_KPOINT_PATH_SPACING and PHONON_KPOINT_LIST . The same restrictions regarding mutually exclusive keywords apply. The block keyword PHONON_GAMMA_DIRECTIONS specifies the directions in which the gamma point will be approached when calculating the non-analytic terms of the LO/TO splitting. Each line in this block will consist of a 3-vector specifying a direction in the basis of reciprocal lattice vectors. If this keyword is not present, the default will be a single vector determined as follows: If the gamma point is q_i = 0 q_i = 0 and there is a successor kpoint q_{i+1} q_{i+1} in the list, then it is q_{i+1} q_{i+1} . Otherwise if the gamma point is q_i =0 q_i =0 and there is a predecessor kpoint q_{i-1} q_{i-1} in the list then it is q_{i-1} q_{i-1} . Otherwise (i.e. a Gamma point only calculation) the a-axis of the reciprocal cell. For backwards compatibility the keywords beginning BS_ and OPTICS_ are synonyms for SPECTRAL_KPOINT_ and similarly those beginning.","title":"Brillouin Zone Sampling (k-points)"},{"location":"documentation/Input_Files/cell_file/#cell-symmetry","text":"If no symmetry is specified in the cell definition file, the default is for no symmetry to be applied. SYMMETRY_GENERATE If this keyword is present in the cell, the highest symmetry group that applies to the structure of the cell will be found and the corresponding symmetry operations generated. SYMMETRY_TOL R [units] This parameter is the tolerance within which symmetry will be considered to be satisfied. If an ion is found within this distance of its symmetric position, the symmetry will be considered to be satisfied. [units] specifies the units in which the tolerance is defined. If not present, the default is \u00c5. Alternatively, the symmetry operations may be provided directly in a SYMMETRY_OPS block. The symmetry of the cell is represented as a series of symmetry operations under which the unit cell is invariant. Each operation is represented as a 3\\times 3 3\\times 3 array. %BLOCK SYMMETRY_OPS R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 ... %ENDBLOCK SYMMETRY_OPS Each of the first three lines contains 3 entries representing a row of a 3\\times3 3\\times3 array. These represent one symmetry rotation. The three entries on the following line contain the translation associated with this rotation.","title":"Cell Symmetry"},{"location":"documentation/Input_Files/cell_file/#constraints","text":"The movement of ions or the unit cell during a relaxation or molecular dynamics run may be constrained. The constraints on the ionic motion may by specified as a set of linear constraints. Each constraint is specified as a series of coefficients a_{ijk} a_{ijk} such that: $$ \\sum_{k=1}^{\\tt N_\\mathrm{species}} \\quad \\sum_{j=1}^{\\mathrm{N_\\mathrm{ions}}(k)} \\quad \\sum_{i=1}^{3} a_{ijk} \\verb#ionic_positions(i,j,k)# = constant $$ where \\mathrm{N_\\mathrm{ions}}(k) \\mathrm{N_\\mathrm{ions}}(k) is the number of ions in species k k . The change in the shape of the unit cell may also be constrained using the keyword CELL_CONSTRAINTS . The special case of constraining the centre of mass of the ions to remain fixed is supported by a logical keyword FIX_COM . Also all ionic positions or cell parameters may be fixed by specifying the keywords FIX_ALL_IONS or FIX_ALL_CELL to be TRUE respectively. If no ionic or cell constraints are specified in the cell definition file, the default is to fix the centre of mass. %BLOCK IONIC_CONSTRAINTS I_1 CCC_{1s} I_{1s} I_{n1} R_{1i} R_{1j} R_{1k} I_2 CCC_{2s} I_{2s} I_{n2} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK IONIC_CONSTRAINTS The first element on each line is an integer specifying the number of the constraint being specified. The second entry is either the symbol or atomic number of the species of the ion to which this constraint applies. The third element is the number of the ion within the species. The ordering of the ions in a species is the order in which they appear in the POSITIONS_FRAC or POSITIONS_ABS block in the cell definition file. The final three numbers are real numbers representing the coefficients of the Cartesian coordinates of the ionic position in the constraint sum. All coefficients in the sum not explicitly specified will be zero. On reading this data, the matrix of ionic constraints will be orthogonalised. %BLOCK CELL_CONSTRAINTS I_a I_b I_c I_alpha I_beta I_gamma %ENDBLOCK CELL_CONSTRAINTS The first three entries relate to the magnitude of the three lattice vectors a,b,c a,b,c and the second set of three entries to the angles \\alpha, \\beta, \\gamma \\alpha, \\beta, \\gamma . If the value of the entry corresponding to a magnitude or angle is zero, this quantity will remain fixed. If two or three entries contain the same integer, the corresponding quantities will be constrained to have the same value. If a positive integer greater than 0 occurs in entries 1 through 3 the same integer cannot occur in entries 4 through 6 as this would imply that a vector length and angle must have the same value.","title":"Constraints"},{"location":"documentation/Input_Files/cell_file/#species-characteristics","text":"The mass of a species, the pseudopotential which represents the ion and the size of the LCAO basis set used for population anslsyis may be specified in the cell definition file. %BLOCK SPECIES_MASS [units] CCC_1 I_1 R_1 CCC_2 I_2 R_2 ... %ENDBLOCK SPECIES_MASS [units] specifies the units in which the masses are defined. If not present, the default is atomic mass units. The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the mass of that species. Not all species need appear in the SPECIES_MASS block, any not present will assume the default mass for that species. If the initial alphabetical symbol specified for a species is not a standard element symbol in the periodic table, the mass of the species must be specified. %BLOCK SPECIES_POT CCC_1 I_1 <filename> CCC_2 I_2 <filename> ... %ENDBLOCK SPECIES_POT The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the filename of the file containing the definition of the pseudopotential representing the ionic species. The file to which this refers may be a definition of the parameters of the pseudopotential which is to be generated at runtime, or an old-style pseudopotential definition containing the data for the pseudopotential. Not all species need appear in the SPECIES_POT block. If a pseudopotential is not specified, the default pseudopotential parameters will be used to generate a pseudopotential for the element specified. If the initial alphabetical characters of a species label is not a standard element symbol in the periodic table, the potential for the species must be specified. The charge on the ion for each species will be derived from the pseudopotential corresponding to that ion. %BLOCK SPECIES_LCAO_STATES CCC_1 I_1 I_{B1} CCC_2 I_2 I_{B2} ... %ENDBLOCK SPECIES_LCAO_STATES The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second number is the number of angular momentum channels to use in the LCAO basis set for the species when performing population analysis. For example, to use the 2s and 2p states for C (The 1s state is a core state) this should be 2. By default, the number of states will be the appropriate number to complete the valence shell to the next noble gas. If shallow core states are excluded from a pseudopotential, the value of SPECIES_LCAO_STATES for that species should be included in the cell file to ensure a meaningful basis set is used.","title":"Species Characteristics"},{"location":"documentation/Input_Files/cell_file/#external-pressure","text":"An external pressure may be applied to the unit cell by specifying a pressure tensor. %BLOCK EXTERNAL_PRESSURE [units] R_{xx} R_{xy} R_{xz} R_{yy} R_{yz} R_{zz} %ENDBLOCK EXTERNAL_PRESSURE [units] specifies the units in which the pressure is defined. If not present, the default is GPa. Entry R_{xx} R_{xx} is the xx xx -component of the pressure, R_{xy} R_{xy} the xy xy -component etc. The default is to apply no external pressure.","title":"External Pressure"},{"location":"documentation/Input_Files/cell_file/#ionic-velocities","text":"The initial ionic velocities may be specified in Cartesian coordinates in a cell definition file. %BLOCK IONIC_VELOCITIES [units] CCC_1 V_{1x} V_{1y} V_{1z} CCC_2 V_{2x} V_{2y} V_{2z} ... %ENDBLOCK IONIC_VELOCITIES The first entry on a line is the chemical symbol (or atomic number) of the ionic species. The correct symbol will be looked up for the atomic species if the atomic number is specified. A symbol can have a maximum of three characters. The next three entries are real numbers representing the velocity of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5/ps. If this keyword is not present and a molecular dynamics calculation is performed, the ionic velocities will be randomly initialised with the appropriate temperature.","title":"Ionic Velocities"},{"location":"documentation/Input_Files/cell_keywords/","text":"This is a concise list of the common keywords for CASTEP's cell input file. The definitions of the keywords are given in more detail in the section on the cell file . Keyword in the cell file Type Default Description LATTICE_CART ^1 ^1 B -- The cell lattice vectors in Cartesian coordinates. LATTICE_ABC ^1 ^1 B -- The cell lattice vectors specified in $ a, b, c, \\alpha, \\beta, \\gamma $ format. POSITIONS_FRAC ^2 ^2 B -- The positions of the ions in fraction coordinates with respect to the lattice vectors. POSITIONS_ABS ^2 ^2 B -- The positions of the ions in absolute coordinates. KPOINT_LIST ^3 ^3 B -- A list of k-points in the Brillouin zone with associated weights. KPOINT_MP_GRID ^3 ^3 W -- The k-points defined as a Monkhorst-Pack grid by specifying the grid dimensions in each direction. KPOINT_MP_SPACING ^3 ^3 P 0.1 \u00c5^{-1} \u00c5^{-1} The k-points as a Monkhorst-Pack grid by specifying the maximum distance between k-points. KPOINT_MP_OFFSET V 0,0,0 The offset of the origin of the Monkhorst-Pack grid in fractional coordinates relative to the reciprocal lattice vectors. SPECTRAL_KPOINT_PATH ^4 ^4 B -- A list of k-points in the Brillouin zone which defines the path along which a band-structure calculation will be performed. SPECTRAL_KPOINT_PATH_SPACING P 0.1 \u00c5^{-1} \u00c5^{-1} Specifies the maximum spacing between k-points along the path for which a band structure calculation will be performed. SPECTRAL_KPOINT_LIST ^4 ^4 B SCF k-points A list of k-points at which a band-structure calculation will be performed. SPECTRAL_KPOINT_MP_GRID ^4 ^4 W -- The k-points for optical matrix element calculations defined as a Monkhorst-Pack grid by specifying the grid dimensions in each direction. SPECTRAL_KPOINT_MP_SPACING ^4 ^4 P 0.1 \u00c5 ^{-1} ^{-1} The k-points for optical matrix element calculations as a Monkhorst-Pack grid by specifying the maximum distance between k-points. SPECTRAL_KPOINT_MP_OFFSET V 0,0,0 The offset of the origin of the Monkhorst-Pack grid for optical matrix element calculations in fractional coordinates relative to the reciprocal lattice vectors. PHONON_KPOINT_PATH ^5 ^5 B -- A list of k-points in the Brillouin zone which defines the path along which a phonon calculation will be performed. PHONON_KPOINT_PATH_SPACING P 0.1 \u00c5 ^{-1} ^{-1} Specifies the maximum spacing between k-points along the path for which a phonon calculation will be performed. PHONON_KPOINT_LIST ^5 ^5 B SCF k-points A list of k-points at which a phonon calculation will be performed. PHONON_GAMMA_DIRECTIONS B See text The directions in which the gamma point will be approached for calculation of the LO/TO splitting. SYMMETRY_GENERATE ^6 ^6 D no symmetry If this is present, the highest symmtery group of the cell will found and the corresponding symmetry operations generated. SYMMETRY_OPS ^6 ^6 B no symmetry The symmetry operations that apply to the cell. SYMMETRY_TOL P 0.01 \u00c5 The tolerance within which symmetry will be enforced. IONIC_CONSTRAINTS B no constraints The constraints on the motion of ions during relaxation or MD. FIX_ALL_IONS L FALSE Constrain all ionic positions to remain fixed. FIX_ALL_CELL L FALSE Constrain all cell parameters to remain fixed. FIX_COM L TRUE Constrain the centre of mass of the ions to remain fixed. CELL_CONSTRAINTS B no constraints The constraints on changes in the cell shape during relaxation or MD. SPECIES_MASS B atomic mass The masses of the ionic species. SPECIES_POT B see text The names of the pseudopotentials associated with each species. SPECIES_LCAO_STATES B see text The number of angular momentum states to use in the LCAO basis set for this species when performing population analysis. EXTERNAL_PRESSURE B no pressure The external pressure tensor. IONIC_VELOCITIES B random The velocities of the ions in Cartesian coordinates. For the argument types, B indicates block data, P means a physical value, L is a logical value, D is a keyword that may simply be defined (present) or not, V is a real vector and W is an integer vector. ^1 ^1 Only one of LATTICE_CART and LATTICE_ABC maybe present in a cell file. ^2 ^2 Only one of POSITIONS_FRAC and POSITIONS_ABS may be present in a cell file. ^3 ^3 Only one of KPOINTS_LIST , KPOINTS_MP_GRID and KPOINTS_MP_SPACING may be present in a cell file. ^4 ^4 Only one of SPECTRAL_KPOINT_PATH , SPECTRAL_KPOINTS_MP_GRID , SPECTRAL_KPOINTS_MP_SPACING and SPECTRAL_KPOINT_LIST may be present in a cell file. ^5 ^5 Only one of PHONON_KPOINT_PATH and PHONON_KPOINT_LIST may be present in a cell file. ^6 ^6 Only one of SYMMETRY_GENERATE and SYMMETRY_OPS may be present in a cell file.","title":"cell keywords"},{"location":"documentation/Input_Files/output_files/","text":"CASTEP writes output data in a variety of files. Some of these will be in human readable ASCII format (i.e. plaintext) and can be read with commands such as less or more on linux, or with a simple text editor (textedit, notepad etc). Other files will be in binary format and are designed to be read or processed with an external program. Groundstate .castep ASCII. Castep's main outputfile. .bib ASCII. Bibtex file containing citations to the methods CASTEP has used in the calculation. .check Binary. This checkpoint file contains the results of the calculation including the groundstate charge density and wavefunctions. It is typically a very large file. Will be read by CASTEP when performing a continuation calculation. Also read by postprocessing software such as c2x. .check_bak Binary. backup of the checkpoint file. .cst_esp Binary. Electrostatic potential. .usp ASCII. Pseudoptential data, written for each species. See the page on reading usp headers .uspso ASCII. Pseudoptential data, written for each species. This is the J-dependant version of the .usp . See the page on reading usp headers .bands ASCII. Kohn-Sham eigenvalues at the requested k-points. Can be used to plot band structures or density of states. Note that the eigenvalues are given in atomic units (Hartree). .den_fmt ASCII. Charge density. Only written if write_formatted_density : T . .pot_fmt ASCII. Groundstate potential. Only written if write_formatted_potential : T . .chdiff Binary. Difference between the groundstate charge density and a superposition of atomic densities. Only written if calculate_densdiff : T .chdiff_fmt ASCII. same data as .chdiff in human readable format. Only written if calculate_densdiff : T and write_formatted_density : T . .xrd_sf ASCII. X-ray structure factors. See the documentation page Geometry Optimisation *.geom ASCII. State of the system (coordinates, unit cell etc) at each step of the geometry optimisation. See for specification. Can be used to animate the geometry optimisation - can be read with Jmol. Molecular Dynamics *.md ASCII. State of the system (coordinates, unit cell etc) at each step of the molecular dynamics simulation. Same format as the .geom file. See for specification. Can be used to animate the geometry optimisation - can be Spectral .pdos_bin Binary. Matrix elements used for plotting a projected density of states. Used by Optados. .ome_bin Binary. Matrix elements used for calculating optical properties. Used by Optados. .dome_bin Binary. Diagonal elements of the optical matrix elements. Used by Optados to plot densities of states / spectral properties using adaptive smearing. .elnes_bin Binary. Matrix elements used for plotting the core-loss spectrum. Used by Optados. .orbitals Binary. Kohn-Sham states at each kpoints. Used by orbital2bands to make a reorganised .bands file for a cleaner looking bandstructure. Phonon .phonon ASCII. Phonon eigenvalues and eigenvectors. Magres .magres ASCII. Contain the NMR tensors (depending on magres_task shielding, EFG or J). Read by MagresView or the Soprano python libraries. _current.dat ASCII. Written if MAGRES_WRITE_RESPONSE=True . Used to compute NICS (nucleus independent chemical shifts) see https://www.ccpnc.ac.uk/docs/nics Transition state search .ts ASCII. See the specification in the documentation pages","title":"output files"},{"location":"documentation/Input_Files/output_files/#groundstate","text":".castep ASCII. Castep's main outputfile. .bib ASCII. Bibtex file containing citations to the methods CASTEP has used in the calculation. .check Binary. This checkpoint file contains the results of the calculation including the groundstate charge density and wavefunctions. It is typically a very large file. Will be read by CASTEP when performing a continuation calculation. Also read by postprocessing software such as c2x. .check_bak Binary. backup of the checkpoint file. .cst_esp Binary. Electrostatic potential. .usp ASCII. Pseudoptential data, written for each species. See the page on reading usp headers .uspso ASCII. Pseudoptential data, written for each species. This is the J-dependant version of the .usp . See the page on reading usp headers .bands ASCII. Kohn-Sham eigenvalues at the requested k-points. Can be used to plot band structures or density of states. Note that the eigenvalues are given in atomic units (Hartree). .den_fmt ASCII. Charge density. Only written if write_formatted_density : T . .pot_fmt ASCII. Groundstate potential. Only written if write_formatted_potential : T . .chdiff Binary. Difference between the groundstate charge density and a superposition of atomic densities. Only written if calculate_densdiff : T .chdiff_fmt ASCII. same data as .chdiff in human readable format. Only written if calculate_densdiff : T and write_formatted_density : T . .xrd_sf ASCII. X-ray structure factors. See the documentation page","title":"Groundstate"},{"location":"documentation/Input_Files/output_files/#geometry-optimisation","text":"*.geom ASCII. State of the system (coordinates, unit cell etc) at each step of the geometry optimisation. See for specification. Can be used to animate the geometry optimisation - can be read with Jmol.","title":"Geometry Optimisation"},{"location":"documentation/Input_Files/output_files/#molecular-dynamics","text":"*.md ASCII. State of the system (coordinates, unit cell etc) at each step of the molecular dynamics simulation. Same format as the .geom file. See for specification. Can be used to animate the geometry optimisation - can be","title":"Molecular Dynamics"},{"location":"documentation/Input_Files/output_files/#spectral","text":".pdos_bin Binary. Matrix elements used for plotting a projected density of states. Used by Optados. .ome_bin Binary. Matrix elements used for calculating optical properties. Used by Optados. .dome_bin Binary. Diagonal elements of the optical matrix elements. Used by Optados to plot densities of states / spectral properties using adaptive smearing. .elnes_bin Binary. Matrix elements used for plotting the core-loss spectrum. Used by Optados. .orbitals Binary. Kohn-Sham states at each kpoints. Used by orbital2bands to make a reorganised .bands file for a cleaner looking bandstructure.","title":"Spectral"},{"location":"documentation/Input_Files/output_files/#phonon","text":".phonon ASCII. Phonon eigenvalues and eigenvectors.","title":"Phonon"},{"location":"documentation/Input_Files/output_files/#magres","text":".magres ASCII. Contain the NMR tensors (depending on magres_task shielding, EFG or J). Read by MagresView or the Soprano python libraries. _current.dat ASCII. Written if MAGRES_WRITE_RESPONSE=True . Used to compute NICS (nucleus independent chemical shifts) see https://www.ccpnc.ac.uk/docs/nics","title":"Magres"},{"location":"documentation/Input_Files/output_files/#transition-state-search","text":".ts ASCII. See the specification in the documentation pages","title":"Transition state search"},{"location":"documentation/Input_Files/param_file/","text":"This is a detailed description of options for CASTEP's param file. See the basic param file page for an overview. This page has the most frequently-used param file options, but for a full set use CASTEP's built-in help . The param file is one of CASTEP's two main input files. It contains all of the information about the kind of simulation your wish CASTEP to perform, as well as details of how CASTEP should perform them and additional simulations and analyses. The file itself is a free-format keyword-driven text file, consisting largely of single-line keywords, although there are a small number of blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. All of the keywords and blocks are optional, but you will almost always want to change at least some. Task This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file . Cut-off energy The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV. XC functional Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"param file"},{"location":"documentation/Input_Files/param_file/#task","text":"This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file .","title":"Task"},{"location":"documentation/Input_Files/param_file/#cut-off-energy","text":"The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV.","title":"Cut-off energy"},{"location":"documentation/Input_Files/param_file/#xc-functional","text":"Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"XC functional"},{"location":"documentation/Molecular_Dynamics/overview/","text":"Instead of using the forces to optimise the structure of the system, CASTEP can instead use the forces to accelerate the atoms (and cell-shape) in order to simulate dynamical properties - a method known as \"Molecular Dynamics\" or simply \"MD\". To perform this kind of calculation, set task : MD in your param file. CASTEP has a wide range of Molecular Dynamics (MD) capabilities, and can do equilibrium MD using a variety of ensembles: * NVE - the microcanonical ensemble - with fixed number of atoms, volume of cell, and total energy conserved * NVT - the canonical ensemble - with constant temperature not constant energy - due to the application of a thermostat * NPH - constant external pressure and enthalpy - due to the application of a barostat * NPT - constant external pressure and temperature - due to the application of a barostat and a thermostat Of thse, NPT is the closest to most real-life experiments. Of the different thermostats, CASTEP supports Nose-Hoover, Nose-Hoover chains, Langevin and Hoover-Langevin. Of the different barostats, CASTEP supports the isotropic Andersen-Hoover barostat, and the anisotropic Parrinello-Rahman barostat. CASTEP also supports the Berendsen thermostat and barostat, as a route to faster equilibration before switching to one of the above thermostats/barostats for production data. CASTEP can also go beyond the Born-Oppenheimer approximation to do quantum dynamics, using Path Integral Molecular Dynamics (PIMD), in either NVT or NPT ensembles. In all MD schemes, CASTEP can support both linear and non-linear constraints on the ionic positions and/or on the cell vectors. The detailed trajectory information is written to either <seed>.geom or <seed>.md files, which are structured text files, for ease of manipulation and post-calculation analysis.","title":"Overview"},{"location":"documentation/NMR/NMR_overview/","text":"Diamagnetic Insulators By a diamagnetic insulator we mean a system with an electronic gap between its highest occupied state and lowest unoccupied state, and all of the electronic spins are paired, simple examples are diamond, quartz, glycine\u2026 This class of materials is the most suitable for calculations as the main NMR interactions, magnetic sielding, J-coupling and electric field gradients can all be computed. Magnetic Shielding In a diamagnetic insulator this arises from orbital currents induced by an external magnetic field. This current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , produces a non-uniform induced magnetic field in the material, which is given by the Biot-Savart law as {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. The shielding tensor is defined as the ratio between this induced field, and the external applied field {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. It can thus be seen that the question of computing the shielding tensor is that of computing the induced electronic current. J-coupling The J-coupling is a small perturbation to the electronic ground-state of the system and we can identify it as a derivative of the total energy E, of the system {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} An equivalent expression arises from considering one nuclear spin (L) as perturbation which creates a magnetic field at a second (receiving) nucleus (K) {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. Eqn.~\\ref{eq:J} tells us that the question of computing J is essentially that of computing the magnetic field induced indirectly by a nuclear magnetic moment. When spin-orbit coupling is neglected we can consider the field as arising from two, essentially independent, mechanisms. Firstly, the magnetic moment can interact with electronic charge inducing an orbital current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , which in turn creates a magnetic field at the other nuclei in the system. This mechanism is similar to the case of magnetic shielding in insulators. The second mechanism arises from the interaction of the magnetic moment with the electronic spin, causing an electronic spin polarisation. By working to first order in these quantities we can write the magnetic field at atom {\\rm K} {\\rm K} induced by the magnetic moment of atom {\\rm L} {\\rm L} as {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. Several quantum chemistry packages provide the ability to compute J coupling tensors in molecular systems (see Ref 1 } for a review of methods). An approach to compute J tensors within the planewave-pseudopotential approach has recently been developed. 2 EFG For a nucleus with spin > > \u00bd the NMR response will include an interaction between the quadrupole moment of the nucleus, Q, and the electric field gradient (EFG) generated by the surrounding electronic structure. The EFG is a second rank, symmetric, traceless tensor G({\\bf r}) G({\\bf r}) given by G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} where \\alpha,\\beta,\\gamma \\alpha,\\beta,\\gamma denote the Cartesian coordinates x,y,z and E_{\\alpha}({\\bf r}) E_{\\alpha}({\\bf r}) is the local electric field at the position {\\bf r} {\\bf r} , which can be calculated from the charge density n({\\bf r}) n({\\bf r}) : \\begin{equation} E_{\\alpha}({\\bf r})=\\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3} (r_{\\alpha}-r_{\\alpha}'). \\end{equation} The EFG tensor is then equal to \\begin{equation}\\label{eq:efg_rs} G_{\\alpha\\beta}({\\bf r}) = \\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3}\\left[ \\delta_{\\alpha\\beta} -3 \\frac{(r_{\\alpha}-r_{\\alpha}')(r_{\\beta}-r_{\\beta}')}{|{\\bf r}-{\\bf r}'|^2}\\right]. \\end{equation} The computation of electric field gradient tensors is less demanding than either shielding or J-coupling tensors as it requires only knowledge of the electronic ground state. The LAPW approach in its implementation within the Wien series of codes\\cite{blaha90} has been widely used and shown to reliably predict Electric Field Gradient (EFG) tensors 3 . The equivalent formalism for the planewave/PAW approach is reported in Ref.~\\cite{profeta03}. The quadrupolar coupling constant, C _Q _Q and the asymmetry parameter, \\eta_Q \\eta_Q can be obtained from the the diagonalized electric field gradient tensor whose eigenvalues are labelled V _{xx} _{xx} , V _{yy} _{yy} , V _{zz} _{zz} , such that |V_{zz}|>|V_{yy}|>|V_{xx}| |V_{zz}|>|V_{yy}|>|V_{xx}| : \\begin{equation} C_{Q}=\\frac{eV_{zz}Q}{h}, \\end{equation} where h is Planck's constant and \\begin{equation} \\eta_Q=\\frac{V_{xx}-V_{yy}}{V_{zz}}. \\end{equation} Helgaker, T.; Jaszunski, M.; Pecul, M.Progress in Nuclear Magnetic Resonance Spectroscopy2008,53, 249 \u2013 268 \u21a9 Joyce, S. A.; Yates, J. R.; Pickard, C. J.; Mauri, F.J. Chem. Phys.2007,127, 204107 \u21a9 Blaha, P.; Sorantin, P.; Ambrosch, C.; Schwarz, K.Hyperfine Interact.1989,51, 917 \u21a9","title":"NMR Overview"},{"location":"documentation/NMR/NMR_overview/#diamagnetic-insulators","text":"By a diamagnetic insulator we mean a system with an electronic gap between its highest occupied state and lowest unoccupied state, and all of the electronic spins are paired, simple examples are diamond, quartz, glycine\u2026 This class of materials is the most suitable for calculations as the main NMR interactions, magnetic sielding, J-coupling and electric field gradients can all be computed.","title":"Diamagnetic Insulators"},{"location":"documentation/NMR/NMR_overview/#magnetic-shielding","text":"In a diamagnetic insulator this arises from orbital currents induced by an external magnetic field. This current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , produces a non-uniform induced magnetic field in the material, which is given by the Biot-Savart law as {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. The shielding tensor is defined as the ratio between this induced field, and the external applied field {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. It can thus be seen that the question of computing the shielding tensor is that of computing the induced electronic current.","title":"Magnetic Shielding"},{"location":"documentation/NMR/NMR_overview/#j-coupling","text":"The J-coupling is a small perturbation to the electronic ground-state of the system and we can identify it as a derivative of the total energy E, of the system {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} An equivalent expression arises from considering one nuclear spin (L) as perturbation which creates a magnetic field at a second (receiving) nucleus (K) {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. Eqn.~\\ref{eq:J} tells us that the question of computing J is essentially that of computing the magnetic field induced indirectly by a nuclear magnetic moment. When spin-orbit coupling is neglected we can consider the field as arising from two, essentially independent, mechanisms. Firstly, the magnetic moment can interact with electronic charge inducing an orbital current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , which in turn creates a magnetic field at the other nuclei in the system. This mechanism is similar to the case of magnetic shielding in insulators. The second mechanism arises from the interaction of the magnetic moment with the electronic spin, causing an electronic spin polarisation. By working to first order in these quantities we can write the magnetic field at atom {\\rm K} {\\rm K} induced by the magnetic moment of atom {\\rm L} {\\rm L} as {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. Several quantum chemistry packages provide the ability to compute J coupling tensors in molecular systems (see Ref 1 } for a review of methods). An approach to compute J tensors within the planewave-pseudopotential approach has recently been developed. 2","title":"J-coupling"},{"location":"documentation/NMR/NMR_overview/#efg","text":"For a nucleus with spin > > \u00bd the NMR response will include an interaction between the quadrupole moment of the nucleus, Q, and the electric field gradient (EFG) generated by the surrounding electronic structure. The EFG is a second rank, symmetric, traceless tensor G({\\bf r}) G({\\bf r}) given by G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} where \\alpha,\\beta,\\gamma \\alpha,\\beta,\\gamma denote the Cartesian coordinates x,y,z and E_{\\alpha}({\\bf r}) E_{\\alpha}({\\bf r}) is the local electric field at the position {\\bf r} {\\bf r} , which can be calculated from the charge density n({\\bf r}) n({\\bf r}) : \\begin{equation} E_{\\alpha}({\\bf r})=\\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3} (r_{\\alpha}-r_{\\alpha}'). \\end{equation} The EFG tensor is then equal to \\begin{equation}\\label{eq:efg_rs} G_{\\alpha\\beta}({\\bf r}) = \\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3}\\left[ \\delta_{\\alpha\\beta} -3 \\frac{(r_{\\alpha}-r_{\\alpha}')(r_{\\beta}-r_{\\beta}')}{|{\\bf r}-{\\bf r}'|^2}\\right]. \\end{equation} The computation of electric field gradient tensors is less demanding than either shielding or J-coupling tensors as it requires only knowledge of the electronic ground state. The LAPW approach in its implementation within the Wien series of codes\\cite{blaha90} has been widely used and shown to reliably predict Electric Field Gradient (EFG) tensors 3 . The equivalent formalism for the planewave/PAW approach is reported in Ref.~\\cite{profeta03}. The quadrupolar coupling constant, C _Q _Q and the asymmetry parameter, \\eta_Q \\eta_Q can be obtained from the the diagonalized electric field gradient tensor whose eigenvalues are labelled V _{xx} _{xx} , V _{yy} _{yy} , V _{zz} _{zz} , such that |V_{zz}|>|V_{yy}|>|V_{xx}| |V_{zz}|>|V_{yy}|>|V_{xx}| : \\begin{equation} C_{Q}=\\frac{eV_{zz}Q}{h}, \\end{equation} where h is Planck's constant and \\begin{equation} \\eta_Q=\\frac{V_{xx}-V_{yy}}{V_{zz}}. \\end{equation} Helgaker, T.; Jaszunski, M.; Pecul, M.Progress in Nuclear Magnetic Resonance Spectroscopy2008,53, 249 \u2013 268 \u21a9 Joyce, S. A.; Yates, J. R.; Pickard, C. J.; Mauri, F.J. Chem. Phys.2007,127, 204107 \u21a9 Blaha, P.; Sorantin, P.; Ambrosch, C.; Schwarz, K.Hyperfine Interact.1989,51, 917 \u21a9","title":"EFG"},{"location":"documentation/Pseudopotentials/otfg_string/","text":"In addition to Chris' OTFG document, some more description of the OTF string 2|3.1|4.0|2.2|2|3|5|50U3.4:60U3.1:51:52U3.1{6s1.45,5d0.05}(qc=3)[] Quantities in <> are descriptions not literals. All chars outside <> are literal <Local cpt>|<r_c(loc)>|<r_c(nonloc)>|<rinner/rcore>|<COARSE>|<MEDIUM>|<FINE>| <proj1>:<proj2>...<projn>{<config>}(flags)[<test config>] Local cpt : 0,1,2 for s,p,d r_c(loc) : pseudisation radius for local component (atomic units) r_c(nl) : pseudisation radius for nonlocal components (atomic units) (can be overridden as part of projector description) rinner/rcore : Pseudisation radius for augmentation functions and pseudo-core charge COARSE/MEDIUM/FINE : Recommended cutoff energies in atomic units (Hartree) projn : Descriptions of projectors to include, separated by semicolons. Syntax of a projector is in its briefest form <n><l> where digits <n> and <l> denote the atomic quantum numbers eg 30 for 3s In fact this is equivalent to the expanded form \"<n><l>UU\" where the projector flags \"UU\" mean include two ultrasoft beta projectors for this channel. The full form is <n><l>[<type>[<r_c>]][+/-<dE_use>][@<shift>] where anything in brackets [] is optional (here only). <type> can be U - a single ultrasoft projector UU - Two ultrasoft projectors N - a single norm-conserving projector L - use this projector as the local component G - an ultrasoft GIPAW Gamma projector H - an norm-conserving GIPAW Gamma projector P - Dummy: do not make a projector. LG - Make Gammas for local channel (not done by default) <r_c> - the projector specific pseudisation radius. <dE_use> - the reference energy for the projector. A floating-point value beginning with an explicit '=', '+' or '-' in Hartree. '=E' means absolute energy, '+/-E' is relative to AE eigenvalue. <shift> - Add this value to the projector, it shift it in energy. config : Reference configuration used to generate pseudopotential specified in obvious way, eg {3s1,3d0.5}. It is not necessary to explicitly mention all core states - CASTEP figures this out. flags : Options controlling the type of pseudisation applied and parameters. Syntax (flag1,flag2, ) allows multiple, comma separated flags qc=<val> The optmisation parameter - KE for q < qc is minimised in optimised projector scheme. Can also write (qc=3,qc1=3.5) to specify angular momentum channel-specific value of qc. tm Troullier-Martins pseudosation scheme pn polynomial fit pb bessel fit es \"extra soft\" scheme esr=val extra-soft with explicit specification of r_c nonlcc Do not generate of unscreen with a pseudo-core charge. schro Use non-relativistic schroedinger equation for AE calculation (default is scalar relativistic eqn) aug Explicitly turn on augmentation charges scpsp Generate a self-consistent pseudopotential test config : Specify a non-default test configuration eg, [4s1.5,3d0.5].","title":"OTFG string"},{"location":"documentation/Pseudopotentials/overview/","text":"CASTEP has a built-in library of pseudopotentials which is usually updated each release. We refer to CASTEP's build-in pseudopotentials as on-the-fly generated (or OTFG). The default OTFG pseudopotentials are accurate ultrasoft pseudopotentials. These are used if species_pot block is not defined in the cell file - or an empty block is given %block species_pot %endblock species_pot For preliminary investigations and high-throughput calculations you might want to choose the QC5 set of ultrasoftpotentials which are faster, but slightly less accurate than the default set. These are designed to give converged results at 500eV for all elements: %block species_pot QC5 %endblock species_pot For properties that require norm-conserving pseudopotentials, you can select CASTEP's latest OTFG norm-conserving set with the following in the in your .cell file. %block species_pot NCP %endblock species_pot For backwards compatibility you can also select pseudopotentials from earlier versions on the on-the-fly database, e.g. use %block species_pot C17 %endblock species_pot to select the ultrasoft pseudopotentials from CASTEP version 17. You can also specify the pseudopotential on a per-element basis, e.g. %block species_pot Fe C17 O NCP Ba QC5 %endblock species_pot A complete list of the availible OTFG definitions follows: String Description NCP Alias for the most recent set of norm conserving potentials QC5 High through put set (delta=1.7meV, 0.8meV excluding N,O,Cr,Mn) HARD \"Ultimate\" set of HARD pseudopotentials C7 USP definitions as of CASTEP 7.0 (C7) C8 USP definitions as of CASTEP 8.0 (C8) C9 USP definitions as of CASTEP 9.0/16.0 delta=0.5meV NCP9 Set of Norm Conserving pseudopotentials CASTEP 9.0/16.0 (NCP9)(delta=1.1meV) C17 USP definitions, CASTEP 17.0 (C17) NCP19 Set of Norm Conserving pseudopotentials CASTEP 17.0 (NCP17) C18 USP definitions, CASTEP 18.0 (C18) NCP18 Norm Conserving pseudopotentials CASTEP 18.0 (NCP18) C19 USP definitions, CASTEP 19.0 (C19) delta=0.442 meV NCP19 Norm Conserving pseudopotentials CASTEP 19.0 (NCP19) delta=1.098 meV Pseudopotential files CASTEP can also read in pseudopotentials from files Format Origin .usp as generated by CASTEP (note both USP and NCP use this format) .uspso as generated by CASTEP, with spin-orbit coupling .recpot as generated by OPIUM (also legacy CASTEP files) .UPF as generated by Quantum Espresso Note that properties using PAW augmentation will not be available when using file based pseudopotentials (OTFG is required) - this includes all NMR/EPR properties and EELS spectra.","title":"Overview"},{"location":"documentation/Pseudopotentials/overview/#pseudopotential-files","text":"CASTEP can also read in pseudopotentials from files Format Origin .usp as generated by CASTEP (note both USP and NCP use this format) .uspso as generated by CASTEP, with spin-orbit coupling .recpot as generated by OPIUM (also legacy CASTEP files) .UPF as generated by Quantum Espresso Note that properties using PAW augmentation will not be available when using file based pseudopotentials (OTFG is required) - this includes all NMR/EPR properties and EELS spectra.","title":"Pseudopotential files"},{"location":"documentation/Pseudopotentials/reading_headers/","text":"At the start of a calculation CASTEP will generate the require pseudopotentials. A report is written into the start of the .castep file. This page explains what information is contained within this header. Carbon - Ultrasoft ============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.395 qc 0 | | 2 0 0.250 1.395 qc 0 | | 3 1 -0.194 1.395 qc 0 | | 4 1 0.250 1.395 qc 0 | | loc 2 0.000 1.395 pn 0 | | | | Augmentation charge Rinner = 0.983 | | Partial core correction Rc = 0.983 | ------------------------------------------------------------ | \"2|1.4|10|12|13|20:21(qc=7)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ All quantities are given in atomic units - so energies in Hartree (1Ha =26.4eV) and lengths in Bohr (1 bohr = 0.88Ang) Element: This is just the symbol for the element Ionic Charge: Sum of nuclear charge and the core electrons (C Z=6 core=1s2 gives ionic charge as +6-2=+4) Level of theory: The Exchange-Correlation potential used. Atomic-solver: Koelling-Harmon is the default atomic solver. Reference electronic structure. This section describes the valence states included in the calculation. For Carbon these are the 2s and 2p states. Their occupations and energies are given. Pseudopotential Definition (Advanced) The definitions of each of the non-local projector (aka beta projectors) is given here. Beta - the number of the projector l - angular momentum quantum number e - energy of the corresponding orbital Rc - Cutoff (matching) radius for the orbital scheme - pseudization scheme (qc = qc tuned) norm - 1=norm-conserving 0-ultrasoft (norm not conserved) This is a standard Ultrasoft pseudopotential with two beta projectors per angular momentum channel. One projector is from an orbital at the eigen-energy (i.e. -0.505Ha for 2s) while the second projector corresponds to a non-bound orbital at an energy of 0.25Ha. The final line gives the choice of local potential. In this case the local potential is constructed from a l=2 state with the same cutoff radius as for the local projectors. Augmentation charge Rinner . This is specific to the Ultrasoft scheme - and describes the radius outside which the augmentation charge matches the all-electron charge. Partial core correction . As the exchange correlation energy is a non-linear function of charge there is an error introduced if we compute the xc energy of the valence and core electron separately. We therefore include the core charge in the calculation of the xc energy. The core charge is challenging to represent on a grid - and so a pseudized core charge is used. Rc is the cut-off for this pseudized core charge. Carbon - Normconserving ============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.201 qc 1 | | loc 1 -0.194 1.201 qc 1 | | | | No charge augmentation | | Partial core correction Rc = 0.839 | ------------------------------------------------------------ | \"1|1.2|17|20|23|20N:21L(qc=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ Note that the Reference Electronic Structure section is identical to the ultrasoft potential above. This relates to the all-electron atom and is unaffected by the details of the pseudopotential. From the pseudopotential definition we see there is one beta projector for l=0 (s) and the local potential is set to be l=1 (p). For norm-conserving potentials it is common to only need one projector per angular momentum chanel, and for one of the occupied channels to be represented by the local potential. There is no charge augmentation (this is only needed for ultrasofts) however, a non-linear core correction is used. Uranium - J-dependent ============================================================ | Pseudopotential Report - Date of generation 4-07-2020 | ------------------------------------------------------------ | Element: U Ionic charge: 14.00 Level of theory: LDA | | Atomic Solver: Dirac (FR) | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 6s1/2 2.000 -1.748 | | 6p1/2 2.000 -1.101 | | 6p3/2 4.000 -0.776 | | 7s1/2 2.000 -0.161 | | 5f5/2 1.286 -0.147 | | 5f7/2 1.714 -0.116 | | 6d3/2 0.400 -0.103 | | 6d5/2 0.600 -0.085 | | | | Pseudopotential Definition | | Beta l 2j e Rc scheme norm | | 1 0 1 -1.748 2.106 qc 1 | | 2 0 1 -0.161 2.106 qc 1 | | 3 1 3 -0.776 2.106 qc 1 | | 4 1 1 -1.101 2.106 qc 1 | | 5 2 5 -0.085 2.106 qc 1 | | 6 2 3 -0.103 2.106 qc 1 | | 7 3 7 -0.116 2.106 qc 1 | | 8 3 5 -0.147 2.106 qc 1 | | loc 4 0 0.000 2.106 pn 0 | | | | No charge augmentation | | Partial core correction Rc = 1.472 | ------------------------------------------------------------ | \"4|2.1|17|19|22|60N:70N:61N:62N:53N(qc=6,q3=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ This pseudopotential is calculated by using a Dirac equation solver including the spin-orbit interaction (FR=fully relativistic). It is a norm-conserving potential. There are 14 electrons included in the valence (6s2,7s2,6p6,6d1,5f3). Because of the spin orbit splitting states with different j quantum numbers have different energies. States with l>0 are split into j=l+1/2 j=l+1/2 and j=l-1/2 j=l-1/2 (e.g. the 6p states are split into 6p\u00bd and 6p3/2, the 5f into 5f5/2 5f7/2).","title":"Headers"},{"location":"documentation/Pseudopotentials/reading_headers/#carbon-ultrasoft","text":"============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.395 qc 0 | | 2 0 0.250 1.395 qc 0 | | 3 1 -0.194 1.395 qc 0 | | 4 1 0.250 1.395 qc 0 | | loc 2 0.000 1.395 pn 0 | | | | Augmentation charge Rinner = 0.983 | | Partial core correction Rc = 0.983 | ------------------------------------------------------------ | \"2|1.4|10|12|13|20:21(qc=7)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ All quantities are given in atomic units - so energies in Hartree (1Ha =26.4eV) and lengths in Bohr (1 bohr = 0.88Ang) Element: This is just the symbol for the element Ionic Charge: Sum of nuclear charge and the core electrons (C Z=6 core=1s2 gives ionic charge as +6-2=+4) Level of theory: The Exchange-Correlation potential used. Atomic-solver: Koelling-Harmon is the default atomic solver.","title":"Carbon - Ultrasoft"},{"location":"documentation/Pseudopotentials/reading_headers/#reference-electronic-structure","text":"This section describes the valence states included in the calculation. For Carbon these are the 2s and 2p states. Their occupations and energies are given.","title":"Reference electronic structure."},{"location":"documentation/Pseudopotentials/reading_headers/#pseudopotential-definition-advanced","text":"The definitions of each of the non-local projector (aka beta projectors) is given here. Beta - the number of the projector l - angular momentum quantum number e - energy of the corresponding orbital Rc - Cutoff (matching) radius for the orbital scheme - pseudization scheme (qc = qc tuned) norm - 1=norm-conserving 0-ultrasoft (norm not conserved) This is a standard Ultrasoft pseudopotential with two beta projectors per angular momentum channel. One projector is from an orbital at the eigen-energy (i.e. -0.505Ha for 2s) while the second projector corresponds to a non-bound orbital at an energy of 0.25Ha. The final line gives the choice of local potential. In this case the local potential is constructed from a l=2 state with the same cutoff radius as for the local projectors. Augmentation charge Rinner . This is specific to the Ultrasoft scheme - and describes the radius outside which the augmentation charge matches the all-electron charge. Partial core correction . As the exchange correlation energy is a non-linear function of charge there is an error introduced if we compute the xc energy of the valence and core electron separately. We therefore include the core charge in the calculation of the xc energy. The core charge is challenging to represent on a grid - and so a pseudized core charge is used. Rc is the cut-off for this pseudized core charge.","title":"Pseudopotential Definition (Advanced)"},{"location":"documentation/Pseudopotentials/reading_headers/#carbon-normconserving","text":"============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.201 qc 1 | | loc 1 -0.194 1.201 qc 1 | | | | No charge augmentation | | Partial core correction Rc = 0.839 | ------------------------------------------------------------ | \"1|1.2|17|20|23|20N:21L(qc=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ Note that the Reference Electronic Structure section is identical to the ultrasoft potential above. This relates to the all-electron atom and is unaffected by the details of the pseudopotential. From the pseudopotential definition we see there is one beta projector for l=0 (s) and the local potential is set to be l=1 (p). For norm-conserving potentials it is common to only need one projector per angular momentum chanel, and for one of the occupied channels to be represented by the local potential. There is no charge augmentation (this is only needed for ultrasofts) however, a non-linear core correction is used.","title":"Carbon - Normconserving"},{"location":"documentation/Pseudopotentials/reading_headers/#uranium-j-dependent","text":"============================================================ | Pseudopotential Report - Date of generation 4-07-2020 | ------------------------------------------------------------ | Element: U Ionic charge: 14.00 Level of theory: LDA | | Atomic Solver: Dirac (FR) | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 6s1/2 2.000 -1.748 | | 6p1/2 2.000 -1.101 | | 6p3/2 4.000 -0.776 | | 7s1/2 2.000 -0.161 | | 5f5/2 1.286 -0.147 | | 5f7/2 1.714 -0.116 | | 6d3/2 0.400 -0.103 | | 6d5/2 0.600 -0.085 | | | | Pseudopotential Definition | | Beta l 2j e Rc scheme norm | | 1 0 1 -1.748 2.106 qc 1 | | 2 0 1 -0.161 2.106 qc 1 | | 3 1 3 -0.776 2.106 qc 1 | | 4 1 1 -1.101 2.106 qc 1 | | 5 2 5 -0.085 2.106 qc 1 | | 6 2 3 -0.103 2.106 qc 1 | | 7 3 7 -0.116 2.106 qc 1 | | 8 3 5 -0.147 2.106 qc 1 | | loc 4 0 0.000 2.106 pn 0 | | | | No charge augmentation | | Partial core correction Rc = 1.472 | ------------------------------------------------------------ | \"4|2.1|17|19|22|60N:70N:61N:62N:53N(qc=6,q3=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ This pseudopotential is calculated by using a Dirac equation solver including the spin-orbit interaction (FR=fully relativistic). It is a norm-conserving potential. There are 14 electrons included in the valence (6s2,7s2,6p6,6d1,5f3). Because of the spin orbit splitting states with different j quantum numbers have different energies. States with l>0 are split into j=l+1/2 j=l+1/2 and j=l-1/2 j=l-1/2 (e.g. the 6p states are split into 6p\u00bd and 6p3/2, the 5f into 5f5/2 5f7/2).","title":"Uranium - J-dependent"},{"location":"documentation/Pseudopotentials/theory/","text":"The electrons in an atom can be divided into two types --- core electrons and valence electrons. The core electrons are tightly bound to the nucleus, while the valence electrons are more extended. A working definition for core electrons is that they are the ones which play no part in the interactions between atoms, while the valence electrons dictate most of the properties of the material. It is common to make the frozen core approximation; the core electrons are constrained not to differ from their free atomic nature when placed in the solid state environment. This reduces the number of electronic degrees of freedom in an all-electron calculation. It is a very good approximation. A different, but physically related, approach is taken in the pseudopotential approximation. Since, in an all-electron calculation, the valence electron wavefunctions must be orthogonal to the core wavefunctions they necessarily have strong oscillations in the region near the nucleus (see the all-electron wavefunction in Figure~\\ref{fig:wvfn}). Given that a planewave basis set is to be used to describe the wavefunctions, these strong oscillations are undesirable --- requiring many plane waves for an accurate description. Further, these oscillations are of very little consequence for the electronic structure in the solid, since they occur close to the nucleus. In the pseudopotential approach only the valence electrons are explicitly considered, the effects of the core electrons being integrated within a new ionic potential. The valence wavefunctions need no longer be orthogonal to the core states, and so the orthogonality oscillations disappear; hence far fewer plane waves are required to describe the valence wavefunctions. Numerous schemes to produce optimally soft pseudopotentials have been developed. Common choices are the norm-conserving potentials due to Troullier and Martins\\cite{troullier91} and Vanderbilt's ultrasoft scheme.\\cite{vanderbilt90}","title":"Theory"},{"location":"documentation/Spectral/keywords/","text":"SPECTRAL_TASK - determines what will be calculated. All tasks will compute the eigenenergies (aka bands). The list of tasks, and the extra properties calculated are as follows: bandstructure dos band gradients optics optical matrix elements pdos atomic projections coreloss dipole matrix elements with core states Most spectral calculations will involve the calculation of unoccupied states. One of the following parameters should be set to determine the number of states calculated. SPECTRAL_NEXTRA_BANDS number of extra spectral bands SPECTRAL_PERC_EXTRA_BANDS percentage of extra spectral bands SPECTRAL_NBANDS number of bands/k-point in spectral calc It is possible to use a different exchange-correlation functional to the one used for the groundstate. An example might be when a semi-local functional (such as PBE) is used for the groundstate, and a more expensive non-local functional (e.g. PBE0) is used for the spectral calculation. This is an approximation and should be done with cuation. To set the xc functional use one of the two keywords. SPECTRAL_XC_FUNCTIONAL spectral exchange-correlation functional SPECTRAL_XC_DEFINITION spectral exchange-correlation functional To change the convergence tolerance for the eigenvalues set SPECTRAL_EIGENVALUE_TOL ! default: 10E-6 eV SPECTRAL_MAX_ITER maximum iterations in spectral calculation SPECTRAL_MAX_STEPS_PER_ITER maximum steps per iter in spectral calculation","title":"Keywords"},{"location":"documentation/Spectral/overview/","text":"`","title":"Overview"},{"location":"documentation/Spectral/restarts/","text":"Spectral calculations do not write a check file - however, they can write backups to enable restarting an unfinished calculation. The limitation is that a parallel calculation must be restarted on the same number of processors. #Sample param file cut_off_energy : 550 eV fix_occupancy : true task : spectral spectral_task : coreloss %block devel_code SPECTRAL_RESTART %endblock devel_code backup_interval 1800 ! time in seconds The devel_code keyword SPECTRAL_RESTART triggers both the writing an reading of Spectral backup files. backup_interval determines the time between writing backups. Backup will slow down the calculation as they require disk access (which is always slow). If you expect a job to run for several hours backing up every 30min is a reasonable compromise. After completing each k-point the CASTEP will check to see if time since the last backup is greater than backup_interval - is it is a backup will be written - if not CASTEP carries on with the next k-point. Note that a backup is always written (if backup_interval>0) after the final kpoint. This is useful insurance in case there is any problem when CASTEP writes the final output files. Here is an example .castep file with backup ===================================================================== + + + Calculation of Spectral Properties + + + + Calculation re-parallelised over 2 processes. + + Data distributed by G-vector(1-way), k-point(2-way), band(1-way) + + Data distributed by k-point(2-way) + + + ===================================================================== Starting k-point: 1 of 5 on this process |<-- SPEC Starting k-point: 2 of 5 on this process |<-- SPEC Starting k-point: 3 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Starting k-point: 4 of 5 on this process |<-- SPEC Starting k-point: 5 of 5 on this process |<-- SPEC Starting k-point: 1 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Starting k-point: 2 of 5 on this process |<-- SPEC Starting k-point: 3 of 5 on this process |<-- SPEC Starting k-point: 4 of 5 on this process |<-- SPEC We see that backups were written every three k-points. The last backup was done after the 1 st k-point for spin 2. As this calculation was run on two processors, we find two backup files have been created -rw-r--r-- 1 317700 18 Jul 10:53 Si2-core.0001.spec -rw-r--r-- 1 317700 18 Jul 10:53 Si2-core.0002.spec To restart, keep everything the same but add to the param file continuation : xxx.check Where xxx.check is the name of the check file containing the ground-state density etc. This will have been written during the first run - and xxx will be replaced with whatever is the seedname of your run. We now re-run the calculation. CASTEP will read the ground-state from the check file (so there should be no electronic minimisation) Restarting spectral calculation from restart file |<-- SPEC Starting k-point: 2 of 5 on this process |<-- SPEC Starting k-point: 3 of 5 on this process |<-- SPEC Starting k-point: 4 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Starting k-point: 5 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Total time to compute matrix elements 3500.45 sec |<\u2014- SPEC So the calculation did restart from the 2 nd k-point on spin 2.","title":"Restarts"},{"location":"documentation/TDDFT/overview/","text":"","title":"TDDFT Overview"},{"location":"documentation/Transition_State_Search/neb/","text":"Note The NEB functionality in CASTEP was overhauled in version 22, with more efficient algorithms available. In order to use this new functionality, make sure you're using CASTEP 22 or later . Background and theory The nudged elastic band method is a widely-used method for finding a minimum energy pathway between two structures. You can use the method to estimate the barrier for the system to transition between the two structures. In our NEB implementation the update rule for atomic position is given by: x^{k+1}_{n} = x^{k}_n + \\alpha^k [-\\nabla^\\perp V(x^{k}_n) + \\mathbf{\\eta}^{k}_n] x^{k+1}_{n} = x^{k}_n + \\alpha^k [-\\nabla^\\perp V(x^{k}_n) + \\mathbf{\\eta}^{k}_n] where x^{k}_n x^{k}_n are the positions of image n n at iteration k k . \\alpha^k \\alpha^k is the step size, which can either be fixed or chosen in an adaptive manner, \\nabla^\\perp V(x^{k}_n) \\nabla^\\perp V(x^{k}_n) is the gradient of the total energy, projected to remove the component along the reaction path, and \\mathbf{\\eta}^{k}_n = \\mathbf{\\eta}((x^{k}_n)',(x^{k}_n)'') \\mathbf{\\eta}^{k}_n = \\mathbf{\\eta}((x^{k}_n)',(x^{k}_n)'') is the NEB spring force. As a consequence of the projection step, the NEB forces do not have a corresponding energy functional and hence linesearch is not possible, making quasi-Newton searches such as (L)BFGS inapplicable. Standard approaches are either to use simple gradient-only based methods or to add a maximum step size constraint in place of the linesearch. Both of these can exhibit slow convergence; a solution is instead to choose the step size adaptively using a custom time-stepping algorithm. A promising solution to this problem is the ODE12r adaptive scheme introduced in Ref. 3 , which combines two distinct step selection criteria: one based on minimising the change in the residual force from one step to the next as is typically done to control error in adaptive ODE solvers, and a second based on minimising the residual itself. The key idea is that adaptive ODE step selection should be used in the pre-asymptotic regime, while minimising the residual is suitable in the asymptotic regime. We have implemented three optimisation schemes for NEB paths, with the approach to be used controlled by the TSSEARCH_NEB_METHOD parameter: (i) the two point steepest descent scheme of Barzilai and Borwein ; (ii) the fast inertial relaxation engine ( FIRE ) and (iii) the ODE12R scheme discussed above. In all three cases, convergence is controlled by the existing TSSEARCH_FORCE_TOL parameter. To better fit user intuition, the default value of this parameter is now equal to the force tolerance used during geometry optimisation, GEOM_FORCE_TOL . We also provide three alternative algorithms to compute the tangents (x^{k}_n)' (x^{k}_n)' and curvatures (x^{k}_n)'' (x^{k}_n)'' at each image along the path, controlled by the TSSEARCH_NEB_TANGENT_MODE parameter. The three approaches are based on bisection, the improved tangent scheme of Ref 2 , and cubic spline interpolation as used in Ref 3 . The latter was found to be the most robust so has been made the default. Keywords As with other functionality in CASTEP, you can use the built-in help tool to find information on NEB-related keywords. For example, you could run: castep -s tssearch The relevant .param keywords are summarised in the table below: Parameter Default Level Notes TASK SINGLEPOINT Basic Set to TRANSITIONSTATESEARCH to perform a transition state calculation. TSSEARCH_METHOD LSTQST Basic The search method used to locate transition states. Must be set to NEB to perform a NEB calculation. Previous default retained for backwards compatibility. Modifiable: restart only. Allowed values: LSTQST , NEB Default value : LSTQST TSSEARCH_FORCE_TOL Same as GEOM_FORCE_TOL Basic Tolerance for accepting convergence of the maximum |ionic force| during QST search. Modifiable: restart and on the fly TSSEARCH_MAX_PATH_POINTS 20 Intermediate The maximum number of path points for NEB search. Modifiable: restart and on the fly. Allowed values: (any integer) > 0 TSSEARCH_NEB_METHOD ODE12R Intermediate Method used to optimize the NEB shape. Modifiable: restart and on the fly. Allowed values: GRAD_BB , FIRE , ODE12R TSSEARCH_NEB_TANGENT_MODE SPLINE Basic Method used to calculate the tangents of the NEB. Modifiable: restart and on the fly. Allowed values: NONE , BISECT , HIGH_E , SPLINE TSSEARCH_NEB_SPRING_CONSTANT 0.1 eV/ang2 Basic Spring constant used between the images in NEB search. Modifiable: restart and on the fly. Allowed values: (any) > 0.0 TSSEARCH_NEB_CLIMBING FALSE Basic If TRUE then the central bead in NEB search climbs up the potential and TSSEARCH_MAX_PATH_POINTS must be odd (may be increased by +1). If FALSE then the central bead in NEB search slides down the potential. Modifiable: restart only. Allowed values: TRUE or FALSE. Default value: FALSE TSSEARCH_NEB_MAX_ITER 20 Intermediate The maximum number of steps during NEB search. Modifiable: restart and on the fly. Allowed values: (any integer) > 0 TSSEARCH_NEB_NORMED FALSE if TSSEARCH_NEB_TANGENT_MODE = SPLINE , TRUE otherwise Expert If TRUE then the spring forces applied along the tangents in the NEB are normed to the displacement between beads. If FALSE then the spring forces are projected along the tangents in the NEB and may result in null forces if displacements are orthogonal to the NEB tangents. Modifiable: restart only. Allowed values: TRUE or FALSE As a minimum, you need to specify TASK: TRANSITIONSTATESEARCH and TSSEARCH_METHOD: NEB in the .param file and specify the product (final) ionic positions (using e.g. the POSITIONS_ABS_PRODUCT block) in the .cell file, in addition to the normal POSITIONS_ABS block. CASTEP will then linearly interpolate between the initial and product configuration and begin the NEB calculation. However, it's advisable to also: change the number of images used ( TSSEARCH_MAX_PATH_POINTS ), decide on whether you want the climbing image method ( TSSEARCH_NEB_CLIMBING ), and think about the relevant force criterion to be used ( TSSEARCH_FORCE_TOL ). For a practical guide on how to use the NEB method in CASTEP, see the tutorial . Output files In addition to information in the .castep file, a .ts file will be generated during a transition state search calculation. Below is the start of a typical .ts file, with annotations explaing what each line means (you can see these by clicking on the ( ) symbols). Note Like .geom and .md files, .ts files use atomic units (Ha for energies, Bohr for distances and Bohr/Ha for forces etc.). TSTYPE TSConfirmation # (1)! REA 1 0.00000000E+000 # (2)! -1.19447739E+001 -1.19447739E+001 <-- E #(3)! 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h #(4)! 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61419707E+000 8.39780193E+000 5.86117838E+000 <-- R #(5)! H 2 8.15635294E+000 5.72185774E+000 5.85777350E+000 <-- R H 3 5.06964224E+000 5.72278559E+000 5.86095165E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 8.47021636E-007 3.11793289E-005 2.28609226E-005 <-- F #(6)! H 2 1.38512779E-006 -2.45087447E-005 -4.65186359E-005 <-- F H 3 -4.12781162E-005 -4.76763241E-006 1.75643331E-005 <-- F N 1 3.90459667E-005 -1.90295182E-006 6.09338019E-006 <-- F PRO 1 1.00000000E+000 #(7)! -1.19447351E+001 -1.19447351E+001 <-- E 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61608080E+000 8.39796599E+000 7.36585209E+000 <-- R H 2 8.15724653E+000 5.72090835E+000 7.36726384E+000 <-- R H 3 5.07119891E+000 5.72404366E+000 7.37171850E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 6.09749957E-005 4.97392811E-005 -4.85624696E-005 <-- F H 2 6.57602570E-005 -1.92918456E-005 -3.12188543E-005 <-- F H 3 -5.16484028E-005 2.80445001E-005 5.83274956E-005 <-- F N 1 -7.50868499E-005 -5.84919355E-005 2.14538282E-005 <-- F TST 1 1.25000056E-001 #(8)! -1.19415297E+001 -1.19415297E+001 <-- E 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61443264E+000 8.39782206E+000 6.04926187E+000 <-- R H 2 8.15646486E+000 5.72173929E+000 6.04646018E+000 <-- R H 3 5.06983587E+000 5.72294304E+000 6.04979810E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 -9.19085803E-006 2.32501273E-002 -1.04092397E-002 <-- F H 2 2.02903385E-002 -1.17660606E-002 -1.06346944E-002 <-- F H 3 -2.03961322E-002 -1.17795791E-002 -1.05604406E-002 <-- F N 1 1.14984498E-004 2.95512341E-004 3.16043747E-002 <-- F This is a comment line stating what type of calculation was carried out. This is the initial (i.e. the REA ctant) configuration. The integer indicates it is the configuration for the first NEB iteration. As the REActant (and PROduct) configurations are the same for every NEB iteration, they are only printed out once. The float at the end of the line is a measure of where the configuration lies between 0 (reactant) and 1 (product). TODO: be more precise. <-- E is the total energy and enthalpy of the system, in atomic units. <-- h is the unit cell matrix (atomic units). <-- R are the atomic coordinates (Cartesian), in atomic units. <-- F are the forces (atomic units). TODO: do these include NEB forces? This is the end-point (or PRO duct) configuration for the first iteration. As this is the same for every NEB iteration, it is only printed out once. This is the first of the transition state configurations (NEB images) for iteration 1 of the NEB. For example, if you have 7 images, then there will be 7 blocks that start with TST 1 .","title":"Nudged elastic band"},{"location":"documentation/Transition_State_Search/neb/#background-and-theory","text":"The nudged elastic band method is a widely-used method for finding a minimum energy pathway between two structures. You can use the method to estimate the barrier for the system to transition between the two structures. In our NEB implementation the update rule for atomic position is given by: x^{k+1}_{n} = x^{k}_n + \\alpha^k [-\\nabla^\\perp V(x^{k}_n) + \\mathbf{\\eta}^{k}_n] x^{k+1}_{n} = x^{k}_n + \\alpha^k [-\\nabla^\\perp V(x^{k}_n) + \\mathbf{\\eta}^{k}_n] where x^{k}_n x^{k}_n are the positions of image n n at iteration k k . \\alpha^k \\alpha^k is the step size, which can either be fixed or chosen in an adaptive manner, \\nabla^\\perp V(x^{k}_n) \\nabla^\\perp V(x^{k}_n) is the gradient of the total energy, projected to remove the component along the reaction path, and \\mathbf{\\eta}^{k}_n = \\mathbf{\\eta}((x^{k}_n)',(x^{k}_n)'') \\mathbf{\\eta}^{k}_n = \\mathbf{\\eta}((x^{k}_n)',(x^{k}_n)'') is the NEB spring force. As a consequence of the projection step, the NEB forces do not have a corresponding energy functional and hence linesearch is not possible, making quasi-Newton searches such as (L)BFGS inapplicable. Standard approaches are either to use simple gradient-only based methods or to add a maximum step size constraint in place of the linesearch. Both of these can exhibit slow convergence; a solution is instead to choose the step size adaptively using a custom time-stepping algorithm. A promising solution to this problem is the ODE12r adaptive scheme introduced in Ref. 3 , which combines two distinct step selection criteria: one based on minimising the change in the residual force from one step to the next as is typically done to control error in adaptive ODE solvers, and a second based on minimising the residual itself. The key idea is that adaptive ODE step selection should be used in the pre-asymptotic regime, while minimising the residual is suitable in the asymptotic regime. We have implemented three optimisation schemes for NEB paths, with the approach to be used controlled by the TSSEARCH_NEB_METHOD parameter: (i) the two point steepest descent scheme of Barzilai and Borwein ; (ii) the fast inertial relaxation engine ( FIRE ) and (iii) the ODE12R scheme discussed above. In all three cases, convergence is controlled by the existing TSSEARCH_FORCE_TOL parameter. To better fit user intuition, the default value of this parameter is now equal to the force tolerance used during geometry optimisation, GEOM_FORCE_TOL . We also provide three alternative algorithms to compute the tangents (x^{k}_n)' (x^{k}_n)' and curvatures (x^{k}_n)'' (x^{k}_n)'' at each image along the path, controlled by the TSSEARCH_NEB_TANGENT_MODE parameter. The three approaches are based on bisection, the improved tangent scheme of Ref 2 , and cubic spline interpolation as used in Ref 3 . The latter was found to be the most robust so has been made the default.","title":"Background and theory"},{"location":"documentation/Transition_State_Search/neb/#keywords","text":"As with other functionality in CASTEP, you can use the built-in help tool to find information on NEB-related keywords. For example, you could run: castep -s tssearch The relevant .param keywords are summarised in the table below: Parameter Default Level Notes TASK SINGLEPOINT Basic Set to TRANSITIONSTATESEARCH to perform a transition state calculation. TSSEARCH_METHOD LSTQST Basic The search method used to locate transition states. Must be set to NEB to perform a NEB calculation. Previous default retained for backwards compatibility. Modifiable: restart only. Allowed values: LSTQST , NEB Default value : LSTQST TSSEARCH_FORCE_TOL Same as GEOM_FORCE_TOL Basic Tolerance for accepting convergence of the maximum |ionic force| during QST search. Modifiable: restart and on the fly TSSEARCH_MAX_PATH_POINTS 20 Intermediate The maximum number of path points for NEB search. Modifiable: restart and on the fly. Allowed values: (any integer) > 0 TSSEARCH_NEB_METHOD ODE12R Intermediate Method used to optimize the NEB shape. Modifiable: restart and on the fly. Allowed values: GRAD_BB , FIRE , ODE12R TSSEARCH_NEB_TANGENT_MODE SPLINE Basic Method used to calculate the tangents of the NEB. Modifiable: restart and on the fly. Allowed values: NONE , BISECT , HIGH_E , SPLINE TSSEARCH_NEB_SPRING_CONSTANT 0.1 eV/ang2 Basic Spring constant used between the images in NEB search. Modifiable: restart and on the fly. Allowed values: (any) > 0.0 TSSEARCH_NEB_CLIMBING FALSE Basic If TRUE then the central bead in NEB search climbs up the potential and TSSEARCH_MAX_PATH_POINTS must be odd (may be increased by +1). If FALSE then the central bead in NEB search slides down the potential. Modifiable: restart only. Allowed values: TRUE or FALSE. Default value: FALSE TSSEARCH_NEB_MAX_ITER 20 Intermediate The maximum number of steps during NEB search. Modifiable: restart and on the fly. Allowed values: (any integer) > 0 TSSEARCH_NEB_NORMED FALSE if TSSEARCH_NEB_TANGENT_MODE = SPLINE , TRUE otherwise Expert If TRUE then the spring forces applied along the tangents in the NEB are normed to the displacement between beads. If FALSE then the spring forces are projected along the tangents in the NEB and may result in null forces if displacements are orthogonal to the NEB tangents. Modifiable: restart only. Allowed values: TRUE or FALSE As a minimum, you need to specify TASK: TRANSITIONSTATESEARCH and TSSEARCH_METHOD: NEB in the .param file and specify the product (final) ionic positions (using e.g. the POSITIONS_ABS_PRODUCT block) in the .cell file, in addition to the normal POSITIONS_ABS block. CASTEP will then linearly interpolate between the initial and product configuration and begin the NEB calculation. However, it's advisable to also: change the number of images used ( TSSEARCH_MAX_PATH_POINTS ), decide on whether you want the climbing image method ( TSSEARCH_NEB_CLIMBING ), and think about the relevant force criterion to be used ( TSSEARCH_FORCE_TOL ). For a practical guide on how to use the NEB method in CASTEP, see the tutorial .","title":"Keywords"},{"location":"documentation/Transition_State_Search/neb/#output-files","text":"In addition to information in the .castep file, a .ts file will be generated during a transition state search calculation. Below is the start of a typical .ts file, with annotations explaing what each line means (you can see these by clicking on the ( ) symbols). Note Like .geom and .md files, .ts files use atomic units (Ha for energies, Bohr for distances and Bohr/Ha for forces etc.). TSTYPE TSConfirmation # (1)! REA 1 0.00000000E+000 # (2)! -1.19447739E+001 -1.19447739E+001 <-- E #(3)! 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h #(4)! 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61419707E+000 8.39780193E+000 5.86117838E+000 <-- R #(5)! H 2 8.15635294E+000 5.72185774E+000 5.85777350E+000 <-- R H 3 5.06964224E+000 5.72278559E+000 5.86095165E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 8.47021636E-007 3.11793289E-005 2.28609226E-005 <-- F #(6)! H 2 1.38512779E-006 -2.45087447E-005 -4.65186359E-005 <-- F H 3 -4.12781162E-005 -4.76763241E-006 1.75643331E-005 <-- F N 1 3.90459667E-005 -1.90295182E-006 6.09338019E-006 <-- F PRO 1 1.00000000E+000 #(7)! -1.19447351E+001 -1.19447351E+001 <-- E 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61608080E+000 8.39796599E+000 7.36585209E+000 <-- R H 2 8.15724653E+000 5.72090835E+000 7.36726384E+000 <-- R H 3 5.07119891E+000 5.72404366E+000 7.37171850E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 6.09749957E-005 4.97392811E-005 -4.85624696E-005 <-- F H 2 6.57602570E-005 -1.92918456E-005 -3.12188543E-005 <-- F H 3 -5.16484028E-005 2.80445001E-005 5.83274956E-005 <-- F N 1 -7.50868499E-005 -5.84919355E-005 2.14538282E-005 <-- F TST 1 1.25000056E-001 #(8)! -1.19415297E+001 -1.19415297E+001 <-- E 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61443264E+000 8.39782206E+000 6.04926187E+000 <-- R H 2 8.15646486E+000 5.72173929E+000 6.04646018E+000 <-- R H 3 5.06983587E+000 5.72294304E+000 6.04979810E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 -9.19085803E-006 2.32501273E-002 -1.04092397E-002 <-- F H 2 2.02903385E-002 -1.17660606E-002 -1.06346944E-002 <-- F H 3 -2.03961322E-002 -1.17795791E-002 -1.05604406E-002 <-- F N 1 1.14984498E-004 2.95512341E-004 3.16043747E-002 <-- F This is a comment line stating what type of calculation was carried out. This is the initial (i.e. the REA ctant) configuration. The integer indicates it is the configuration for the first NEB iteration. As the REActant (and PROduct) configurations are the same for every NEB iteration, they are only printed out once. The float at the end of the line is a measure of where the configuration lies between 0 (reactant) and 1 (product). TODO: be more precise. <-- E is the total energy and enthalpy of the system, in atomic units. <-- h is the unit cell matrix (atomic units). <-- R are the atomic coordinates (Cartesian), in atomic units. <-- F are the forces (atomic units). TODO: do these include NEB forces? This is the end-point (or PRO duct) configuration for the first iteration. As this is the same for every NEB iteration, it is only printed out once. This is the first of the transition state configurations (NEB images) for iteration 1 of the NEB. For example, if you have 7 images, then there will be 7 blocks that start with TST 1 .","title":"Output files"},{"location":"documentation/Troubleshooting/linux_path/","text":"Command not found When you type castep , Linux doesn't know where that command is, so it looks in the places where programs are usually put (often /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin and /usr/local/sbin ; \"bin\" here is short for \"binary\"). Unless CASTEP is there, it will tell you that it can't find it. Notice in particular that the directory you're in when you type the command is not in Linux's list of usual places to look, which is especially confusing when you first encounter it! Telling Linux where to find CASTEP There are several ways to fix this. If you're on a shared machine, it is usually best to make a subdirectory in your home directory, perhaps called \"bin\": mkdir ~/bin and put CASTEP in there (along with any other programs you compile yourself), e.g. cp ~/CASTEP-22.1/obj/linux_x86_64_gfortran--serial/castep.serial ~/bin This still won't mean that Linux will find CASTEP, because this is also not a place it will look for programs. The places Linux looks in are stored in a special Linux environment variable called the \"path\", and the final step is to add the new directory to this \"path\". Exactly how you do this depends on what kind of command-line interpreter (called a \"shell\") you're using in Linux, but there are only really two main kinds: bash and csh. Type export PATH=${PATH}:~/bin if you're using bash, or setenv PATH ${PATH}:~/bin if you're using csh. These commands tell Linux to look in all the places it's looking in already, and also \"~/bin\". If you don't know which shell you're using, try typing: echo $SHELL and see what it says. If it says something like \"/bin/bash\" then you're using bash, if it's \"/bin/csh\" or \"/bin/tcsh\" then it's csh (or close enough). If it gives something else, just try the line starting \"export\" and if it gives an error, try the \"setenv\" one instead. Now try typing \"castep.serial\" and you should see this: Usage: castep <seedname> : Run files <seedname>.cell [and <seedname>.param] \" [-d|--dryrun] <seedname> : Perform a dryrun calculation on files <seedname>.cell \" [-s|--search] <text> : print list of keywords with <text> match in description \" [-v|--version] : print version information \" [-h|--help] <keyword> : describe specific keyword in <>.cell or <>.param \" \" all : print list of all keywords \" \" basic : print list of basic-level keywords \" \" inter : print list of intermediate-level keywords \" \" expert : print list of expert-level keywords \" \" dummy : print list of dummy keywords Automatically adding to your PATH The changes so far will be lost when you exit the command-line. We need to make sure that your directory is added to the PATH variable every time you log in or open a new terminal. If you're using bash, edit the file ~/.bashrc with a text editor (e.g. gedit), go to the end, and add the line to set the PATH: export PATH=${PATH}:~/bin Note that the file is in your home directory (\"~/\"), and the name starts with a dot (\".\" a full stop). Save and exit, and it should all be set up for you. If you're using csh, edit the file \"~/.cshrc\" instead, and add the appropriate line to set the PATH: setenv PATH ${PATH}:~/bin Save and exit, and it should all be set up for you.","title":"Linux help"},{"location":"documentation/Troubleshooting/linux_path/#command-not-found","text":"When you type castep , Linux doesn't know where that command is, so it looks in the places where programs are usually put (often /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin and /usr/local/sbin ; \"bin\" here is short for \"binary\"). Unless CASTEP is there, it will tell you that it can't find it. Notice in particular that the directory you're in when you type the command is not in Linux's list of usual places to look, which is especially confusing when you first encounter it!","title":"Command not found"},{"location":"documentation/Troubleshooting/linux_path/#telling-linux-where-to-find-castep","text":"There are several ways to fix this. If you're on a shared machine, it is usually best to make a subdirectory in your home directory, perhaps called \"bin\": mkdir ~/bin and put CASTEP in there (along with any other programs you compile yourself), e.g. cp ~/CASTEP-22.1/obj/linux_x86_64_gfortran--serial/castep.serial ~/bin This still won't mean that Linux will find CASTEP, because this is also not a place it will look for programs. The places Linux looks in are stored in a special Linux environment variable called the \"path\", and the final step is to add the new directory to this \"path\". Exactly how you do this depends on what kind of command-line interpreter (called a \"shell\") you're using in Linux, but there are only really two main kinds: bash and csh. Type export PATH=${PATH}:~/bin if you're using bash, or setenv PATH ${PATH}:~/bin if you're using csh. These commands tell Linux to look in all the places it's looking in already, and also \"~/bin\". If you don't know which shell you're using, try typing: echo $SHELL and see what it says. If it says something like \"/bin/bash\" then you're using bash, if it's \"/bin/csh\" or \"/bin/tcsh\" then it's csh (or close enough). If it gives something else, just try the line starting \"export\" and if it gives an error, try the \"setenv\" one instead. Now try typing \"castep.serial\" and you should see this: Usage: castep <seedname> : Run files <seedname>.cell [and <seedname>.param] \" [-d|--dryrun] <seedname> : Perform a dryrun calculation on files <seedname>.cell \" [-s|--search] <text> : print list of keywords with <text> match in description \" [-v|--version] : print version information \" [-h|--help] <keyword> : describe specific keyword in <>.cell or <>.param \" \" all : print list of all keywords \" \" basic : print list of basic-level keywords \" \" inter : print list of intermediate-level keywords \" \" expert : print list of expert-level keywords \" \" dummy : print list of dummy keywords","title":"Telling Linux where to find CASTEP"},{"location":"documentation/Troubleshooting/linux_path/#automatically-adding-to-your-path","text":"The changes so far will be lost when you exit the command-line. We need to make sure that your directory is added to the PATH variable every time you log in or open a new terminal. If you're using bash, edit the file ~/.bashrc with a text editor (e.g. gedit), go to the end, and add the line to set the PATH: export PATH=${PATH}:~/bin Note that the file is in your home directory (\"~/\"), and the name starts with a dot (\".\" a full stop). Save and exit, and it should all be set up for you. If you're using csh, edit the file \"~/.cshrc\" instead, and add the appropriate line to set the PATH: setenv PATH ${PATH}:~/bin Save and exit, and it should all be set up for you.","title":"Automatically adding to your PATH"},{"location":"documentation/Troubleshooting/troubleshooting/","text":"CASTEP fails to start Command not found If you see a message like this on the command-line when you run CASTEP: castep mytest castep: command not found then your computer has not located the CASTEP program. Check that: you've used the correct CASTEP name ( castep.serial or castep.mpi ) the CASTEP program is somewhere your computer expects programs to be See here for details of where Linux looks for programs, and how to change it. CASTEP aborts a calculation If CASTEP detects a serious problem, it will stop and write an error message to a .err file. If you are using the parallel version of CASTEP on many cores, you may see error messages from each of these cores. They are named using the same seedname, but with the process ID added, e.g. if CASTEP is run on 2 cores and a serious problem occurs, you might see the files mytest.0001.err mytest.0002.err These files contain useful information about what went wrong, so it is always worth looking at them. Failed to converge","title":"Common errors"},{"location":"documentation/Troubleshooting/troubleshooting/#castep-fails-to-start","text":"","title":"CASTEP fails to start"},{"location":"documentation/Troubleshooting/troubleshooting/#command-not-found","text":"If you see a message like this on the command-line when you run CASTEP: castep mytest castep: command not found then your computer has not located the CASTEP program. Check that: you've used the correct CASTEP name ( castep.serial or castep.mpi ) the CASTEP program is somewhere your computer expects programs to be See here for details of where Linux looks for programs, and how to change it.","title":"Command not found"},{"location":"documentation/Troubleshooting/troubleshooting/#castep-aborts-a-calculation","text":"If CASTEP detects a serious problem, it will stop and write an error message to a .err file. If you are using the parallel version of CASTEP on many cores, you may see error messages from each of these cores. They are named using the same seedname, but with the process ID added, e.g. if CASTEP is run on 2 cores and a serious problem occurs, you might see the files mytest.0001.err mytest.0002.err These files contain useful information about what went wrong, so it is always worth looking at them.","title":"CASTEP aborts a calculation"},{"location":"documentation/Troubleshooting/troubleshooting/#failed-to-converge","text":"","title":"Failed to converge"},{"location":"documentation/Vibrations/overview/","text":"","title":"Vibrations"},{"location":"documentation/XC/XC/","text":"The exchange and correlation functional used for calculations in Castep can be specified in one of two main ways. xc_functional The most straightforward is with the .param file keyword xc_functional . For example to use the PBE functional in the .param file simply use xc_functional : PBE There are a number of standard functionals that can be used in Castep with the xc_functional keyword: Local density approximation: LDA LDA-X LDA-C Generalised gradient approximations (GGA): PW91 PBE PBEsol RPBE WC BLYP B86PBE PBE_X PBE_C PBEsol_X PBEsol_C B88_X LYP_C Hybrid (non-local) functionals: HF SHF-LDA PBE0 B3LYP HSE03 HSE06 SPBE0 Meta-GGA functionals: RSCAN MS2 xc_definition The keyword xc_definition in the .param file (used instead of xc_functional) is used when you want to modify the standard behaviour of hybrid functionals, or if you want to construct your own hybrid functionals. The simplest use of xc_definition is to replicate that of xc_functional , for example %block xc_definition PBE 1.0 %endblock xc_definition is the same as xc_functional : PBE The \"1.0\" is what weighted fraction of the functional you want, so in this case 1.0 (i.e. 100% PBE). Recall that hybrids are (usually) a mixture of pure (or screened) non-local Hartree-Fock exchange, some local exchange and local correlation. So you could, for example, build a functional that could be 20% Hartree Fock, 80% LDA exchange and 100% LDA correlation. You can run a Castep calculation with this using %block xc_definition HF 0.2 LDA-X 0.8 LDA-C 1.0 %endblock xc_definition Examples: 1. B3LYP Firstly you cansimply use xc_functional : B3LYP , however B3LYP is a hybrid functional consisting of a mixture of Hartree-Fock, LDA and B88 exchange, LYP and LDA correlation. This functional can be specified component by component: %block xc_definition LDA-X 0.08 B88_X 0.72 LYP_C 0.81 LDA-C 0.19 HF 0.20 %endblock xc_definition Using the full specification in xc_definition makes it straightforward to adjust the various component weightings to your own specification. There are other adjustments that can be made within the functional. For example the popular functional HSE06 contains a screened Hartree-Fock component, with a mixture of other local functionals. It can be specified component by component as %block xc_definition SHF 0.25 PBE 1.0 PBE_X_SR -0.25 NLXC_SCREENING_LENGTH 0.11 NLXC_SCREENING_FUNCTION ERRORFUNCTION %endblock xc_definition In this case we have 25% screened Hartree-Fock offsetting -25% screened PBE exchange (and 100% PBE correlation within PBE). The default HF screening is exponential, but this can be changed to an error function as shown in the block. Also the strength of the screening can be altered by the NLXC_SCREENING_LENGTH parameter (natural units). 2. Hybrid functionals are expensive calculations, much(!) more computationally intensive than (semi-)local functionals. They are often used because they are able to give much better electronic band gaps. If we do LDA and SHF-LDA band structure for silicon we can use the cell file %block lattice_cart 2.7 2.7 0.0 2.7 0.0 2.7 0.0 2.7 2.7 %endblock lattice_cart %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac symmetry_generate %block spectral_kpoint_path W G X W L G %endblock spectral_kpoint_path %block species_pot NCP %endblock species_pot and then the .param file for LDA task : spectral spectral_task : BandStructure xc_functional : lda and for screened exchange, task : spectral spectral_task : BandStructure xc_functional : shf-lda If we then plot these two band structures together, the difference in results can be seen, the band gap opens from the LDA value of around 0.5eV to a more realistic 1.","title":"Controlling XC"},{"location":"documentation/XC/XCoverview/","text":"There are many sources of description of the role of exchange and correlation within density functional theory, https://en.wikipedia.org/wiki/Density_functional_theory Here we will look at how to give both a basic control over the XC functional that your calculation will use and well as giving finer control over functionals that have free parameters.","title":"Overview"},{"location":"documentation/XC/libXC/","text":"There are many (many!) XC functionals (of varying quality and applicability). LIBXC ( https://www.tddft.org/programs/libxc/ ) is a maintained library of functionals that is upgraded regularly. The list of functionals available in LIBXC is at https://www.tddft.org/programs/libxc/functionals/ . Castep interfaces to this library which can be used instead of Castep's in-built library of XC functionals. Prepend the string LIBXC_ to Castep's functional name in the parameter keyword xc_functional to use LIBXC. For example: xc_functional : PBE for Castep's in-built PBE functional xc_functional : LIBXC_PBE for the LIBXC version of the PBE functional In the LIBXC library there are many functionals, covering LDAs, GGAs, Meta-GGAs, Hybrids, etc. Most of these are separated into exchange and correlation contributions. To use these functionals, build your own combination using Castep's xc_definition keyword in the .param file. Firstly at https://www.tddft.org/programs/libxc/functionals/ find the exchange and correlation functionals that you require, note the name LIBXC calls is and then prepend the string LIBXC_ to them. For example to construct Perdew and Zunger's LDA, LDA exchange is called LDA_X and correlation is called LDA_C_PZ. In the .param file use %block xc_definition LIBXC_LDA_X 1.0 LIBXC_LDA_C_PZ 1.0 %endblock xc_definition The \"1.0\" after each is the fraction of how much of each you require to use, in this case 100% of each. Example, construct the PBE functional from LIBXC: In LIBXC, PBE exchange is called GGA_X_PBE and its correlation is called GGA_C_PBE. Prepend with LIBXC_ and construct xc_definition : %block xc_definition LIBXC_GGA_X_PBE 1.0 LIBXC_GGA_C_PBE 1.0 %endblock xc_definition There are a few functional in LIBXC that have combined exchange and correlation parts, so this can be listed in xc_definition on its own. For example the HCTH93 XC functional is called GGA_XC_HCTH_93 in LIBXC hence it can be used in Castep with %block xc_definition LIBXC_GGA_XC_HCTH_93 1.0 %endblock xc_definition LIBXC can also be used to construct hybrid (non-local) functionals that contain (screened) Hartree-Fock components. Note that LIBXC does not contain the non-local part of such functionals, just the local part. Construct the functional using Castep's non-local functionality. For example, the PBE0 functional is called HYB_GGA_XC_PBE0 in LIBXC, so to construct this use %block xc_definition LIBXC_HYB_GGA_XC_PBE0 1.0 HF 0.25 %endblock xc_definition Note here you need to know (ie. read the HYB_GGA_XC_PBE0 reference given in https://www.tddft.org/programs/libxc/functionals/ ) what fraction of local exchange is in the functional and so infer what the fraction of non-local exchange is required (here 0.25). If you want to vary the fraction of non-local exchange then you need to balance this with offsetting it with the correct fraction of local exchange. For this construct the whole functional yourself. For example PBE0 is 0.25HF + 0.75PBE_X + 1.0PBE_C. Varying the HF component in PBE0 can be done with %block xc_definition HF 0.20 LIBXC_GGA_PBE_X 0.80 LIBXC_GGA_PBE_C_1.0 %endblock xc_definition where here it's set to 20% non-local and 80% local exchange, with 100% PBE correlation. Meta-GGAs are also supported. For example the RSCAN functional can be used with %block xc_definition LIBXC_MGGA_X_RSCAN 1.0 LIBXC_MGGA_C_RSCAN 1.0 %endblock xc_definition (although RSCAN is also natively supported in Castep with xc_functional : RSCAN ). The xc_definition keyword in the .param file will allow you to mix and match any of the hundreds of functionals in LIBXC https://www.tddft.org/programs/libxc/functionals/ . DO SO WITH EXTREME CAUTION!","title":"libXC"},{"location":"documentation/XRD/overview/","text":"X-ray Structure Factors Basic Theory The X-ray structure factor (SF) intensities can be measured by diffraction experiments involving either X-rays, \\gamma \\gamma -rays or electron beams. It is directly related to the electron density within the unit cell of a material, n(\\mathbf{r}) n(\\mathbf{r}) , by a Fourier transformation 1 : F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, where \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* is the scattering vector corresponding to the (hkl) (hkl) plane, with \\mathbf{a}^*, \\mathbf{b}^* \\mathbf{a}^*, \\mathbf{b}^* and \\mathbf{c}^* \\mathbf{c}^* being the reciprocal lattice vectors of the conventional unit cell. Computation of the SF is difficult within plane-wave pseudopotential DFT codes since the total \"all-electron'' electron density is not normally directly computed and the FFT grids used to house the pseudised valence electron density do not have enough spatial resolution to capture the rapid oscillations near the atomic cores of the total electron density, requiring large plane-wave energy cutoffs in the order of several thousands of eV. Within CASTEP, we have developed an efficient and accurate approach towards calculating these SFs without having to move to large FFT grids or plane-wave energy cutoffs. Details of this implementation can be found in the paper (CITE PAPER WHEN PUBLISHED) but the key observation that has enabled this development is that the electron density can be separated into atom-centred contributions which can be treated on separate radial grids. The resulting structure factor has the form 2 : F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), where f_j(\\mathbf{H}) f_j(\\mathbf{H}) is an effective atomic scattering factor of atom j j within the unit cell, defined to be the Fourier transform of its effective atomic density \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) : f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}. f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}. Incorporating Thermal Effects Within experiments, thermal vibrations (i.e. phonons) can modify the (time-averaged) electron density and, hence, SFs. Making the approximation that the electron density assigned to each atom \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) directly follows its nuclear motion perfectly, the structure factors can incoporate these thermal vibration effects by including an atomic temperature factor T(\\mathbf{H}) T(\\mathbf{H}) : F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). Taking the vibrations of an atom to follow that of a harmonic oscillator, the temperature factor can be shown to be of the form: T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), where \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle are the averaged, squared, thermal displacements of the atom. For the case where the vibrations are isotropic, this equation reduces to: T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), where B is termed the Debye-Waller factor. Keywords Currently, to enable CASTEP (versions 21 and beyond) to calculate X-ray SFs, the desired SFs must be placed between CALCULATE_XRD_SF: and :ENDCALCULATE_XRD_SF within the devel_code block of the seed.param file. For example, the (111) (111) and (200) (200) and (220) (220) SFs can be calculated by appending the following code to the end of the seed.param file: %block devel_code CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, if no structure factors are listed, as in: %block devel_code CALCULATE_XRD_SF: :ENDCALCULATE_XRD_SF %endblock devel_code then the SFs on the entire FFT grid will be written out. Thermal effects can also be incoporated by placing the desired atomic Debye-Waller (DW) factors between DW_FACTOR: and :ENDDW_FACTOR within the devel_code block of the seed.param file. For isotropic DW factors, the value of the DW factor can be written next to the corresponding atomic symbol as below: %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, the entire anisotropic displacement tensor of each atomic species may be specified as follows: %block devel_code DW_FACTOR: Mg 0.305 0.000 0.000 0.000 0.305 0.000 0.000 0.000 0.305 O 0.340 0.000 0.000 0.000 0.340 0.000 0.000 0.000 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Note Structure factor calculations are a post-processing calculation, so they can be restarted from a previous DFT calculation's .check file by using the CONTINUATION parameter in CASTEP. Output Files The resulting structure factors that have been calculated will be outputted into a file named seed.xrd_sf . For the following inputs: ! MgO.param xc_functional : PBE %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 0 0 2 0 2 2 :ENDCALCULATE_XRD_SF %endblock devel_code ! MgO.cell %BLOCK LATTICE_CART ang 4.2112 0.0 0.0 0.0 4.2112 0.0 0.0 0.0 4.2112 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Mg 0.00 0.00 0.00 Mg 0.50 0.50 0.00 Mg 0.50 0.00 0.50 Mg 0.00 0.50 0.50 O 0.00 0.50 0.00 O 0.50 0.00 0.00 O 0.00 0.00 0.50 O 0.50 0.50 0.50 %ENDBLOCK POSITIONS_FRAC kpoint_mp_grid 8 8 8 SYMMETRY_GENERATE We get a resulting seed.xrd_sf file with the output: h k l Re(F_PAW) Im(F_PAW) Re(F_IAM) Im(F_IAM) Re(F_PP) Im(F_PP) Re(F_core) Im(F_core) Re(F_soft) Im(F_soft) Re(F_aug) Im(F_aug) 1 1 1 11.115757 -0.000000 12.492143 -0.000000 10.926445 -0.000000 0.085890 -0.000000 -9.892234 0.000000 20.922101 -0.000000 0 0 2 52.877502 0.000000 51.830521 -0.000000 52.626486 0.000000 15.464656 -0.000000 15.585172 -0.000000 21.827675 0.000000 0 2 2 41.051122 0.000000 40.948429 -0.000000 40.609195 0.000000 14.950468 -0.000000 7.954567 -0.000000 18.146087 0.000000 After the header, the structure factors are listed along each row based on the order in which they have been listed in the seed.param file. Across the columns along each row, the h, k,l h, k,l vectors are first listed before the real and imaginary components of the SF are listed under Re(F_PAW) and Im(F_PAW) respectively. Several other (less accurate) SFs that are commonly found in literature as well as charge contributions to F_PAW are also listed in columns further to the right, as described below: Label Description F_PAW DFT structure factor with all-electron augmentation charge F_IAM Indepedent atom model structure factor; electron densit formed from superposition of atomic electron densities obtained by numerically solving the Koelling-Harmon equation F_PP DFT structure factor with pseudised (inaccurate) augmentation charge F_core Structure factor contribution to F_PAW due to the (frozen) core electrons F_soft Structure factor contribution to F_PAW due to the soft valence charge (where augmentation charge contribute is removed) F_aug Structure factor contribution due to the all-electron valence augmentation charge P. Coppens, X-Ray Charge Densities and Chemical Bonding (International Union of Crystallography, New York, 1997) \u21a9 U. Shmueli and Internationale Union f\u00fcr Kristallographie, editors , International Tables for Crystallography. Vol. B: Reciprocal Space, 2. ed (Kluwer Acad. Publ, Dordrecht, 2001) \u21a9","title":"XRD"},{"location":"documentation/XRD/overview/#x-ray-structure-factors","text":"","title":"X-ray Structure Factors"},{"location":"documentation/XRD/overview/#basic-theory","text":"The X-ray structure factor (SF) intensities can be measured by diffraction experiments involving either X-rays, \\gamma \\gamma -rays or electron beams. It is directly related to the electron density within the unit cell of a material, n(\\mathbf{r}) n(\\mathbf{r}) , by a Fourier transformation 1 : F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, where \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* is the scattering vector corresponding to the (hkl) (hkl) plane, with \\mathbf{a}^*, \\mathbf{b}^* \\mathbf{a}^*, \\mathbf{b}^* and \\mathbf{c}^* \\mathbf{c}^* being the reciprocal lattice vectors of the conventional unit cell. Computation of the SF is difficult within plane-wave pseudopotential DFT codes since the total \"all-electron'' electron density is not normally directly computed and the FFT grids used to house the pseudised valence electron density do not have enough spatial resolution to capture the rapid oscillations near the atomic cores of the total electron density, requiring large plane-wave energy cutoffs in the order of several thousands of eV. Within CASTEP, we have developed an efficient and accurate approach towards calculating these SFs without having to move to large FFT grids or plane-wave energy cutoffs. Details of this implementation can be found in the paper (CITE PAPER WHEN PUBLISHED) but the key observation that has enabled this development is that the electron density can be separated into atom-centred contributions which can be treated on separate radial grids. The resulting structure factor has the form 2 : F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), where f_j(\\mathbf{H}) f_j(\\mathbf{H}) is an effective atomic scattering factor of atom j j within the unit cell, defined to be the Fourier transform of its effective atomic density \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) : f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}. f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}.","title":"Basic Theory"},{"location":"documentation/XRD/overview/#incorporating-thermal-effects","text":"Within experiments, thermal vibrations (i.e. phonons) can modify the (time-averaged) electron density and, hence, SFs. Making the approximation that the electron density assigned to each atom \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) directly follows its nuclear motion perfectly, the structure factors can incoporate these thermal vibration effects by including an atomic temperature factor T(\\mathbf{H}) T(\\mathbf{H}) : F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). Taking the vibrations of an atom to follow that of a harmonic oscillator, the temperature factor can be shown to be of the form: T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), where \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle are the averaged, squared, thermal displacements of the atom. For the case where the vibrations are isotropic, this equation reduces to: T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), where B is termed the Debye-Waller factor.","title":"Incorporating Thermal Effects"},{"location":"documentation/XRD/overview/#keywords","text":"Currently, to enable CASTEP (versions 21 and beyond) to calculate X-ray SFs, the desired SFs must be placed between CALCULATE_XRD_SF: and :ENDCALCULATE_XRD_SF within the devel_code block of the seed.param file. For example, the (111) (111) and (200) (200) and (220) (220) SFs can be calculated by appending the following code to the end of the seed.param file: %block devel_code CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, if no structure factors are listed, as in: %block devel_code CALCULATE_XRD_SF: :ENDCALCULATE_XRD_SF %endblock devel_code then the SFs on the entire FFT grid will be written out. Thermal effects can also be incoporated by placing the desired atomic Debye-Waller (DW) factors between DW_FACTOR: and :ENDDW_FACTOR within the devel_code block of the seed.param file. For isotropic DW factors, the value of the DW factor can be written next to the corresponding atomic symbol as below: %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, the entire anisotropic displacement tensor of each atomic species may be specified as follows: %block devel_code DW_FACTOR: Mg 0.305 0.000 0.000 0.000 0.305 0.000 0.000 0.000 0.305 O 0.340 0.000 0.000 0.000 0.340 0.000 0.000 0.000 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Note Structure factor calculations are a post-processing calculation, so they can be restarted from a previous DFT calculation's .check file by using the CONTINUATION parameter in CASTEP.","title":"Keywords"},{"location":"documentation/XRD/overview/#output-files","text":"The resulting structure factors that have been calculated will be outputted into a file named seed.xrd_sf . For the following inputs: ! MgO.param xc_functional : PBE %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 0 0 2 0 2 2 :ENDCALCULATE_XRD_SF %endblock devel_code ! MgO.cell %BLOCK LATTICE_CART ang 4.2112 0.0 0.0 0.0 4.2112 0.0 0.0 0.0 4.2112 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Mg 0.00 0.00 0.00 Mg 0.50 0.50 0.00 Mg 0.50 0.00 0.50 Mg 0.00 0.50 0.50 O 0.00 0.50 0.00 O 0.50 0.00 0.00 O 0.00 0.00 0.50 O 0.50 0.50 0.50 %ENDBLOCK POSITIONS_FRAC kpoint_mp_grid 8 8 8 SYMMETRY_GENERATE We get a resulting seed.xrd_sf file with the output: h k l Re(F_PAW) Im(F_PAW) Re(F_IAM) Im(F_IAM) Re(F_PP) Im(F_PP) Re(F_core) Im(F_core) Re(F_soft) Im(F_soft) Re(F_aug) Im(F_aug) 1 1 1 11.115757 -0.000000 12.492143 -0.000000 10.926445 -0.000000 0.085890 -0.000000 -9.892234 0.000000 20.922101 -0.000000 0 0 2 52.877502 0.000000 51.830521 -0.000000 52.626486 0.000000 15.464656 -0.000000 15.585172 -0.000000 21.827675 0.000000 0 2 2 41.051122 0.000000 40.948429 -0.000000 40.609195 0.000000 14.950468 -0.000000 7.954567 -0.000000 18.146087 0.000000 After the header, the structure factors are listed along each row based on the order in which they have been listed in the seed.param file. Across the columns along each row, the h, k,l h, k,l vectors are first listed before the real and imaginary components of the SF are listed under Re(F_PAW) and Im(F_PAW) respectively. Several other (less accurate) SFs that are commonly found in literature as well as charge contributions to F_PAW are also listed in columns further to the right, as described below: Label Description F_PAW DFT structure factor with all-electron augmentation charge F_IAM Indepedent atom model structure factor; electron densit formed from superposition of atomic electron densities obtained by numerically solving the Koelling-Harmon equation F_PP DFT structure factor with pseudised (inaccurate) augmentation charge F_core Structure factor contribution to F_PAW due to the (frozen) core electrons F_soft Structure factor contribution to F_PAW due to the soft valence charge (where augmentation charge contribute is removed) F_aug Structure factor contribution due to the all-electron valence augmentation charge P. Coppens, X-Ray Charge Densities and Chemical Bonding (International Union of Crystallography, New York, 1997) \u21a9 U. Shmueli and Internationale Union f\u00fcr Kristallographie, editors , International Tables for Crystallography. Vol. B: Reciprocal Space, 2. ed (Kluwer Acad. Publ, Dordrecht, 2001) \u21a9","title":"Output Files"},{"location":"tutorials/Bands_and_DOS/magnetic/","text":"Iron ! Fe.cell %BLOCK LATTICE_CART -1.433199999999999 1.433200000000001 1.433200000000001 1.433200000000001 -1.433200000000000 1.433200000000000 1.433200000000000 1.433200000000000 -1.433200000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Fe 0.0000000000000000 0.0000000000000000 0.0000000000000000 %ENDBLOCK POSITIONS_FRAC symmetry_generate ! Kpoint grid for the Groundstate (SCF) calculation kpoint_mp_grid 8 8 8 ! kpoint path through the Brillouin Zone for the Bandstructure %BLOCK spectral_KPOINT_PATH 0.0 0.0 0.0 !G 0.5 0.5 0.5 !H 0.5 0.0 0.0 !N 0.0 0.0 0.0 !G 0.75 0.25 -0.25 !P 0.5 0.0 0.0 !N %ENDBLOCK spectral_KPOINT_PATH In the param file we set spin_polarised true in order to allow the up and down spin electrons to take different configurations. It is important to start the calculation with an initial spin density using e.g. spin: 1 . The value of the initial spin should not affect the final answer - a non-zero value is just needed to break the symmetry between the spin channels. ! Fe.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! grid_scale 2.0 ! opt_strategy speed ! Choose algorithms for best speed spin 1 ! Set the spin in the original cell to 1. spin_polarised true ! Run a spin polarised calculation spectral_nbands 6 ! number of bands to compute during the BS run At the end of the calculation the net spin of the unit cell is reported in the castep file e.g. Integrated Spin Density = 2.15322 hbar/2 Note The band structure has similarities with that of Copper - and other 3d elements - with flat 3d bands and dispersive s bands. We colour code the bands according to their spin chactacter (red=up, blue=down). We can see that there is an almost constant exchange splitting of 1.5eV between the up and down 3d bands. The splitting between the s-like bands is much smaller. More up states lie below the fermi energy than down states - hence the net spin of the unit cell. FeO FeO is an anti-ferromagnetic oxide. We set up the calculation with initial spins on the two Fe atoms pointing in opposite directions. ! FeO.cell %BLOCK LATTICE_CART 1.768531594289456 0.000000000000001 5.002162732258922 -0.884265797144728 1.531593288050063 5.002162732258921 -0.884265797144728 -1.531593288050063 5.002162732258922 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC O 0.75 0.750 -1.250 O -0.75 -0.750 1.250 Fe 0.00 0.000 -0.000 spin=-4.0 Fe 1.50 -0.500 -0.500 spin=4.0 %ENDBLOCK POSITIONS_FRAC kpoints_mp_grid: 6 6 6 symmetry_generate %block spectral_kpoint_path 0.500 0.500 0.000 0.000 0.000 0.000 0.500 0.500 0.500 0.000 0.500 0.000 0.000 0.000 0.000 %endblock spectral_kpoint_path ! FeO.param task : spectral ! The TASK keyword instructs CASTEP what to do xc_functional : PBE ! Which exchange-correlation functional to use. cutoff_energy 600 eV opt_strategy speed ! Choose algorithms for speed. nextra_bands : 6 spin_polarized : true A PBE calculation incorrectly finds FeO to be a metal (bandstructure on left below). Add the following to the cell file to run a PBE+U calculation %block hubbard_u Fe 1 d: 2.5 Fe 2 d: 2.5 %endblock hubbard_u FeO band structure with PBE (left) and with PBE+U (right) Note Adding a Hubbard U term to the calculation opens the band gap and FeO is (correctly) predicted to be an antiferromangetic insulator.","title":"Magnetic Materials"},{"location":"tutorials/Bands_and_DOS/magnetic/#iron","text":"! Fe.cell %BLOCK LATTICE_CART -1.433199999999999 1.433200000000001 1.433200000000001 1.433200000000001 -1.433200000000000 1.433200000000000 1.433200000000000 1.433200000000000 -1.433200000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Fe 0.0000000000000000 0.0000000000000000 0.0000000000000000 %ENDBLOCK POSITIONS_FRAC symmetry_generate ! Kpoint grid for the Groundstate (SCF) calculation kpoint_mp_grid 8 8 8 ! kpoint path through the Brillouin Zone for the Bandstructure %BLOCK spectral_KPOINT_PATH 0.0 0.0 0.0 !G 0.5 0.5 0.5 !H 0.5 0.0 0.0 !N 0.0 0.0 0.0 !G 0.75 0.25 -0.25 !P 0.5 0.0 0.0 !N %ENDBLOCK spectral_KPOINT_PATH In the param file we set spin_polarised true in order to allow the up and down spin electrons to take different configurations. It is important to start the calculation with an initial spin density using e.g. spin: 1 . The value of the initial spin should not affect the final answer - a non-zero value is just needed to break the symmetry between the spin channels. ! Fe.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! grid_scale 2.0 ! opt_strategy speed ! Choose algorithms for best speed spin 1 ! Set the spin in the original cell to 1. spin_polarised true ! Run a spin polarised calculation spectral_nbands 6 ! number of bands to compute during the BS run At the end of the calculation the net spin of the unit cell is reported in the castep file e.g. Integrated Spin Density = 2.15322 hbar/2 Note The band structure has similarities with that of Copper - and other 3d elements - with flat 3d bands and dispersive s bands. We colour code the bands according to their spin chactacter (red=up, blue=down). We can see that there is an almost constant exchange splitting of 1.5eV between the up and down 3d bands. The splitting between the s-like bands is much smaller. More up states lie below the fermi energy than down states - hence the net spin of the unit cell.","title":"Iron"},{"location":"tutorials/Bands_and_DOS/magnetic/#feo","text":"FeO is an anti-ferromagnetic oxide. We set up the calculation with initial spins on the two Fe atoms pointing in opposite directions. ! FeO.cell %BLOCK LATTICE_CART 1.768531594289456 0.000000000000001 5.002162732258922 -0.884265797144728 1.531593288050063 5.002162732258921 -0.884265797144728 -1.531593288050063 5.002162732258922 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC O 0.75 0.750 -1.250 O -0.75 -0.750 1.250 Fe 0.00 0.000 -0.000 spin=-4.0 Fe 1.50 -0.500 -0.500 spin=4.0 %ENDBLOCK POSITIONS_FRAC kpoints_mp_grid: 6 6 6 symmetry_generate %block spectral_kpoint_path 0.500 0.500 0.000 0.000 0.000 0.000 0.500 0.500 0.500 0.000 0.500 0.000 0.000 0.000 0.000 %endblock spectral_kpoint_path ! FeO.param task : spectral ! The TASK keyword instructs CASTEP what to do xc_functional : PBE ! Which exchange-correlation functional to use. cutoff_energy 600 eV opt_strategy speed ! Choose algorithms for speed. nextra_bands : 6 spin_polarized : true A PBE calculation incorrectly finds FeO to be a metal (bandstructure on left below). Add the following to the cell file to run a PBE+U calculation %block hubbard_u Fe 1 d: 2.5 Fe 2 d: 2.5 %endblock hubbard_u FeO band structure with PBE (left) and with PBE+U (right) Note Adding a Hubbard U term to the calculation opens the band gap and FeO is (correctly) predicted to be an antiferromangetic insulator.","title":"FeO"},{"location":"tutorials/Bands_and_DOS/metals/","text":"Here we use CASTEP to calculate the bandstructure of two typical metals. The cell and param files are very similar to the semiconductor examples - the one difference is that we use a finer sampling of the Brillouin Zone with the keyword kpoint_mp_grid . A finer sampling is needed to correctly represent the change in occupancy at the Fermi energy. Aluminium ! Al.cell %BLOCK LATTICE_ABC 2.86 2.86 2.86 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Al 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Al.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Aluminium is a metal - there is no gap energy between the occupied and unoccupied states. The bands are close to parabolic (this is particularly noticeable around Gamma) - the electronic structure of aluminium closely follows a nearly-free electron model. Copper ! Cu.cell %BLOCK LATTICE_ABC 2.55 2.55 2.55 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Cu 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Cu.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed at expense of memory. spectral_nbands 8 ! Note Copper is a metal - there is no gap energy between the occupied and unoccupied states. The bandstructure of copper is typical for a transition metal - we have highly dispersive parabolic bands corresponding to the s electrons, these are crossed by 5 quite flat bands corresponding to more localised 3d electrons. In copper the 3d states are filled, and we see the flat bands lie below the Fermi level.","title":"Metals"},{"location":"tutorials/Bands_and_DOS/metals/#aluminium","text":"! Al.cell %BLOCK LATTICE_ABC 2.86 2.86 2.86 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Al 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Al.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Aluminium is a metal - there is no gap energy between the occupied and unoccupied states. The bands are close to parabolic (this is particularly noticeable around Gamma) - the electronic structure of aluminium closely follows a nearly-free electron model.","title":"Aluminium"},{"location":"tutorials/Bands_and_DOS/metals/#copper","text":"! Cu.cell %BLOCK LATTICE_ABC 2.55 2.55 2.55 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Cu 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Cu.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed at expense of memory. spectral_nbands 8 ! Note Copper is a metal - there is no gap energy between the occupied and unoccupied states. The bandstructure of copper is typical for a transition metal - we have highly dispersive parabolic bands corresponding to the s electrons, these are crossed by 5 quite flat bands corresponding to more localised 3d electrons. In copper the 3d states are filled, and we see the flat bands lie below the Fermi level.","title":"Copper"},{"location":"tutorials/Bands_and_DOS/plotting_perl/","text":"In this tutorial we will walk through plotting a bandstructure and density of states using the perl utilities supplied with CASTEP. We will use Xmgace for plotting - however, the scripts also support gnuplot. Bandstructure Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dispersion.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dispersion.pl -h' castep si-bands dispersion.pl -sym fcc -xg si-bands.bands You should get a plot Density of States Here is a cell file. It is the same as a bandstructure cell file except we have replaced the path through the Brillioun zone with a regular grid of k-points. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a uniform sampling of the Brillouin Zone ! spectral_kpoint_mp_grid 17 17 17 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task dos ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dos.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dos.pl -h' castep si-dos dos.pl -xg si-dos.bands -w 0.3 You should get a plot like Note The procedure above is inefficient as we computed the groundstate of the system twice, once when computing the bandstructure and again when computing the dos. To avoid this we could put the following line in the si-dos.param file continuation: si-bands.check . This will restart the calculation of the dos using the previously computed groundstate.","title":"Plotting - CASTEP tools"},{"location":"tutorials/Bands_and_DOS/plotting_perl/#bandstructure","text":"Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dispersion.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dispersion.pl -h' castep si-bands dispersion.pl -sym fcc -xg si-bands.bands You should get a plot","title":"Bandstructure"},{"location":"tutorials/Bands_and_DOS/plotting_perl/#density-of-states","text":"Here is a cell file. It is the same as a bandstructure cell file except we have replaced the path through the Brillioun zone with a regular grid of k-points. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a uniform sampling of the Brillouin Zone ! spectral_kpoint_mp_grid 17 17 17 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task dos ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dos.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dos.pl -h' castep si-dos dos.pl -xg si-dos.bands -w 0.3 You should get a plot like Note The procedure above is inefficient as we computed the groundstate of the system twice, once when computing the bandstructure and again when computing the dos. To avoid this we could put the following line in the si-dos.param file continuation: si-bands.check . This will restart the calculation of the dos using the previously computed groundstate.","title":"Density of States"},{"location":"tutorials/Bands_and_DOS/plotting_sumo/","text":"This is stub for https://github.com/ajjackson/castep-sumo-tutorial/blob/master/castep-sumo.org","title":"Plotting - SUMO"},{"location":"tutorials/Bands_and_DOS/semiconductors/","text":"In this tutorial we will show you the cell and param files needed to plot bandstructures and density of states plots for various semiconductors. For the commands needed to make the plots refer to earlier tutorials. Silicon ! Si.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path ! Si.cell task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Silicon is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is indirect as the valence band maximum is as Gamma, but the conduction band minimum lies between Gamma and X. Gallium Arsenide The cell file is almost identical to the silicon example above, except that the unitc cell length is slighly larger, and we have replaced one Si atom with Ga, and the other Si with As. ! GaAs.cell %block lattice_abc 4 4 4 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Ga 0.00 0.00 0.00 As 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path The param file is unchanged from the Silicon example ! GaAs.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note GaAs is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is direct both the valence band maximum and conduction band minimum are at Gamma. Compared with Silicon we see that the original bandstructure contains low lying flat bands at around -32eV and -12eV. This is because both the Ga and As pseudopotentials include semi-core states in the valence. The red states are the As 3d and the green are the Ga 3d.","title":"Semiconductors"},{"location":"tutorials/Bands_and_DOS/semiconductors/#silicon","text":"! Si.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path ! Si.cell task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Silicon is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is indirect as the valence band maximum is as Gamma, but the conduction band minimum lies between Gamma and X.","title":"Silicon"},{"location":"tutorials/Bands_and_DOS/semiconductors/#gallium-arsenide","text":"The cell file is almost identical to the silicon example above, except that the unitc cell length is slighly larger, and we have replaced one Si atom with Ga, and the other Si with As. ! GaAs.cell %block lattice_abc 4 4 4 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Ga 0.00 0.00 0.00 As 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path The param file is unchanged from the Silicon example ! GaAs.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note GaAs is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is direct both the valence band maximum and conduction band minimum are at Gamma. Compared with Silicon we see that the original bandstructure contains low lying flat bands at around -32eV and -12eV. This is because both the Ga and As pseudopotentials include semi-core states in the valence. The red states are the As 3d and the green are the Ga 3d.","title":"Gallium Arsenide"},{"location":"tutorials/Bonding_and_Charge/charge_density/","text":"In this tutorial we will walk through plotting a charge density with Vesta https://jp-minerals.org/vesta/en/ Silicon Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 1500 eV #this next line causes the charge to be written in a den_fmt file write_formatted_density : T spin_polarised : false The cutoff energy is somewhat higher than needed for a converged total energy - but it helps when making a smoother looking charge density plot. Run castep. You will see a file called silicon.den_fmt this contains the charge density in a formatted (i.e. a human readable, ASCII file). We need to change this file into a format Vesta can read. Copy it to a file called silicon.charg_frm cp silicon.den_fmt silicon.charg_frm Now edit the file silicon.charg_frm with a text editor to remove the first 11 lines. The file should now begin with 1 1 1 and a number. You can now open silicon.charg_frm with Vesta. Note that Vesta needs both the cell and charge_frm files to make a plot. If you are working on a remote machine you will need to copy both of these back to your local machine to view with Vesta. You can find a walkthrough video of this process at https://youtu.be/_c2Hk4jxmm4 An alternative way to plot charge densities (and much more besides) is c2x https://www.c2x.org.uk","title":"Plotting Charge Density"},{"location":"tutorials/Bonding_and_Charge/charge_density/#silicon","text":"Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 1500 eV #this next line causes the charge to be written in a den_fmt file write_formatted_density : T spin_polarised : false The cutoff energy is somewhat higher than needed for a converged total energy - but it helps when making a smoother looking charge density plot. Run castep. You will see a file called silicon.den_fmt this contains the charge density in a formatted (i.e. a human readable, ASCII file). We need to change this file into a format Vesta can read. Copy it to a file called silicon.charg_frm cp silicon.den_fmt silicon.charg_frm Now edit the file silicon.charg_frm with a text editor to remove the first 11 lines. The file should now begin with 1 1 1 and a number. You can now open silicon.charg_frm with Vesta. Note that Vesta needs both the cell and charge_frm files to make a plot. If you are working on a remote machine you will need to copy both of these back to your local machine to view with Vesta. You can find a walkthrough video of this process at https://youtu.be/_c2Hk4jxmm4 An alternative way to plot charge densities (and much more besides) is c2x https://www.c2x.org.uk","title":"Silicon"},{"location":"tutorials/Bonding_and_Charge/mulliken_population/","text":"By default castep will calculate the Mulliken Population analysis at the end of every calculation (the keyword popn_calculate is set to true by default). Silicon Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 500 eV spin_polarised : false Run castep. Toward the end of the file silicon.castep you will find Atomic Populations (Mulliken) ----------------------------- Species Ion s p d f Total Charge (e) ========================================================================== Si 1 1.356 2.644 0.000 0.000 4.000 0.000 Si 2 1.356 2.644 0.000 0.000 4.000 0.000 ========================================================================== Bond Population Length (A) ====================================================================== Si 1 -- Si 2 2.99 2.32702 ====================================================================== The atoms are not charged overall, and there is a large bond population. This is all indicative of a strong covalent bond. To finish","title":"Population Analysis"},{"location":"tutorials/Bonding_and_Charge/mulliken_population/#silicon","text":"Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 500 eV spin_polarised : false Run castep. Toward the end of the file silicon.castep you will find Atomic Populations (Mulliken) ----------------------------- Species Ion s p d f Total Charge (e) ========================================================================== Si 1 1.356 2.644 0.000 0.000 4.000 0.000 Si 2 1.356 2.644 0.000 0.000 4.000 0.000 ========================================================================== Bond Population Length (A) ====================================================================== Si 1 -- Si 2 2.99 2.32702 ====================================================================== The atoms are not charged overall, and there is a large bond population. This is all indicative of a strong covalent bond.","title":"Silicon"},{"location":"tutorials/Bonding_and_Charge/mulliken_population/#to-finish","text":"","title":"To finish"},{"location":"tutorials/NEB/neb_tutorial/","text":"Nudged elastic band tutorial Overview and background The nudged elastic band (NEB) approach is a widely-used method for finding a minimum energy pathway between two configurations of atoms. You can use the method to estimate the barrier for the system to transition between the two structures. The technique starts with two fixed end points which are fully relaxed (local) minima: the initial and final configurations. It then connects these end points with a series of \"images\" via fictitious springs that \"pull\" the structures taut over one or more intermediate transition states. In this tutorial, we will use the well-known example of an ammonia molecule's pyramidal inversion We will cover: How to set up the initial, final (and intermediate) structures How to actually run the NEB calculation efficiently How to analyse the results Other tips and tricks Files You can find all the files needed for this tutorial here: neb_tutorial.tar.gz Setting up the structures Setting up the initial and final states These are the local minima structures you want to find the barrier between. They can be equivalent structures, e.g. differing by a symmetry operation, such reflection through a mirror plane, or they can be configurations with different energies (in which case your forward and reverse barriers will not be the same!). Two crucial conditions must be met before running the NEB calculation : The end point structures must be fully relaxed (geometry optimised) before you start the NEB. Note that both the initial relaxations and the actual NEB calculation must use consistent parameters (e.g. basis set, pseudopotentials, k-points, XC functional etc.). The atoms must be in the correct order. A common mistake is to use a software tool to generate the final state from the initial state and end up with atoms that don't match the initial atom order. Atoms then \"pass through each other\" when CASTEP interpolates between the two structures, causing the calculation to blow up. Always check that the atoms connect up in the way you expect. The initial state is specified in the same way as a normal .cell file, e.g.: %BLOCK positions_frac H 0.500011764912384 0.634846485697942 0.443086003907125 H 0.616593728396204 0.432553816946042 0.442828605918639 H 0.383248448613152 0.432623959245757 0.443068863520867 N 0.500000000000000 0.500000000000000 0.500000000000000 %ENDBLOCK positions_frac The final state is specified using a similar block in the same .cell file but with _product appended to the name of the block, e.g.: %BLOCK positions_frac_product H 0.500154169007758 0.634858887961251 0.556834437330747 H 0.616661280589956 0.432482046338754 0.556941161085851 H 0.383366127862304 0.432719065607707 0.557277918851780 N 0.500000000000000 0.500000000000000 0.500000000000000 %ENDBLOCK positions_frac_product Setting up the transition state guess CASTEP will linearly interpolate between the initial and final structures provided to generate the first guess of the minimum energy pathway. This works well in many cases. However, if your minimum energy pathway contains e.g. a rotation of a (group of) atom(s) around a bond or something similar, then the linear path between initial and final configurations may be a bad starting guess/non-physical structure. For example, if your end points correspond to a C2 rotation, then a linearly interpolated intermediate structure would not be a physical one. It's important to visualise or otherwise check all of your structures before running a calculation. Intermediate structures can also be chosen in such a way as to bias your results to one pathway over another. CASTEP allows you to provide one intermediate structure between the initial and final configurations in order to get the NEB on the right track. The intermediate configuration is added using, e.g.: %BLOCK POSITIONS_ABS_INTERMEDIATE ang N 3.500000 3.500000 3.500000 H 3.500000 4.443968 3.500000 H 4.316393 3.027626 3.500000 H 2.683149 3.028701 3.501215 %ENDBLOCK POSITIONS_ABS_INTERMEDIATE How many images do I need? It depends... It's usually preferable to start with a small number of images and increase the number if you need to. Starting small can quickly give you a rough sense of the energy landscape and that will determine the actual number of images needed. In addition, if you start with too many images then you might never get close to the converged TS because the optimisation takes too long. If you instead start with a small number and get a reasonable TS structure, you can then use that as your initial intermediate structure in a restarted calculation with more images. Using many (i.e. > 15) will result in slow convergence, but may lead to a more accurate minimum energy pathway for complex barriers. If you do find a particularly complex pathway, however, you might be better off splitting the work up into more than one NEB calculation, each with fewer images. Just remember to always fully relax the end points (even if the end point is a meta-stable local minimum)! Using too few (i.e. < 5) might fail to find the minimum energy pathway if the energy landscape is complex. TODO: add guidance on odd vs even number of images (touching on how the spacing is calculated) and on how many you need for this simple example -- maybe an exercise for the user? You can actually get the same barrier height with just one image in this simple case! Some questions to help answer how many images you need: How complex is the landscape between the initial and final state? For example, if you expect more than one maximum between the end points, you probably need more images than for the single peak example we look at here. Note The number of images is the number of structures between the end points. The total number of structures in the path (i.e. including the end points) is therefore the number of images + 2. Constraints We can often dramatically improve the efficiency of the transition state search by imposing constraints on the atomic positions, although this must be done with care so as not to introduce artifacts. For example, when looking at NEB barriers for adsorbates on a surface slab, we can usefully constrain the bottom slab layers, but probably want the top layer(s) unconstrained. In the ammonia case, we can constrain the N atom position without affecting the physical set up by adding the block: %BLOCK IONIC_CONSTRAINTS 1 N 1 1 0 0 2 N 1 0 1 0 3 N 1 0 0 1 %ENDBLOCK IONIC_CONSTRAINTS to the nh3.cell file. [Isn't there a more compact way now to specify a fixed atom?] You should then see something like: --- Initialising NEB constraints --- Fixed 3 degrees of freedom in the .castep output file. Do I need climbing NEB? The climbing NEB method modifies the force on the highest-energy image such that it tries to climb up the barrier. This is very useful to get accurate barrier estimates, but care must be taken when more complex pathways (i.e. with multiple maxima) are found. [Don't get this!] In our example the path is quite straightforward and it makes sense to use the climbing image method. We therefore set: TSSEARCH_NEB_CLIMBING: TRUE in the .param file. TODO: clarify what happens when you set climbing to true. TODO: include advice/explanation about starting with regular NEB and turning on climbing image after a few steps. Running the NEB Parallelisation Because the NEB calculation essentially involves N independent CASTEP calculations (where N is the number of images), we can make very efficient use of high-performance computers. This is done via \"task farming\", running the calculations for the N images independently. For example, if one CASTEP calculation fits on one node, and you have 7 images, then you could run on a total of 7 nodes by setting the keyword: NUM_FARMS: 7 in the .param file. A good rule of thumb is to aim for NUM_FARMS = number of NEB images. That way each 'farm' is responsible for one NEB image. Since each farm will effectively run a series of single-point calculations on each NEB image they are responsible for, the compute resources of that farm should be appropriately sized for such calculations. Too small and you could get an out-of-memory error, too large and you might end up over-parallelising, leading to reduced overall performance. i.e. you should aim to run on a total of NUM_FARMS times as many cores as you would use for a single-point calculation on one of the structures. This also assumes that your available compute resources can be neatly split into NUM_FARMS . The easy case is when each farm can run on a single node; i.e. NUM_FARMS = number of NEB images = number of nodes. Note that the total number of cores available must be divisible by NUM_FARMS . If you choose NUM_FARMS < number of images, each of the images will run sequentially on one farm as soon as that farm becomes available. If the number of images is not a multiple of NUM_FARMS , some farms will end up being responsible for more images than others, leading poor overall efficiency. If you choose NUM_FARMS > number of images, then some farms will be left with nothing to do, resulting in poor overall efficiency. Setting NUM_FARMS = 1 is equivalent to not setting NUM_FARMS . You will notice that if you enable task farming, the seedname.castep output file will look relatively empty, as most output is split into the different task farm .castep files. The first indexed one contains the most important information (for example, the \"Max NEB force\") and will be called e.g. seedname_farm001.castep . Is the calculation converging? You can monitor the convergence by searching for \"Max NEB force\" within the .castep output file. Common convergence issues include: Not having consistent order in the initial and final structures, i.e. non-physical initial path Too many (or too few) images [As above - not clear what this means, so looks odd.] Initial or final state (endpoints) not being fully relaxed structures Restarting / Continuing Sometimes the calculation will run out of time/number of iterations before the NEB calculation is finished. You will probably see a \"Failed to converge\" message in the .castep output in that case; always read through your output files! [Not obvious in .ts file? Shouldn't need to positively check for unconverged results.] If you re-run the calculation without changing anything, it will simply start from the beginning again -- probably not what you want! In order restart the NEB from the last checkpointed state, you need to explicitly set the name of the .check file you want to continue from in your .param file. In our example that would be: continuation: nh3.check In the .castep output you would then see: Coordinates of NEB images loaded from checkpoint file . Warning Unlike other CASTEP tasks, setting continuation: default does not seem to work for continuing/restarting NEB calculations! You must explicitly set the name of checkpoint file. Analysis Once you have a converged NEB, the provided Python utility readTS can be used to parse and analyse the NEB. To add the readTS module to your PYTHONPATH, you can find a setup.py script in the castep/Utilities/readts directory of your CASTEP source directory. Running python setup.py should install the module to your path. You can also manually add it by inserting the following line into your ~/.bashrc or equivalent and restarting the terminal: export PYTHONPATH = \"/path/to/castep/Utilities/readts: $PYTHONPATH \" (changing the /path/to/castep/ bit to wherever CASTEP is on your machine). You can then extract the NEB path using something like this python code: [This looks sufficiently general that you could supply the analysis.py script?] ## get this by adding castep/Utilities/readts to your PYTHONPATH from readts import TSFile from ase.neb import NEBTools def get_images ( tsfile ): ''' Function to extract the final NEB images from a tsfile object Args: tsfile (TSFile): tsfile object Returns: images (list): list of ASE atoms objects ''' diam_tst = tsfile . blocks [ 'TST' ] diam_i = tsfile . blocks [ 'REA' ][ 1 ][ 0 ] diam_f = tsfile . blocks [ 'PRO' ][ 1 ][ 0 ] nbeads = len ( diam_tst [ 1 ]) max_idx = diam_tst . last_index images = [ diam_i . atoms ] images += [ diam_tst [ max_idx ][ i ] . atoms for i in range ( 0 , nbeads , 1 )] images . append ( diam_f . atoms ) return images def plot_band ( images , filename = 'neb.png' ): nt = NEBTools ( images ) energies = nt . get_barrier () print ( f 'Barrier height: { energies [ 0 ] : 16.5f } eV' ) print ( f 'E_final - E_initial: { energies [ 1 ] : 16.5f } eV' ) nebplot = nt . plot_band () nebplot . savefig ( filename ) if __name__ == '__main__' : import sys seedname = sys . argv [ 1 ] path = './' tolerant = False if len ( sys . argv ) > 2 : tolerant = bool ( sys . argv [ 2 ]) tsfile = TSFile ( seedname , path = path , tolerant = tolerant ) images = get_images ( tsfile ) plot_band ( images ) # we can use ASE to write out the structure # in whatever format we want print ( 'Image \\t\\t Energy (eV)' ) for i , atoms in enumerate ( images ): print ( f ' { i : 03d } \\t { atoms . get_potential_energy () : 16.5f } eV' ) ## this format includes the energy of the image atoms . write ( f 'image- { i : 03d } .xyz' ) ## We can also use the ASE GUI to ## view the images and analyse the NEB path. ## Select Tools -> NEB Plot # from ase.visualize import view # view(images) If we save this script as analysis.py and run it in the directory containing both the nh3.cell and nh3.ts files like this: python analysis.py nh3 we will get an .xyz file for each structure in the optimised NEB path and the energy of each image. We will also get the barrier estimate and a NEB plot showing the barrier. The ASE GUI can also be used to plot the NEB band (uncomment the last two lines in the above script and Select Tools \u2192 NEB Plot from the GUI). The ASE-generated plot looks like this: The green lines show the tangents at those points; these can be useful indicators of convergence. The barrier we obtained is about 0.23 eV, which compares well with the value of 0.25 eV (24.2 kJ/mol) from Wikipedia . We might also notice the slight difference in energy between the two end-points of the path (about 1 meV). These should be identical, so any difference can be used as a very rough guide for the amount of numerical noise in the geometry optimisations. If equivalent structures (the end-points in this example) were found to have very different energies, you would need to go back and tighten up your convergence criteria or force/energy tolerances in the initial geometry optimisations and re-run the NEB calculation with these tightened parameters. Using our favourite visualisation software (here we used the ASE POV-Ray interface ), we can then look at how the structure evolves along the minimum energy pathway found via the NEB. Zero-point energy corrections In many cases, particularly when lighter atoms are involved, the energy barrier estimates obtained above need to be corrected for quantum-nuclear effects. The simplest way to do this is in the harmonic approximation. You need to estimate the harmonic zero-point energy at the start, transition and final configurations. TODO: replace the section on zero-point energy corrections by a note that highlights that the NEB will provide a Delta E (this is exact), while the transition rates will depend on Delta E_0. TODO: add instructions for harmonic ZPE corrections.","title":"Nudged elastic band"},{"location":"tutorials/NEB/neb_tutorial/#nudged-elastic-band-tutorial","text":"","title":"Nudged elastic band tutorial"},{"location":"tutorials/NEB/neb_tutorial/#overview-and-background","text":"The nudged elastic band (NEB) approach is a widely-used method for finding a minimum energy pathway between two configurations of atoms. You can use the method to estimate the barrier for the system to transition between the two structures. The technique starts with two fixed end points which are fully relaxed (local) minima: the initial and final configurations. It then connects these end points with a series of \"images\" via fictitious springs that \"pull\" the structures taut over one or more intermediate transition states. In this tutorial, we will use the well-known example of an ammonia molecule's pyramidal inversion We will cover: How to set up the initial, final (and intermediate) structures How to actually run the NEB calculation efficiently How to analyse the results Other tips and tricks","title":"Overview and background"},{"location":"tutorials/NEB/neb_tutorial/#files","text":"You can find all the files needed for this tutorial here: neb_tutorial.tar.gz","title":"Files"},{"location":"tutorials/NEB/neb_tutorial/#setting-up-the-structures","text":"","title":"Setting up the structures"},{"location":"tutorials/NEB/neb_tutorial/#setting-up-the-initial-and-final-states","text":"These are the local minima structures you want to find the barrier between. They can be equivalent structures, e.g. differing by a symmetry operation, such reflection through a mirror plane, or they can be configurations with different energies (in which case your forward and reverse barriers will not be the same!). Two crucial conditions must be met before running the NEB calculation : The end point structures must be fully relaxed (geometry optimised) before you start the NEB. Note that both the initial relaxations and the actual NEB calculation must use consistent parameters (e.g. basis set, pseudopotentials, k-points, XC functional etc.). The atoms must be in the correct order. A common mistake is to use a software tool to generate the final state from the initial state and end up with atoms that don't match the initial atom order. Atoms then \"pass through each other\" when CASTEP interpolates between the two structures, causing the calculation to blow up. Always check that the atoms connect up in the way you expect. The initial state is specified in the same way as a normal .cell file, e.g.: %BLOCK positions_frac H 0.500011764912384 0.634846485697942 0.443086003907125 H 0.616593728396204 0.432553816946042 0.442828605918639 H 0.383248448613152 0.432623959245757 0.443068863520867 N 0.500000000000000 0.500000000000000 0.500000000000000 %ENDBLOCK positions_frac The final state is specified using a similar block in the same .cell file but with _product appended to the name of the block, e.g.: %BLOCK positions_frac_product H 0.500154169007758 0.634858887961251 0.556834437330747 H 0.616661280589956 0.432482046338754 0.556941161085851 H 0.383366127862304 0.432719065607707 0.557277918851780 N 0.500000000000000 0.500000000000000 0.500000000000000 %ENDBLOCK positions_frac_product","title":"Setting up the initial and final states"},{"location":"tutorials/NEB/neb_tutorial/#setting-up-the-transition-state-guess","text":"CASTEP will linearly interpolate between the initial and final structures provided to generate the first guess of the minimum energy pathway. This works well in many cases. However, if your minimum energy pathway contains e.g. a rotation of a (group of) atom(s) around a bond or something similar, then the linear path between initial and final configurations may be a bad starting guess/non-physical structure. For example, if your end points correspond to a C2 rotation, then a linearly interpolated intermediate structure would not be a physical one. It's important to visualise or otherwise check all of your structures before running a calculation. Intermediate structures can also be chosen in such a way as to bias your results to one pathway over another. CASTEP allows you to provide one intermediate structure between the initial and final configurations in order to get the NEB on the right track. The intermediate configuration is added using, e.g.: %BLOCK POSITIONS_ABS_INTERMEDIATE ang N 3.500000 3.500000 3.500000 H 3.500000 4.443968 3.500000 H 4.316393 3.027626 3.500000 H 2.683149 3.028701 3.501215 %ENDBLOCK POSITIONS_ABS_INTERMEDIATE","title":"Setting up the transition state guess"},{"location":"tutorials/NEB/neb_tutorial/#how-many-images-do-i-need","text":"It depends... It's usually preferable to start with a small number of images and increase the number if you need to. Starting small can quickly give you a rough sense of the energy landscape and that will determine the actual number of images needed. In addition, if you start with too many images then you might never get close to the converged TS because the optimisation takes too long. If you instead start with a small number and get a reasonable TS structure, you can then use that as your initial intermediate structure in a restarted calculation with more images. Using many (i.e. > 15) will result in slow convergence, but may lead to a more accurate minimum energy pathway for complex barriers. If you do find a particularly complex pathway, however, you might be better off splitting the work up into more than one NEB calculation, each with fewer images. Just remember to always fully relax the end points (even if the end point is a meta-stable local minimum)! Using too few (i.e. < 5) might fail to find the minimum energy pathway if the energy landscape is complex. TODO: add guidance on odd vs even number of images (touching on how the spacing is calculated) and on how many you need for this simple example -- maybe an exercise for the user? You can actually get the same barrier height with just one image in this simple case! Some questions to help answer how many images you need: How complex is the landscape between the initial and final state? For example, if you expect more than one maximum between the end points, you probably need more images than for the single peak example we look at here. Note The number of images is the number of structures between the end points. The total number of structures in the path (i.e. including the end points) is therefore the number of images + 2.","title":"How many images do I need?"},{"location":"tutorials/NEB/neb_tutorial/#constraints","text":"We can often dramatically improve the efficiency of the transition state search by imposing constraints on the atomic positions, although this must be done with care so as not to introduce artifacts. For example, when looking at NEB barriers for adsorbates on a surface slab, we can usefully constrain the bottom slab layers, but probably want the top layer(s) unconstrained. In the ammonia case, we can constrain the N atom position without affecting the physical set up by adding the block: %BLOCK IONIC_CONSTRAINTS 1 N 1 1 0 0 2 N 1 0 1 0 3 N 1 0 0 1 %ENDBLOCK IONIC_CONSTRAINTS to the nh3.cell file. [Isn't there a more compact way now to specify a fixed atom?] You should then see something like: --- Initialising NEB constraints --- Fixed 3 degrees of freedom in the .castep output file.","title":"Constraints"},{"location":"tutorials/NEB/neb_tutorial/#do-i-need-climbing-neb","text":"The climbing NEB method modifies the force on the highest-energy image such that it tries to climb up the barrier. This is very useful to get accurate barrier estimates, but care must be taken when more complex pathways (i.e. with multiple maxima) are found. [Don't get this!] In our example the path is quite straightforward and it makes sense to use the climbing image method. We therefore set: TSSEARCH_NEB_CLIMBING: TRUE in the .param file. TODO: clarify what happens when you set climbing to true. TODO: include advice/explanation about starting with regular NEB and turning on climbing image after a few steps.","title":"Do I need climbing NEB?"},{"location":"tutorials/NEB/neb_tutorial/#running-the-neb","text":"","title":"Running the NEB"},{"location":"tutorials/NEB/neb_tutorial/#parallelisation","text":"Because the NEB calculation essentially involves N independent CASTEP calculations (where N is the number of images), we can make very efficient use of high-performance computers. This is done via \"task farming\", running the calculations for the N images independently. For example, if one CASTEP calculation fits on one node, and you have 7 images, then you could run on a total of 7 nodes by setting the keyword: NUM_FARMS: 7 in the .param file. A good rule of thumb is to aim for NUM_FARMS = number of NEB images. That way each 'farm' is responsible for one NEB image. Since each farm will effectively run a series of single-point calculations on each NEB image they are responsible for, the compute resources of that farm should be appropriately sized for such calculations. Too small and you could get an out-of-memory error, too large and you might end up over-parallelising, leading to reduced overall performance. i.e. you should aim to run on a total of NUM_FARMS times as many cores as you would use for a single-point calculation on one of the structures. This also assumes that your available compute resources can be neatly split into NUM_FARMS . The easy case is when each farm can run on a single node; i.e. NUM_FARMS = number of NEB images = number of nodes. Note that the total number of cores available must be divisible by NUM_FARMS . If you choose NUM_FARMS < number of images, each of the images will run sequentially on one farm as soon as that farm becomes available. If the number of images is not a multiple of NUM_FARMS , some farms will end up being responsible for more images than others, leading poor overall efficiency. If you choose NUM_FARMS > number of images, then some farms will be left with nothing to do, resulting in poor overall efficiency. Setting NUM_FARMS = 1 is equivalent to not setting NUM_FARMS . You will notice that if you enable task farming, the seedname.castep output file will look relatively empty, as most output is split into the different task farm .castep files. The first indexed one contains the most important information (for example, the \"Max NEB force\") and will be called e.g. seedname_farm001.castep .","title":"Parallelisation"},{"location":"tutorials/NEB/neb_tutorial/#is-the-calculation-converging","text":"You can monitor the convergence by searching for \"Max NEB force\" within the .castep output file. Common convergence issues include: Not having consistent order in the initial and final structures, i.e. non-physical initial path Too many (or too few) images [As above - not clear what this means, so looks odd.] Initial or final state (endpoints) not being fully relaxed structures","title":"Is the calculation converging?"},{"location":"tutorials/NEB/neb_tutorial/#restarting-continuing","text":"Sometimes the calculation will run out of time/number of iterations before the NEB calculation is finished. You will probably see a \"Failed to converge\" message in the .castep output in that case; always read through your output files! [Not obvious in .ts file? Shouldn't need to positively check for unconverged results.] If you re-run the calculation without changing anything, it will simply start from the beginning again -- probably not what you want! In order restart the NEB from the last checkpointed state, you need to explicitly set the name of the .check file you want to continue from in your .param file. In our example that would be: continuation: nh3.check In the .castep output you would then see: Coordinates of NEB images loaded from checkpoint file . Warning Unlike other CASTEP tasks, setting continuation: default does not seem to work for continuing/restarting NEB calculations! You must explicitly set the name of checkpoint file.","title":"Restarting / Continuing"},{"location":"tutorials/NEB/neb_tutorial/#analysis","text":"Once you have a converged NEB, the provided Python utility readTS can be used to parse and analyse the NEB. To add the readTS module to your PYTHONPATH, you can find a setup.py script in the castep/Utilities/readts directory of your CASTEP source directory. Running python setup.py should install the module to your path. You can also manually add it by inserting the following line into your ~/.bashrc or equivalent and restarting the terminal: export PYTHONPATH = \"/path/to/castep/Utilities/readts: $PYTHONPATH \" (changing the /path/to/castep/ bit to wherever CASTEP is on your machine). You can then extract the NEB path using something like this python code: [This looks sufficiently general that you could supply the analysis.py script?] ## get this by adding castep/Utilities/readts to your PYTHONPATH from readts import TSFile from ase.neb import NEBTools def get_images ( tsfile ): ''' Function to extract the final NEB images from a tsfile object Args: tsfile (TSFile): tsfile object Returns: images (list): list of ASE atoms objects ''' diam_tst = tsfile . blocks [ 'TST' ] diam_i = tsfile . blocks [ 'REA' ][ 1 ][ 0 ] diam_f = tsfile . blocks [ 'PRO' ][ 1 ][ 0 ] nbeads = len ( diam_tst [ 1 ]) max_idx = diam_tst . last_index images = [ diam_i . atoms ] images += [ diam_tst [ max_idx ][ i ] . atoms for i in range ( 0 , nbeads , 1 )] images . append ( diam_f . atoms ) return images def plot_band ( images , filename = 'neb.png' ): nt = NEBTools ( images ) energies = nt . get_barrier () print ( f 'Barrier height: { energies [ 0 ] : 16.5f } eV' ) print ( f 'E_final - E_initial: { energies [ 1 ] : 16.5f } eV' ) nebplot = nt . plot_band () nebplot . savefig ( filename ) if __name__ == '__main__' : import sys seedname = sys . argv [ 1 ] path = './' tolerant = False if len ( sys . argv ) > 2 : tolerant = bool ( sys . argv [ 2 ]) tsfile = TSFile ( seedname , path = path , tolerant = tolerant ) images = get_images ( tsfile ) plot_band ( images ) # we can use ASE to write out the structure # in whatever format we want print ( 'Image \\t\\t Energy (eV)' ) for i , atoms in enumerate ( images ): print ( f ' { i : 03d } \\t { atoms . get_potential_energy () : 16.5f } eV' ) ## this format includes the energy of the image atoms . write ( f 'image- { i : 03d } .xyz' ) ## We can also use the ASE GUI to ## view the images and analyse the NEB path. ## Select Tools -> NEB Plot # from ase.visualize import view # view(images) If we save this script as analysis.py and run it in the directory containing both the nh3.cell and nh3.ts files like this: python analysis.py nh3 we will get an .xyz file for each structure in the optimised NEB path and the energy of each image. We will also get the barrier estimate and a NEB plot showing the barrier. The ASE GUI can also be used to plot the NEB band (uncomment the last two lines in the above script and Select Tools \u2192 NEB Plot from the GUI). The ASE-generated plot looks like this: The green lines show the tangents at those points; these can be useful indicators of convergence. The barrier we obtained is about 0.23 eV, which compares well with the value of 0.25 eV (24.2 kJ/mol) from Wikipedia . We might also notice the slight difference in energy between the two end-points of the path (about 1 meV). These should be identical, so any difference can be used as a very rough guide for the amount of numerical noise in the geometry optimisations. If equivalent structures (the end-points in this example) were found to have very different energies, you would need to go back and tighten up your convergence criteria or force/energy tolerances in the initial geometry optimisations and re-run the NEB calculation with these tightened parameters. Using our favourite visualisation software (here we used the ASE POV-Ray interface ), we can then look at how the structure evolves along the minimum energy pathway found via the NEB.","title":"Analysis"},{"location":"tutorials/NEB/neb_tutorial/#zero-point-energy-corrections","text":"In many cases, particularly when lighter atoms are involved, the energy barrier estimates obtained above need to be corrected for quantum-nuclear effects. The simplest way to do this is in the harmonic approximation. You need to estimate the harmonic zero-point energy at the start, transition and final configurations. TODO: replace the section on zero-point energy corrections by a note that highlights that the NEB will provide a Delta E (this is exact), while the transition rates will depend on Delta E_0. TODO: add instructions for harmonic ZPE corrections.","title":"Zero-point energy corrections"},{"location":"tutorials/NMR/NMR_shielding/","text":"We now start running castep calculations by looking at two small systems, and examining the issue of \"convergence\". Example 1 - Ethanol CH 3 CH 2 OH The discovery that one could actually see chemical shifts in hydrogen spectra was made in 1951 at Stanford University by Packard, Arnold, Dharmatti (shown below). We will try to reproduce this result. Fig1. Proton spectrum of ethanol Files ethanol.cell ethanol.param OBJECTIVES: Examine the convergence of the chemical shieldings with planewave cutoff Compare to experiment. INSTRUCTIONS: Look at the cell and param file. Note that the only special keyword is task = magres. Run castep. Look at the output file. At the end the isotropic chemical shielding, anisotropy, and asymmetry are reported (here we are only interested in the isotropic value.) This information, plus the full tensors is also given in the file ethanol.magres You might wish to transfer the *.magres file back to your desktop to visualise with MagresView Examine the effect of increasing the cutoff energy (say 20-50 Ryd in steps of 10 Ryd). It always helps to plot a graph of the convergence (eg with gnuplot or xmgrace on the cluster - or with excel on the pc) Find the \"converged\" hydrogen (or proton in NMR language) shieldings. We will compare them to experiment. The three methyl (CH3) protons undergo fast exchange; they \"rotate\" faster than the nuclear magnetic moment processes. The magnetic moment will therefore \"see\" an average chemical shielding. The same is true of the CH2 protons. Average the CH 3 and CH 2 chemical shieldings. This will give you 3 unique chemical shieldings. We now need to convert the chemical shieldings \u03c3 iso to chemical shifts \u03b4 iso on the experimental scale. We use the relation: \\delta_{iso}=\\sigma_{ref}-\\sigma_{iso} \\delta_{iso}=\\sigma_{ref}-\\sigma_{iso} , A suitable \u03c3 ref for 1H is 30.97ppm. %block rframe width=200px padding=10px%\\ %width=180px%Attach:nmr_tut2.png Fig1. Proton spectrum of liquid ethanol.%% Fig 2 shows a modern high-resolution 1H spectrum for liquid ethanol. Note that the peaks are split due to J-coupling - the interaction of the 1H magnetic moments - but let's ignore that for now. The three peaks are roughly at 1.2ppm, 3.7ppm and 5ppm. You should find that your computed values agree for two sites. Do you know why the other site has such a large disagreement with experiment? Example 2 - Diamond FILES: *diamond.cell *diamond.param OBJECTIVES: * Examine the convergence of the chemical shielding as the sampling of the electronic Brillouin zone (BZ) is increased. INSTRUCTIONS: * Look at the files diamond.cell and diamond.param * We have specified the kpoints in the cell file using the keyword kpoints_mp_grid 4 4 4 * Run CASTEP for a range of kpoint meshes (say 2,4,6,8,10) * Examine (plot?) the convergence of the chemical shielding. The computational cost scales linearly with the number of kpoints (ie the number of points in the irreducible Brillouin Zone). For a large unit cell (ie a small BZ) it may be possible to get converged results using a single k-point. But which kpoint should we choose? For diamond we will look at 3 different k-points (0,0,0), (\u00bd,\u00bd,\u00bd) (\u00bc,\u00bc,\u00bc). Specify the kpoint in the cell file using %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST Which gives a result closest to the converged answer? (as the diamond unit cell is rather small the 1 kpoint answer is not too close to converged. However, the observation holds true for all orthorhombic cells) PART 3 We now look at some more realistic examples. Oxygen-17 Oxygen is a component of many geological materials. Oxygen is also important element in organic and biological molecules since it is often intimately involved in hydrogen bonding. Solid State 17 O NMR should be a uniquely valuable probe as the chemical shift range of 17 O covers almost 1000 ppm in organic molecules. Furthermore 17 O has spin I = 5/2 and hence a net quadrupole moment. As a consequence of this the solid state NMR spectrum is strongly affected by the electric field gradient at the nucleus. Because the isotopic abundance of 17 O is very low (0.037%) and the NMR linewidths due to the electric field gradient relatively large, only limited Solid State NMR data is available. This is particularly true for organic materials. First principles calculations of 17 O NMR parameters have played a vital role in assigning experimental spectra, and developing empirical rules between NMR parameters and local atomic structure. Example 3 - Alanine, a simple amino acid FILES: *alanine.cell *alanine.param *alanine.pdb OBJECTIVES: Compute the chemical shift and Electric field gradient for alanine Assign the 17 NMR spectrum %block rframe width=200px padding=10px%\\ %width=180px%Attach:nmr_tut3.png Fig3. Solid-State O17 NMR spectrum of L-alanine. (b) is from MAS (magicangle- spinning) \u00a9 is from DOR (double-orientation rotation)%% INSTRUCTIONS: *Look at the cell and param files. The geometry for alanine was obtained by neutron diffraction and was downloaded from the Cambridge Crystallographic database. View the original pdb file note the hydrogen bonding Run the example - the calculation is not fully converged. However, the relative shift between the two sites is fairly converged. The experimental 17 O NMR spectrum shows two peaks (Fig 3 (b)) - they are very broad due to the quadrupolar coupling, and overlap. The experimental parameters are given in Table 1. Assign the two resonances A and B. Do all three computed parameters support this assignment? ||border=1 width=50% ||\u03b4(A)-\u03b4 (B) (ppm)|| 23.5|| ||C Q (A) (MHz)|| 7.86|| ||\u03b7 Q (A)|| 0.28|| ||C Q (A) (MHz)|| 6.53|| ||\u03b7 Q (A)|| 0.70|| Table 1: Experimental 17 O NMR parameters for alanine. The two resonances are labeled A and B. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q . Example 4 - Silicates Quartz and Cristoballite FILES: *quartz.cell *quartz.param *crist.cell *crist.param OBJECTIVES: * Compute the chemical shift and Electric field gradient for two silicates. * Assign the 17 O NMR spectrum INSTRUCTIONS: * The 17 O parameters for two silicates are reported in Table 2. From the values you compute can you tell which one is quartz? (a suitable \u03c3 ref is 263ppm) ||border=1 width=50% || || \u03b4 (ppm) || C Q (MHz) || \u03b7 Q || ||Material A|| 37.2 || 5.21 || 0.13 || ||Material B|| 40.8 || 5.19 || 0.19 || Table 2: Experimental 17O NMR parameters for two silicates. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q .","title":"NMR shielding"},{"location":"tutorials/NMR/NMR_shielding/#example-1-ethanol-ch3ch2oh","text":"The discovery that one could actually see chemical shifts in hydrogen spectra was made in 1951 at Stanford University by Packard, Arnold, Dharmatti (shown below). We will try to reproduce this result. Fig1. Proton spectrum of ethanol Files ethanol.cell ethanol.param OBJECTIVES: Examine the convergence of the chemical shieldings with planewave cutoff Compare to experiment. INSTRUCTIONS: Look at the cell and param file. Note that the only special keyword is task = magres. Run castep. Look at the output file. At the end the isotropic chemical shielding, anisotropy, and asymmetry are reported (here we are only interested in the isotropic value.) This information, plus the full tensors is also given in the file ethanol.magres You might wish to transfer the *.magres file back to your desktop to visualise with MagresView Examine the effect of increasing the cutoff energy (say 20-50 Ryd in steps of 10 Ryd). It always helps to plot a graph of the convergence (eg with gnuplot or xmgrace on the cluster - or with excel on the pc) Find the \"converged\" hydrogen (or proton in NMR language) shieldings. We will compare them to experiment. The three methyl (CH3) protons undergo fast exchange; they \"rotate\" faster than the nuclear magnetic moment processes. The magnetic moment will therefore \"see\" an average chemical shielding. The same is true of the CH2 protons. Average the CH 3 and CH 2 chemical shieldings. This will give you 3 unique chemical shieldings. We now need to convert the chemical shieldings \u03c3 iso to chemical shifts \u03b4 iso on the experimental scale. We use the relation: \\delta_{iso}=\\sigma_{ref}-\\sigma_{iso} \\delta_{iso}=\\sigma_{ref}-\\sigma_{iso} , A suitable \u03c3 ref for 1H is 30.97ppm. %block rframe width=200px padding=10px%\\ %width=180px%Attach:nmr_tut2.png Fig1. Proton spectrum of liquid ethanol.%% Fig 2 shows a modern high-resolution 1H spectrum for liquid ethanol. Note that the peaks are split due to J-coupling - the interaction of the 1H magnetic moments - but let's ignore that for now. The three peaks are roughly at 1.2ppm, 3.7ppm and 5ppm. You should find that your computed values agree for two sites. Do you know why the other site has such a large disagreement with experiment?","title":"Example 1 - Ethanol CH3CH2OH"},{"location":"tutorials/NMR/NMR_shielding/#example-2-diamond","text":"FILES: *diamond.cell *diamond.param OBJECTIVES: * Examine the convergence of the chemical shielding as the sampling of the electronic Brillouin zone (BZ) is increased. INSTRUCTIONS: * Look at the files diamond.cell and diamond.param * We have specified the kpoints in the cell file using the keyword kpoints_mp_grid 4 4 4 * Run CASTEP for a range of kpoint meshes (say 2,4,6,8,10) * Examine (plot?) the convergence of the chemical shielding. The computational cost scales linearly with the number of kpoints (ie the number of points in the irreducible Brillouin Zone). For a large unit cell (ie a small BZ) it may be possible to get converged results using a single k-point. But which kpoint should we choose? For diamond we will look at 3 different k-points (0,0,0), (\u00bd,\u00bd,\u00bd) (\u00bc,\u00bc,\u00bc). Specify the kpoint in the cell file using %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST Which gives a result closest to the converged answer? (as the diamond unit cell is rather small the 1 kpoint answer is not too close to converged. However, the observation holds true for all orthorhombic cells)","title":"Example 2 - Diamond"},{"location":"tutorials/NMR/NMR_shielding/#part-3","text":"We now look at some more realistic examples.","title":"PART 3"},{"location":"tutorials/NMR/NMR_shielding/#oxygen-17","text":"Oxygen is a component of many geological materials. Oxygen is also important element in organic and biological molecules since it is often intimately involved in hydrogen bonding. Solid State 17 O NMR should be a uniquely valuable probe as the chemical shift range of 17 O covers almost 1000 ppm in organic molecules. Furthermore 17 O has spin I = 5/2 and hence a net quadrupole moment. As a consequence of this the solid state NMR spectrum is strongly affected by the electric field gradient at the nucleus. Because the isotopic abundance of 17 O is very low (0.037%) and the NMR linewidths due to the electric field gradient relatively large, only limited Solid State NMR data is available. This is particularly true for organic materials. First principles calculations of 17 O NMR parameters have played a vital role in assigning experimental spectra, and developing empirical rules between NMR parameters and local atomic structure.","title":"Oxygen-17"},{"location":"tutorials/NMR/NMR_shielding/#example-3-alanine-a-simple-amino-acid","text":"FILES: *alanine.cell *alanine.param *alanine.pdb OBJECTIVES: Compute the chemical shift and Electric field gradient for alanine Assign the 17 NMR spectrum %block rframe width=200px padding=10px%\\ %width=180px%Attach:nmr_tut3.png Fig3. Solid-State O17 NMR spectrum of L-alanine. (b) is from MAS (magicangle- spinning) \u00a9 is from DOR (double-orientation rotation)%% INSTRUCTIONS: *Look at the cell and param files. The geometry for alanine was obtained by neutron diffraction and was downloaded from the Cambridge Crystallographic database. View the original pdb file note the hydrogen bonding Run the example - the calculation is not fully converged. However, the relative shift between the two sites is fairly converged. The experimental 17 O NMR spectrum shows two peaks (Fig 3 (b)) - they are very broad due to the quadrupolar coupling, and overlap. The experimental parameters are given in Table 1. Assign the two resonances A and B. Do all three computed parameters support this assignment? ||border=1 width=50% ||\u03b4(A)-\u03b4 (B) (ppm)|| 23.5|| ||C Q (A) (MHz)|| 7.86|| ||\u03b7 Q (A)|| 0.28|| ||C Q (A) (MHz)|| 6.53|| ||\u03b7 Q (A)|| 0.70|| Table 1: Experimental 17 O NMR parameters for alanine. The two resonances are labeled A and B. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q .","title":"Example 3 - Alanine, a simple amino acid"},{"location":"tutorials/NMR/NMR_shielding/#example-4-silicates-quartz-and-cristoballite","text":"FILES: *quartz.cell *quartz.param *crist.cell *crist.param OBJECTIVES: * Compute the chemical shift and Electric field gradient for two silicates. * Assign the 17 O NMR spectrum INSTRUCTIONS: * The 17 O parameters for two silicates are reported in Table 2. From the values you compute can you tell which one is quartz? (a suitable \u03c3 ref is 263ppm) ||border=1 width=50% || || \u03b4 (ppm) || C Q (MHz) || \u03b7 Q || ||Material A|| 37.2 || 5.21 || 0.13 || ||Material B|| 40.8 || 5.19 || 0.19 || Table 2: Experimental 17O NMR parameters for two silicates. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q .","title":"Example 4 - Silicates Quartz and Cristoballite"},{"location":"tutorials/Tools/elastic_constants/","text":"Andrew Walker (building on work by Dan Wilson) provides some python scripts for calculating elastic constants using CASTEP, available from https://github.com/andreww/elastic-constants . The tool comes in two parts - first is generate_strain.py, this takes the results of a successful variable cell geometry optimisation and creates a set of input files to be run through CASTEP. The second part is elastics.py, which takes the CASTEP results and constructs the matrix of elastic constants, Young's modulus, Poisson's ratios and bulk and shear moduli. Usage information for each script can be obtained by using the --help option. For this exercise we will use rutile - titanium dioxide. Below are example .cell and .param files to start from. It is assumed that the scripts generate_strain.py and elastics.py are in your PATH and that python is installed. #TiO2.cell %BLOCK lattice_cart 4.594 0.000 0.000 0.000 4.594 0.000 0.000 0.000 2.959 %ENDBLOCK lattice_cart %BLOCK positions_frac Ti 0.000 0.000 0.000 Ti 0.500 0.500 0.500 O 0.305 0.305 0.000 O -0.305 -0.305 0.000 O 0.805 0.195 0.500 O -0.805 -0.195 0.500 %ENDBLOCK positions_frac symmetry_generate kpoint_mp_grid 3 3 3 #TiO2.param task : geometryoptimisation cutoff_energy : 700 eV xc_functional : PBE max_scf_cycles : 100 calculate_stress : true opt_strategy : speed num_dump_cycles : 0 Task 1: Perform a variable cell geometry optimisation and make sure to include calculate_stress : true in your param file. Test the kinetic energy cut-off and k-point grid such that the stress is converged to within the default geom_stress_tol value. (Hint: Use CASTEP's built-in help utility to find the default.) Task 2: Use the generate_strain.py script to generate a set of .cell files deformed according to the appropriate strain pattern. The command generate_strain.py TiO2 should be sufficient. You should now have twelve (in this case) sets of input files - individual .cell files and corresponding .param , symbolically linked to the original TiO2.param file. Notice that the new .cell files all have the FIX_ALL_CELL true option set. Task 3: Run CASTEP on each of the 12 sets of input files. Note that the cell distortions can break the symmetry of the crystal, hence changing the number of k-points in the symmetry reduced sample. The -dryrun option of CASTEP can be used to do a quick check for how many k-points are required. This can help when selecting how many cores to run the calculation on if you are running CASTEP in parallel. Task 4: Run the elastics.py script to obtain the elastic constants. The command elastics.py TiO2 will print the results to the terminal. The --latex option generates a LaTeX formatted summary of the results and the --graphics option produces a graphical representation of the stress-strain fits in a .png file. Task 5: Investigate how the results and their errors change with smaller values of the elec_energy_tol parameter. Also investigate the effect of changing the --strain option to generate_strain.py . Move any old *cij*.castep files to another directory - the elastics.py script only checks the first set of data in a concatenated .castep file.","title":"Elastic Constants"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/","text":"Interlayer binding energy of graphite Here we'll explore the van der Waals interaction that holds sheets of graphene together to form graphite. We will see how a standard semi-local density functional approximation fails to predict the correct interlayer binding energy in graphite and how we can do better using semi-empirical dispersion corrections in CASTEP. For this tutorial we will use the CASTEP-ASE interface to setup and run many short calculations and analyse the results, though you can of course adapt the content here to use a scripting language of your choice. I have broken up the parts of the script to add clarification in places, but you can download the jupyter notebook with all the cells here . We start by importing several python libraries. For more information on using the atomic simulation environment (ASE) with CASTEP, see the documentation here . # ASE version 3.22.1 from ase.io import read , write from ase.calculators.castep import Castep from ase.io.castep import read_seed from ase.visualize import view # pandas version 1.3.4 import pandas as pd # castep.mpi on path already, version 21.11 castep_cmd = 'mpirun -n 4 castep.mpi' # plotting from matplotlib import pyplot as plt % matplotlib inline # Python version: 3.9.5 For this tutorial I will use CASTEP version 21.11. See here for a list of the different dispersion correction schemes and which version of CASTEP they are available from. Separation of layers: setup and run the calculations The script below loops over several different dispersion corrections schemes and, for each one, calculates the total energy of a 4-atom graphite cell at several different values of the c lattice constant. This effectively increases the interlayer spacing between the sheets of graphene. By separating them far enough apart, we can estimate the interlayer binding energy predicte by each method. The script took about 10 minutes to run using 4 cores on a relatively powerful laptop. You can decrease the k-point sampling or basis set precision, or loop over fewer methods or c parameters in order to speed things up. # run in this directorsy directory = 'separate-layers-tutorial/' # k-point grid # -- try coarser grid if this is too slow, # but higher if you want more reliable results! kpts = [ 13 , 13 , 5 ] # xc functional to use xc = 'PBE' # range of unit c parameters in Angstroms (interlayer spacings are half these!) crange = [ 4 , 5 , 6 , 6.25 , 6.5 , 6.75 , 7 , 7.25 , 7.5 , 8.5 , 10 , 14 , 16 ] #SEDC correction schemes to try: schemes = [ '' , 'G06' , 'D3' , 'D3-BJ' , 'TS' , 'MBD' , 'XDM' ] # pandas dataframe to store the results df = pd . DataFrame ({ 'crange' : crange }) # loop over the different correction schemes for sedc_scheme in schemes : print ( ' \\n ' , 50 * '=' ) print ( f ' { xc } + { sedc_scheme } \\n ' ) # list to temporarily hold the total energy for each calculation energies = [] # loop over c parameters: for c in crange : label = f ' { xc } - { sedc_scheme } - { c : 3.2f } ' try : graphite = read_seed ( directory + label ) except : # if the calculation doesn't already exist, we set it up and # run it # read in cif file (taken from here: https://materialsproject.org/materials/mp-48 ) graphite = read ( 'C_mp-48_primitive.cif' ) # we could make a supercell to get more accurate results for TS, MBD and XDM schemes. # graphite = graphite * (3,3,1) # scale c parameter to new value cellpar = graphite . cell . cellpar () cellpar [ 2 ] = c graphite . set_cell ( cellpar , scale_atoms = True ) # set up castep calculator calc = Castep ( xc = xc , kpts = kpts , label = label , castep_command = castep_cmd , basis_precision = 'precise' , # switch to something cheaper (e.g. FINE) to speed things up for this example.. directory = directory , write_checkpoint = 'None' , # don't need the checkpoint files now write_cst_esp = False , # don't need the electrostatic potential file now write_bands = False , # don't need the bands file now _rename_existing_dir = False , # allows us to write all these calculations to the same directory... symmetry_generate = True , # use symmetry to speed up the calculation snap_to_symmetry = True , # enforce symmetry ) # Switch on the SEDC flags if sedc_scheme != '' : calc . param . sedc_apply = True calc . param . sedc_scheme = sedc_scheme # For the XDM scheme we need to set this manually # otherwise the calculation crashes... if sedc_scheme == 'XDM' : calc . param . SEDC_SC_XDM = 1.0 graphite . set_calculator ( calc ) e = graphite . get_potential_energy () energies . append ( e ) print ( f ' { c : 8.3f } A \\t { e : 12.8f } eV' ) # save the energy wrt to furthest energy: energies = [ e - energies [ - 1 ] for e in energies ] df [ f ' { xc } - { sedc_scheme } ' ] = energies # Save to a .csv file: df . to_csv ( 'graphite_layer_separation.csv' ) The .param files generated look something like this: WRITE_CST_ESP: FALSE WRITE_BANDS: FALSE WRITE_CHECKPOINT: None XC_FUNCTIONAL: PBE SEDC_APPLY: TRUE SEDC_SCHEME: D3 # or TS or D3-BJ etc. BASIS_PRECISION: precise The task defaults to SINGLEPOINT (which is what we want in this case). The .cell files simply have the crystal structure in which the cell is scaled in the c direction. Read in and analyse the results We can now read in and analyse the results from the previous step. Reading the data into a pandas dataframe object is convenient. df = pd . read_csv ( './graphite_layer_separation.csv' ) # scale by 1000 / 4 to get the energies per atom and in units of meV dfdiff = ( df . iloc [:, 1 :]) * 1000 / 4 # energy per atom in meV # the c parmeter is 2x the interlayer spacing, d dfdiff [ 'c/2' ] = df [ 'crange' ] / 2 styles = [ f ' { m } -' for m in [ \"o\" , \"v\" , \"^\" , \"s\" , \"+\" , \"x\" , \"D\" ]] # compared to this refence (and many others!) https://doi.org/10.1039/C3RA47187J ax = dfdiff . plot ( x = 'c/2' , y = [ 'PBE-' , 'PBE-G06' , 'PBE-D3' , 'PBE-D3-BJ' , 'PBE-TS' , 'PBE-MBD' , 'PBE-XDM' ], ylabel = 'energy/atom (meV)' , ylim = ( - 100 , 80 ), xlabel = r 'interlayer spacing d ( = c/2) (${\\AA}$)' , figsize = ( 16 , 10 ), style = styles , ) ax . axhline ( 0 , color = '0.3' ) ax . axvline ( 3.355 , ls = '--' , color = '0.4' ) # Experimental binding energies reported shown in the figure are 31 \u00b1 2, 43, 52 \u00b1 5 and 35 (+15 to \u201310) meV per atom ax . axhspan ( ymin =- 57 , ymax =- 25 , color = '0.8' , alpha = 0.5 ) ax . set_title ( 'graphite interlayer binding energy' ) plt . savefig ( 'graphite-interlayer-binding-castep-dispersions.png' ) which produces the following figure: where the dashed vertical line is the experimental interlayer spacing and the shaded grey region is the range of experimentally obtained interlayer binding energies. Please note that these are not fully converged calculations and so do not represent the actual performance of these methods but is simply a guide for how to use them with CASTEP. We can see that the plain PBE functional severely underestimates the binding energy of graphite and that many of the dispersion-corrected results are in much better agreement. The TS scheme strongly overbinds graphite, but has been found to be accurate for other types of systems. Testing such methods carefully is always required when you encounter a new system. Further suggestions CASTEP writes out a warning for the TS, MBD and XDM schemes about the unit cell being too small for accurate corrections. Try repeat the above calculations for these three methods using a larger supercell to see what the effect is and what sized supercell you would need to converge the dispersion correction. For the D3 and D3-BJ methods, try to switch on the three-body interaction term by setting: %BLOCK devel_code d3_threebody TRUE %ENDBLOCK devel_code in the .param file. What effect does this have on the interlayer binding energy in graphite? (You may also want to set IPRINT = 2 to see more information about the dispersion correction parameters.) Compare to other XC functionals with and without the dispersion corrections (though note that of the corrections are only parameterised for a few functionals .)","title":"Dispersion corrections"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#interlayer-binding-energy-of-graphite","text":"Here we'll explore the van der Waals interaction that holds sheets of graphene together to form graphite. We will see how a standard semi-local density functional approximation fails to predict the correct interlayer binding energy in graphite and how we can do better using semi-empirical dispersion corrections in CASTEP. For this tutorial we will use the CASTEP-ASE interface to setup and run many short calculations and analyse the results, though you can of course adapt the content here to use a scripting language of your choice. I have broken up the parts of the script to add clarification in places, but you can download the jupyter notebook with all the cells here . We start by importing several python libraries. For more information on using the atomic simulation environment (ASE) with CASTEP, see the documentation here . # ASE version 3.22.1 from ase.io import read , write from ase.calculators.castep import Castep from ase.io.castep import read_seed from ase.visualize import view # pandas version 1.3.4 import pandas as pd # castep.mpi on path already, version 21.11 castep_cmd = 'mpirun -n 4 castep.mpi' # plotting from matplotlib import pyplot as plt % matplotlib inline # Python version: 3.9.5 For this tutorial I will use CASTEP version 21.11. See here for a list of the different dispersion correction schemes and which version of CASTEP they are available from.","title":"Interlayer binding energy of graphite"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#separation-of-layers-setup-and-run-the-calculations","text":"The script below loops over several different dispersion corrections schemes and, for each one, calculates the total energy of a 4-atom graphite cell at several different values of the c lattice constant. This effectively increases the interlayer spacing between the sheets of graphene. By separating them far enough apart, we can estimate the interlayer binding energy predicte by each method. The script took about 10 minutes to run using 4 cores on a relatively powerful laptop. You can decrease the k-point sampling or basis set precision, or loop over fewer methods or c parameters in order to speed things up. # run in this directorsy directory = 'separate-layers-tutorial/' # k-point grid # -- try coarser grid if this is too slow, # but higher if you want more reliable results! kpts = [ 13 , 13 , 5 ] # xc functional to use xc = 'PBE' # range of unit c parameters in Angstroms (interlayer spacings are half these!) crange = [ 4 , 5 , 6 , 6.25 , 6.5 , 6.75 , 7 , 7.25 , 7.5 , 8.5 , 10 , 14 , 16 ] #SEDC correction schemes to try: schemes = [ '' , 'G06' , 'D3' , 'D3-BJ' , 'TS' , 'MBD' , 'XDM' ] # pandas dataframe to store the results df = pd . DataFrame ({ 'crange' : crange }) # loop over the different correction schemes for sedc_scheme in schemes : print ( ' \\n ' , 50 * '=' ) print ( f ' { xc } + { sedc_scheme } \\n ' ) # list to temporarily hold the total energy for each calculation energies = [] # loop over c parameters: for c in crange : label = f ' { xc } - { sedc_scheme } - { c : 3.2f } ' try : graphite = read_seed ( directory + label ) except : # if the calculation doesn't already exist, we set it up and # run it # read in cif file (taken from here: https://materialsproject.org/materials/mp-48 ) graphite = read ( 'C_mp-48_primitive.cif' ) # we could make a supercell to get more accurate results for TS, MBD and XDM schemes. # graphite = graphite * (3,3,1) # scale c parameter to new value cellpar = graphite . cell . cellpar () cellpar [ 2 ] = c graphite . set_cell ( cellpar , scale_atoms = True ) # set up castep calculator calc = Castep ( xc = xc , kpts = kpts , label = label , castep_command = castep_cmd , basis_precision = 'precise' , # switch to something cheaper (e.g. FINE) to speed things up for this example.. directory = directory , write_checkpoint = 'None' , # don't need the checkpoint files now write_cst_esp = False , # don't need the electrostatic potential file now write_bands = False , # don't need the bands file now _rename_existing_dir = False , # allows us to write all these calculations to the same directory... symmetry_generate = True , # use symmetry to speed up the calculation snap_to_symmetry = True , # enforce symmetry ) # Switch on the SEDC flags if sedc_scheme != '' : calc . param . sedc_apply = True calc . param . sedc_scheme = sedc_scheme # For the XDM scheme we need to set this manually # otherwise the calculation crashes... if sedc_scheme == 'XDM' : calc . param . SEDC_SC_XDM = 1.0 graphite . set_calculator ( calc ) e = graphite . get_potential_energy () energies . append ( e ) print ( f ' { c : 8.3f } A \\t { e : 12.8f } eV' ) # save the energy wrt to furthest energy: energies = [ e - energies [ - 1 ] for e in energies ] df [ f ' { xc } - { sedc_scheme } ' ] = energies # Save to a .csv file: df . to_csv ( 'graphite_layer_separation.csv' ) The .param files generated look something like this: WRITE_CST_ESP: FALSE WRITE_BANDS: FALSE WRITE_CHECKPOINT: None XC_FUNCTIONAL: PBE SEDC_APPLY: TRUE SEDC_SCHEME: D3 # or TS or D3-BJ etc. BASIS_PRECISION: precise The task defaults to SINGLEPOINT (which is what we want in this case). The .cell files simply have the crystal structure in which the cell is scaled in the c direction.","title":"Separation of layers: setup and run the calculations"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#read-in-and-analyse-the-results","text":"We can now read in and analyse the results from the previous step. Reading the data into a pandas dataframe object is convenient. df = pd . read_csv ( './graphite_layer_separation.csv' ) # scale by 1000 / 4 to get the energies per atom and in units of meV dfdiff = ( df . iloc [:, 1 :]) * 1000 / 4 # energy per atom in meV # the c parmeter is 2x the interlayer spacing, d dfdiff [ 'c/2' ] = df [ 'crange' ] / 2 styles = [ f ' { m } -' for m in [ \"o\" , \"v\" , \"^\" , \"s\" , \"+\" , \"x\" , \"D\" ]] # compared to this refence (and many others!) https://doi.org/10.1039/C3RA47187J ax = dfdiff . plot ( x = 'c/2' , y = [ 'PBE-' , 'PBE-G06' , 'PBE-D3' , 'PBE-D3-BJ' , 'PBE-TS' , 'PBE-MBD' , 'PBE-XDM' ], ylabel = 'energy/atom (meV)' , ylim = ( - 100 , 80 ), xlabel = r 'interlayer spacing d ( = c/2) (${\\AA}$)' , figsize = ( 16 , 10 ), style = styles , ) ax . axhline ( 0 , color = '0.3' ) ax . axvline ( 3.355 , ls = '--' , color = '0.4' ) # Experimental binding energies reported shown in the figure are 31 \u00b1 2, 43, 52 \u00b1 5 and 35 (+15 to \u201310) meV per atom ax . axhspan ( ymin =- 57 , ymax =- 25 , color = '0.8' , alpha = 0.5 ) ax . set_title ( 'graphite interlayer binding energy' ) plt . savefig ( 'graphite-interlayer-binding-castep-dispersions.png' ) which produces the following figure: where the dashed vertical line is the experimental interlayer spacing and the shaded grey region is the range of experimentally obtained interlayer binding energies. Please note that these are not fully converged calculations and so do not represent the actual performance of these methods but is simply a guide for how to use them with CASTEP. We can see that the plain PBE functional severely underestimates the binding energy of graphite and that many of the dispersion-corrected results are in much better agreement. The TS scheme strongly overbinds graphite, but has been found to be accurate for other types of systems. Testing such methods carefully is always required when you encounter a new system.","title":"Read in and analyse the results"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#further-suggestions","text":"CASTEP writes out a warning for the TS, MBD and XDM schemes about the unit cell being too small for accurate corrections. Try repeat the above calculations for these three methods using a larger supercell to see what the effect is and what sized supercell you would need to converge the dispersion correction. For the D3 and D3-BJ methods, try to switch on the three-body interaction term by setting: %BLOCK devel_code d3_threebody TRUE %ENDBLOCK devel_code in the .param file. What effect does this have on the interlayer binding energy in graphite? (You may also want to set IPRINT = 2 to see more information about the dispersion correction parameters.) Compare to other XC functionals with and without the dispersion corrections (though note that of the corrections are only parameterised for a few functionals .)","title":"Further suggestions"}]}