{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CASTEP Documentation This is the CASTEP community documentation and tutorial site. For an overview of CASTEP, and to obtain a licence please see the castep website For the Dassault Syst\u00e8mes BIOVIA (Materials Studio) documentation for CASTEP see HTML documentation and a downloadable pdf user guide Contributors: Albert Bart\u00f3k-P\u00e1rtay, Stewart Clark, Phil Hasnip, Chris Pickard, Matt Probert, Keith Refson, Kane Shenton, Benjamin Shi, Jonathan Yates","title":"Home"},{"location":"#castep-documentation","text":"This is the CASTEP community documentation and tutorial site. For an overview of CASTEP, and to obtain a licence please see the castep website For the Dassault Syst\u00e8mes BIOVIA (Materials Studio) documentation for CASTEP see HTML documentation and a downloadable pdf user guide","title":"CASTEP Documentation"},{"location":"#contributors","text":"Albert Bart\u00f3k-P\u00e1rtay, Stewart Clark, Phil Hasnip, Chris Pickard, Matt Probert, Keith Refson, Kane Shenton, Benjamin Shi, Jonathan Yates","title":"Contributors:"},{"location":"documentation/Delta_SCF/lin_ex_delta_scf/","text":"Linear expansion DeltaSCF DFT calculations - Constraining projected reference orbitals Basics For molecules adsorbed at surfaces, \\Delta \\Delta SCF calculations become challenging, simply because of the large number of states. Not only is it difficult to identify the correct state, often hybridization spreads adsorbate molecular orbitals across a large number of substrate bands. A more realistic excitation constraint would be to project on a gasphase molecular orbital and subsequently enforce occupation of this state. This idea is referred to as linear expansion \\Delta \\Delta SCF and has first been proposed by Gavnholt et al . Phys. Rev. B 78, 075441 (2008). The CASTEP implementation is described in J. Chem. Phys. 139, 014708 (2013). Herein, we constrain the occupation of a so-called resonance state built from a linear combination of Kohn-Sham states instead of a single KS state. We expand an abitrary reference state |\\phi_c\\rangle |\\phi_c\\rangle in the space of Kohn-Sham states as follows: |\\tilde{\\psi}_c^{\\mathbf{k}}\\rangle = \\sum_i^{\\mathrm{states}} |\\psi_i^{\\mathbf{k}}\\rangle\\langle\\psi_i^{\\mathbf{k}}|\\phi_c^{\\mathbf{k}} \\rangle |\\tilde{\\psi}_c^{\\mathbf{k}}\\rangle = \\sum_i^{\\mathrm{states}} |\\psi_i^{\\mathbf{k}}\\rangle\\langle\\psi_i^{\\mathbf{k}}|\\phi_c^{\\mathbf{k}} \\rangle At the same time we orthogonalize the remaining KS states |\\tilde{\\psi_i^{\\mathbf{k}}}\\rangle = |\\psi_i^{\\mathbf{k}}\\rangle - \\sum_c^{\\mathrm{constr.}}|\\phi_c^{\\mathbf{k}}\\rangle\\langle\\phi_c^{\\mathbf{k}}|\\psi_i^{\\mathbf{k}}\\rangle |\\tilde{\\psi_i^{\\mathbf{k}}}\\rangle = |\\psi_i^{\\mathbf{k}}\\rangle - \\sum_c^{\\mathrm{constr.}}|\\phi_c^{\\mathbf{k}}\\rangle\\langle\\phi_c^{\\mathbf{k}}|\\psi_i^{\\mathbf{k}}\\rangle After an additional orthonormalization of all states we have constructed a resonance state \\tilde{\\psi_c^{\\mathbf{k}}} \\tilde{\\psi_c^{\\mathbf{k}}} and removed all its contributions from all other states. We can now constrain the occupation of this state with the effect of describing an excitation of a specific molecular orbital. This is done in every SCF step until the calculation is converged. For a le \\Delta \\Delta SCF calculation, we have to set deltascf_method = linear expansion in the <seed>.param file. The constraint must also be specifed, as discussed in the overview section. The only additional relevant \\Delta \\Delta SCF keywords is deltascf_overlap_cutoff Example .param file: reuse : <base>.check calculate_deltascf : true deltascf_checkpoint : <base>.check deltascf_method : linear expansion deltascf_overlap_cutoff : 0.01 #band occ spin %block deltascf_constraints 35 1.0000 1 %endblock deltascf_constraints In this example, we take state 35 from wavefunction file <base>.check and enforce an occupation of 1.00 electrons. In this runmode we do not have to pick constraints that yield a net change in charge equal to 0. Charge neutrality will be satisfied by modifying the Fermi level accordingly. However, this is only strictly sensible for metallic systems.","title":"Linear expansion DeltaSCF"},{"location":"documentation/Delta_SCF/lin_ex_delta_scf/#linear-expansion-deltascf-dft-calculations-constraining-projected-reference-orbitals","text":"","title":"Linear expansion DeltaSCF DFT calculations - Constraining projected reference orbitals"},{"location":"documentation/Delta_SCF/lin_ex_delta_scf/#basics","text":"For molecules adsorbed at surfaces, \\Delta \\Delta SCF calculations become challenging, simply because of the large number of states. Not only is it difficult to identify the correct state, often hybridization spreads adsorbate molecular orbitals across a large number of substrate bands. A more realistic excitation constraint would be to project on a gasphase molecular orbital and subsequently enforce occupation of this state. This idea is referred to as linear expansion \\Delta \\Delta SCF and has first been proposed by Gavnholt et al . Phys. Rev. B 78, 075441 (2008). The CASTEP implementation is described in J. Chem. Phys. 139, 014708 (2013). Herein, we constrain the occupation of a so-called resonance state built from a linear combination of Kohn-Sham states instead of a single KS state. We expand an abitrary reference state |\\phi_c\\rangle |\\phi_c\\rangle in the space of Kohn-Sham states as follows: |\\tilde{\\psi}_c^{\\mathbf{k}}\\rangle = \\sum_i^{\\mathrm{states}} |\\psi_i^{\\mathbf{k}}\\rangle\\langle\\psi_i^{\\mathbf{k}}|\\phi_c^{\\mathbf{k}} \\rangle |\\tilde{\\psi}_c^{\\mathbf{k}}\\rangle = \\sum_i^{\\mathrm{states}} |\\psi_i^{\\mathbf{k}}\\rangle\\langle\\psi_i^{\\mathbf{k}}|\\phi_c^{\\mathbf{k}} \\rangle At the same time we orthogonalize the remaining KS states |\\tilde{\\psi_i^{\\mathbf{k}}}\\rangle = |\\psi_i^{\\mathbf{k}}\\rangle - \\sum_c^{\\mathrm{constr.}}|\\phi_c^{\\mathbf{k}}\\rangle\\langle\\phi_c^{\\mathbf{k}}|\\psi_i^{\\mathbf{k}}\\rangle |\\tilde{\\psi_i^{\\mathbf{k}}}\\rangle = |\\psi_i^{\\mathbf{k}}\\rangle - \\sum_c^{\\mathrm{constr.}}|\\phi_c^{\\mathbf{k}}\\rangle\\langle\\phi_c^{\\mathbf{k}}|\\psi_i^{\\mathbf{k}}\\rangle After an additional orthonormalization of all states we have constructed a resonance state \\tilde{\\psi_c^{\\mathbf{k}}} \\tilde{\\psi_c^{\\mathbf{k}}} and removed all its contributions from all other states. We can now constrain the occupation of this state with the effect of describing an excitation of a specific molecular orbital. This is done in every SCF step until the calculation is converged. For a le \\Delta \\Delta SCF calculation, we have to set deltascf_method = linear expansion in the <seed>.param file. The constraint must also be specifed, as discussed in the overview section. The only additional relevant \\Delta \\Delta SCF keywords is deltascf_overlap_cutoff Example .param file: reuse : <base>.check calculate_deltascf : true deltascf_checkpoint : <base>.check deltascf_method : linear expansion deltascf_overlap_cutoff : 0.01 #band occ spin %block deltascf_constraints 35 1.0000 1 %endblock deltascf_constraints In this example, we take state 35 from wavefunction file <base>.check and enforce an occupation of 1.00 electrons. In this runmode we do not have to pick constraints that yield a net change in charge equal to 0. Charge neutrality will be satisfied by modifying the Fermi level accordingly. However, this is only strictly sensible for metallic systems.","title":"Basics"},{"location":"documentation/Delta_SCF/mo_delta_scf/","text":"DFT+U(MO) - Applying potentials to arbitrary orbitals Basics We can employ the molecular orbital projections we have introduced in the le \\Delta \\Delta SCF section to also introduce penalty potentials that shift specific orbitals up or down. This can be used to specify the HOMO-LUMO of an adsorbed molecule or to modify the level alignment with the metal substrate. This constraint potential can be combined with population constraints. For more details and an example application on Porphine molecules adsorbed at coinage metal surfaces, see J. Chem. Phys. 144, 024701 (2016). For a le \\Delta \\Delta SCF calculation, we have to set deltascf_method = linear expansion in the <seed>.param file. The constraint must also be specifed, as discussed in the overview section. The only additional relevant \\Delta \\Delta SCF keywords is deltascf_dftu_checkpoint Example .param file: reuse : <base>.check calculate_deltascf : true deltascf_checkpoint : <base>.check deltascf_dftu_checkpoint : <base2>.check deltascf_method : DFT+U(MO) #band occ spin +U in eV excite? %block deltascf_constraints 34 0.0000 1 -1.40 Y 35 1.0000 2 0.70 Y %endblock deltascf_constraints In this mode we add a potential to the Hamiltonian for each defined constraint, which has the following form: V_c = \\frac{U}{2} \\cdot|\\phi_c\\rangle\\langle\\phi_c| V_c = \\frac{U}{2} \\cdot|\\phi_c\\rangle\\langle\\phi_c| You can find a detailed description of these potentials in Appendix D of First-Principles Description of the Isomerization Dynamics of Surface-Adsorbed Molecular Switches , Doctoral Thesis, Technische Universit\u00e4t M\u00fcnchen, 2014 In this example, two +U constraint potentials act on orbital no. 34 of the majority spin channel and orbital no. 35 of the minority spin channel, taken from the deltascf_dftu_checkpoint=<base2>.check file. In addition, the occupation of orbital no. 35 taken from file deltascf_checkpoint=<base>.check file is constrained to the occupation 1.000. Excitation constraints on each state can be activated (or not) by adding the final 'Y' or 'N' to the relevant line.","title":"MO Delta SCF"},{"location":"documentation/Delta_SCF/mo_delta_scf/#dftumo-applying-potentials-to-arbitrary-orbitals","text":"","title":"DFT+U(MO) - Applying potentials to arbitrary orbitals"},{"location":"documentation/Delta_SCF/mo_delta_scf/#basics","text":"We can employ the molecular orbital projections we have introduced in the le \\Delta \\Delta SCF section to also introduce penalty potentials that shift specific orbitals up or down. This can be used to specify the HOMO-LUMO of an adsorbed molecule or to modify the level alignment with the metal substrate. This constraint potential can be combined with population constraints. For more details and an example application on Porphine molecules adsorbed at coinage metal surfaces, see J. Chem. Phys. 144, 024701 (2016). For a le \\Delta \\Delta SCF calculation, we have to set deltascf_method = linear expansion in the <seed>.param file. The constraint must also be specifed, as discussed in the overview section. The only additional relevant \\Delta \\Delta SCF keywords is deltascf_dftu_checkpoint Example .param file: reuse : <base>.check calculate_deltascf : true deltascf_checkpoint : <base>.check deltascf_dftu_checkpoint : <base2>.check deltascf_method : DFT+U(MO) #band occ spin +U in eV excite? %block deltascf_constraints 34 0.0000 1 -1.40 Y 35 1.0000 2 0.70 Y %endblock deltascf_constraints In this mode we add a potential to the Hamiltonian for each defined constraint, which has the following form: V_c = \\frac{U}{2} \\cdot|\\phi_c\\rangle\\langle\\phi_c| V_c = \\frac{U}{2} \\cdot|\\phi_c\\rangle\\langle\\phi_c| You can find a detailed description of these potentials in Appendix D of First-Principles Description of the Isomerization Dynamics of Surface-Adsorbed Molecular Switches , Doctoral Thesis, Technische Universit\u00e4t M\u00fcnchen, 2014 In this example, two +U constraint potentials act on orbital no. 34 of the majority spin channel and orbital no. 35 of the minority spin channel, taken from the deltascf_dftu_checkpoint=<base2>.check file. In addition, the occupation of orbital no. 35 taken from file deltascf_checkpoint=<base>.check file is constrained to the occupation 1.000. Excitation constraints on each state can be activated (or not) by adding the final 'Y' or 'N' to the relevant line.","title":"Basics"},{"location":"documentation/Delta_SCF/molpdos/","text":"Molecular Orbital (MO) projected Density-of-States - MolPDOS Basics This mode allows to generate projections and pDOS plots with respect to any molecular orbital (MO). To run it one just has to add calculate_modos=true keyword to <seed>.param file. The projection data is produced by CASTEP after the SCF task and is written to files called <seed>.modos_state_<#>_<#> , where the two numbers correspond to the number and the spin of the specified reference orbital from the reference checkfile. At the end of the <seed>.castep file the projection is commented in the following way: Calculating MODOS weights +-------------------INPUT PARAMETERS-------------------+ Taking band from model N2-base.check MODOS state 1 MODOS band nr. 5 MODOS band has spin 1 MODOS state 2 MODOS band nr. 6 MODOS band has spin 1 |DeltaSCF| Population of state: 5 1 1.000000 |DeltaSCF| Population of state: 6 1 0.000000 Writing file N2-modos.modos_state_5_1 Writing file N2-modos.modos_state_6_1 These files, together with the <seed>.bands file can be post-processed with the MolPDOS program with the following command MolPDOS <seed> This will write output in the <seed>.castep with following header. ############################################# # # # # # MolPDOS -CASTEP Post-processor # # # # by R. J. Maurer # # # # # ############################################# In addition it will write files for the total DOS (Total-DOS.dat), for the two spin channels if the calculation was spin polarized (Total-DOS_spin1.dat, Total-DOS_spin2.dat), and for the MolPDOS ( <#>_spin<#>_<output_filename) . The keywords for the .molpdos input file can be found below. Keywords allowed in .molpdos In the .molpdos files, the keyword title plus colon takes exactly 23 columns (A20,3X). The keyword content starts after that. Lines with # are ignored. keyword multiple appearance arguments and FORTRAN format molpdos_state Yes <# of ref. state I6>1X<spin of ef. state I6> molpdos_bin_with No real number, default=0.01 molpdos_smearing No real number, default=0.05 molpdos_scaling No real number, default=1.0, scales MolPDOSes no_fermi_shift No no argument, logical, removes fermishift ax is_energy_margin No real in eV default=0.0eV output_filename No <string len=40 filename> Example .molpdos file: molpdos_state : 34 1 molpdos_state : 35 1 molpdos_state : 36 1 molpdos_state : 33 1 molpdos_bin_width : 0.02 molpdos_smearing : 0.05 molpdos_scaling : 1.00 axis_energy_margin : 2.00 output_filename : MolPDOS.dat","title":"Molecular Projected DOS"},{"location":"documentation/Delta_SCF/molpdos/#molecular-orbital-mo-projected-density-of-states-molpdos","text":"","title":"Molecular Orbital (MO) projected Density-of-States - MolPDOS"},{"location":"documentation/Delta_SCF/molpdos/#basics","text":"This mode allows to generate projections and pDOS plots with respect to any molecular orbital (MO). To run it one just has to add calculate_modos=true keyword to <seed>.param file. The projection data is produced by CASTEP after the SCF task and is written to files called <seed>.modos_state_<#>_<#> , where the two numbers correspond to the number and the spin of the specified reference orbital from the reference checkfile. At the end of the <seed>.castep file the projection is commented in the following way: Calculating MODOS weights +-------------------INPUT PARAMETERS-------------------+ Taking band from model N2-base.check MODOS state 1 MODOS band nr. 5 MODOS band has spin 1 MODOS state 2 MODOS band nr. 6 MODOS band has spin 1 |DeltaSCF| Population of state: 5 1 1.000000 |DeltaSCF| Population of state: 6 1 0.000000 Writing file N2-modos.modos_state_5_1 Writing file N2-modos.modos_state_6_1 These files, together with the <seed>.bands file can be post-processed with the MolPDOS program with the following command MolPDOS <seed> This will write output in the <seed>.castep with following header. ############################################# # # # # # MolPDOS -CASTEP Post-processor # # # # by R. J. Maurer # # # # # ############################################# In addition it will write files for the total DOS (Total-DOS.dat), for the two spin channels if the calculation was spin polarized (Total-DOS_spin1.dat, Total-DOS_spin2.dat), and for the MolPDOS ( <#>_spin<#>_<output_filename) . The keywords for the .molpdos input file can be found below.","title":"Basics"},{"location":"documentation/Delta_SCF/molpdos/#keywords-allowed-in-molpdos","text":"In the .molpdos files, the keyword title plus colon takes exactly 23 columns (A20,3X). The keyword content starts after that. Lines with # are ignored. keyword multiple appearance arguments and FORTRAN format molpdos_state Yes <# of ref. state I6>1X<spin of ef. state I6> molpdos_bin_with No real number, default=0.01 molpdos_smearing No real number, default=0.05 molpdos_scaling No real number, default=1.0, scales MolPDOSes no_fermi_shift No no argument, logical, removes fermishift ax is_energy_margin No real in eV default=0.0eV output_filename No <string len=40 filename> Example .molpdos file: molpdos_state : 34 1 molpdos_state : 35 1 molpdos_state : 36 1 molpdos_state : 33 1 molpdos_bin_width : 0.02 molpdos_smearing : 0.05 molpdos_scaling : 1.00 axis_energy_margin : 2.00 output_filename : MolPDOS.dat","title":"Keywords allowed in .molpdos"},{"location":"documentation/Delta_SCF/overview/","text":"Overview Functionality Calculate \\Delta \\Delta SCF-DFT excitation energies by changing band occupation - the \"simple\" method. Constrain and occupy an orbital of a subsystem or reference system to resemble an electronic excitation via 'linear expansion mode' = le \\Delta \\Delta SCF-DFT Put penalties onto orbitals of a subsystem in a DFT+U fashion (DFT+U(MO)). This can be done by enforcing idempotency (integer occupation) or by constrained DFT Generate a projection of the orbital of a subsystem on the Density-of-States (DOS) There is also a separate post-processing tool (MolPDOS) to generate the corresponding DOS from the projection information Prerequisites The following applies to all modes, except the \\Delta \\Delta SCF-DFT mode. Nonetheless, this runmode requires a good understanding of its limitations. The two systems should not be strongly geometrically or electronically mixed and a separation into general system and subsystem has to still be chemically reasonable. Otherwise this Ansatz breaks down. Ideally the difference can be seen as a weak perturbation. This applies for example for A molecule adsorbed at a metal surface with weak to medium hybridization, e.g. C 6 H 6 \\@Au(111). A particle or molecule inserted into a porous nanostructure. The exact same system in another electronic state, e.g. groundstate vs. first excited state. The wavefunction of the subsystem has to be calculated with exactly the same settings (K-points, spin-polarisation, cutoff, cell size) as the actual system. This introduces some artificial dispersion for gas-phase molecules, but if the cell is sufficiently large the effects should be small. In addition, this might be something desirable, for example when high coverage situations are investigated. At the moment, the excitation constraints only work for metals_method=DM and spin_treatment=scalar or none . Currently, hybrid XC functionals are unsupported. General Use The general use of \\Delta \\Delta SCF always involves the following steps: Define the base system and calculate the self consistent density and wave functions using a task=single point energy . The checkfile generated is then used as the base for the next steps. Define the system you want to study and add something similar to the following to the <seed>.param file: reuse : <base>.check calculate_deltascf : true deltascf_checkpoint : <base>.check deltascf_mode : 1 where <base> is the seedname of the base calculation in step 1. Decide on the type of \\Delta \\Delta SCF calculation. The allowed methods are: deltascf_method : SIMPLE or deltascf_mode : 1 deltascf_method : DFT+U(MO) or deltascf_mode : 2 deltascf_method : LINEAR EXPANSTION or deltascf_mode : 3 For each method, the constraints need to be specified as follows: SIMPLE #band occ spin from_band to_band %block deltascf_constraints 5 0.5000 1 5 5 6 0.5000 1 6 6 %endblock deltascf_constraints DFT+U(MO) #band occ spin U(eV) excite_band %block deltascf_constraints 5 0.5000 1 +0.0 .true. 6 0.5000 1 +0.0 .true. %endblock deltascf_constraints LINEAR EXPANSION #band occ spin %block deltascf_constraints 5 0.5000 1 6 0.5000 1 %endblock deltascf_constraints The \"occ\" column is the constrained occupation required. In this instance, 1 electron is being raised from band 5 to band 6. The occupation is defined such that 0<=occ<=1 so if non-spin polarized calculation then occ=0.5 means 1 electron. You can now run the \\Delta \\Delta SCF calculation as any other CASTEP task. If you wish to, you can analyse the results using the MolPDOS post-processing tool which needs an additional <seed>.molpdos input file. Hence use MolPDOS <seed>","title":"Delta SCF Overview"},{"location":"documentation/Delta_SCF/overview/#overview","text":"","title":"Overview"},{"location":"documentation/Delta_SCF/overview/#functionality","text":"Calculate \\Delta \\Delta SCF-DFT excitation energies by changing band occupation - the \"simple\" method. Constrain and occupy an orbital of a subsystem or reference system to resemble an electronic excitation via 'linear expansion mode' = le \\Delta \\Delta SCF-DFT Put penalties onto orbitals of a subsystem in a DFT+U fashion (DFT+U(MO)). This can be done by enforcing idempotency (integer occupation) or by constrained DFT Generate a projection of the orbital of a subsystem on the Density-of-States (DOS) There is also a separate post-processing tool (MolPDOS) to generate the corresponding DOS from the projection information","title":"Functionality"},{"location":"documentation/Delta_SCF/overview/#prerequisites","text":"The following applies to all modes, except the \\Delta \\Delta SCF-DFT mode. Nonetheless, this runmode requires a good understanding of its limitations. The two systems should not be strongly geometrically or electronically mixed and a separation into general system and subsystem has to still be chemically reasonable. Otherwise this Ansatz breaks down. Ideally the difference can be seen as a weak perturbation. This applies for example for A molecule adsorbed at a metal surface with weak to medium hybridization, e.g. C 6 H 6 \\@Au(111). A particle or molecule inserted into a porous nanostructure. The exact same system in another electronic state, e.g. groundstate vs. first excited state. The wavefunction of the subsystem has to be calculated with exactly the same settings (K-points, spin-polarisation, cutoff, cell size) as the actual system. This introduces some artificial dispersion for gas-phase molecules, but if the cell is sufficiently large the effects should be small. In addition, this might be something desirable, for example when high coverage situations are investigated. At the moment, the excitation constraints only work for metals_method=DM and spin_treatment=scalar or none . Currently, hybrid XC functionals are unsupported.","title":"Prerequisites"},{"location":"documentation/Delta_SCF/overview/#general-use","text":"The general use of \\Delta \\Delta SCF always involves the following steps: Define the base system and calculate the self consistent density and wave functions using a task=single point energy . The checkfile generated is then used as the base for the next steps. Define the system you want to study and add something similar to the following to the <seed>.param file: reuse : <base>.check calculate_deltascf : true deltascf_checkpoint : <base>.check deltascf_mode : 1 where <base> is the seedname of the base calculation in step 1. Decide on the type of \\Delta \\Delta SCF calculation. The allowed methods are: deltascf_method : SIMPLE or deltascf_mode : 1 deltascf_method : DFT+U(MO) or deltascf_mode : 2 deltascf_method : LINEAR EXPANSTION or deltascf_mode : 3 For each method, the constraints need to be specified as follows: SIMPLE #band occ spin from_band to_band %block deltascf_constraints 5 0.5000 1 5 5 6 0.5000 1 6 6 %endblock deltascf_constraints DFT+U(MO) #band occ spin U(eV) excite_band %block deltascf_constraints 5 0.5000 1 +0.0 .true. 6 0.5000 1 +0.0 .true. %endblock deltascf_constraints LINEAR EXPANSION #band occ spin %block deltascf_constraints 5 0.5000 1 6 0.5000 1 %endblock deltascf_constraints The \"occ\" column is the constrained occupation required. In this instance, 1 electron is being raised from band 5 to band 6. The occupation is defined such that 0<=occ<=1 so if non-spin polarized calculation then occ=0.5 means 1 electron. You can now run the \\Delta \\Delta SCF calculation as any other CASTEP task. If you wish to, you can analyse the results using the MolPDOS post-processing tool which needs an additional <seed>.molpdos input file. Hence use MolPDOS <seed>","title":"General Use"},{"location":"documentation/Delta_SCF/simple_delta_scf/","text":"Conventional Delta-Self-Consistent-Field-DFT Calculations Basics In \\Delta \\Delta SCF-DFT we calculate electronic excited states by assuming a certain non-equilibrium orbital occupation and by self-consistently solving the Kohn-Sham equations with this excited state population. The excitation energy is then simply the energy difference between the ground state KS-DFT calculation and the \\Delta \\Delta SCF-DFT calculation: \\Delta E = E(\\Delta SCF)-E(DFT) \\Delta E = E(\\Delta SCF)-E(DFT) We therefore need to perform two calculations, the ground state DFT calculation and the DeltaSCF calculation. For a more detailed explanation, see J. Chem. Phys. 135, 224303 (2011) For this simple \\Delta \\Delta SCF calculation, we have to set deltascf_method = simple in the <seed>.param file. The constraint must also be specifed, as discussed in the overview section. The only additional relevant \\Delta \\Delta SCF keywords is deltascf_smearing Example .param file: reuse : <base>.check calculate_deltascf : true deltascf_checkpoint : <base>.check deltascf_method : simple deltascf_smearing : 0.01 #band occ spin from_band to_band %block deltascf_constraints 34 0.0000 1 34 34 35 1.0000 1 35 35 %endblock deltascf_constraints In this example, we enforce an occupation of 0.00 electrons in the electronic state 34, spin channel 1 and an occupation of 1.00 electrons in the electronic state 35, spin channel 1. The last two numbers in each line specify a window of states in which the corresponding state is searched if it changes its position between SCF cycles. In that way we can ensure that we constrain the correct state. deltascf_smearing is a mechanism which relaxes the constraints minimally to facilitate convergence. Sometimes, especially in the case of degenerate states, deltascf_smearing is necessary.","title":"Simple Delta SCF"},{"location":"documentation/Delta_SCF/simple_delta_scf/#conventional-delta-self-consistent-field-dft-calculations","text":"","title":"Conventional Delta-Self-Consistent-Field-DFT Calculations"},{"location":"documentation/Delta_SCF/simple_delta_scf/#basics","text":"In \\Delta \\Delta SCF-DFT we calculate electronic excited states by assuming a certain non-equilibrium orbital occupation and by self-consistently solving the Kohn-Sham equations with this excited state population. The excitation energy is then simply the energy difference between the ground state KS-DFT calculation and the \\Delta \\Delta SCF-DFT calculation: \\Delta E = E(\\Delta SCF)-E(DFT) \\Delta E = E(\\Delta SCF)-E(DFT) We therefore need to perform two calculations, the ground state DFT calculation and the DeltaSCF calculation. For a more detailed explanation, see J. Chem. Phys. 135, 224303 (2011) For this simple \\Delta \\Delta SCF calculation, we have to set deltascf_method = simple in the <seed>.param file. The constraint must also be specifed, as discussed in the overview section. The only additional relevant \\Delta \\Delta SCF keywords is deltascf_smearing Example .param file: reuse : <base>.check calculate_deltascf : true deltascf_checkpoint : <base>.check deltascf_method : simple deltascf_smearing : 0.01 #band occ spin from_band to_band %block deltascf_constraints 34 0.0000 1 34 34 35 1.0000 1 35 35 %endblock deltascf_constraints In this example, we enforce an occupation of 0.00 electrons in the electronic state 34, spin channel 1 and an occupation of 1.00 electrons in the electronic state 35, spin channel 1. The last two numbers in each line specify a window of states in which the corresponding state is searched if it changes its position between SCF cycles. In that way we can ensure that we constrain the correct state. deltascf_smearing is a mechanism which relaxes the constraints minimally to facilitate convergence. Sometimes, especially in the case of degenerate states, deltascf_smearing is necessary.","title":"Basics"},{"location":"documentation/EPR/overview/","text":"In crystalline materials, electron paramagnetic resonance (EPR) can be used to study paramagnetic defects. EPR spectra of spin \u00bd centers have two contributions: the hyperfine tensor {\\bf A} {\\bf A} and the g-tensor {\\bf g} {\\bf g} , which are defined through the following effective Hamiltonian \\begin{equation} H_{eff}=\\frac{\\alpha}{2}{\\bf S}\\cdot{\\bf g}\\cdot{\\bf B} + \\sum_I {\\bf S}\\cdot{\\bf A}_{I}\\cdot{\\bf I}_I \\end{equation} where \\alpha \\alpha is the fine structure constant and the summation I I runs over nuclei. The hyperfine tensor arises from the interaction of the nuclei with the ground-state spin density. This term has been calculated within the planewave-pseudopotential approach; indeed it was for this property that the PAW scheme was first introduced.\\cite{walle93} The g-tensor arises from the interaction of the electronic spin with the external magnetic field. This term plays an somewhat similar role to the shielding in NMR; induced electronic currents in the sample modify the g-tensor from its vacuum value. The GIPAW approach has been used to compute g-tensors in several crystalline materials including defects in \\alpha \\alpha -quartz and zirconia.","title":"EPR Overview"},{"location":"documentation/Geometry_Optimisation/constraints/","text":"Atomic constraints CASTEP can impose various forms of linear or non-linear constraints upon the positions of the atoms. This can be used with all forms of geometry optimization and molecular dynamics. Some simple short cuts exist, such as to keep all the atoms fixed: FIX_ALL_IONS : T or to fix the Centre of Mass: FIX_COM : T It is also possible to specify constraints on individual atoms, using the IONIC_CONSTRAINTS block. The simplest case is to control which atoms remain fixed during a geometry optimisation. e.g. %BLOCK IONIC_CONSTRAINTS fix: C 1 !fix position of atom C 1 %ENDBLOCK IONIC_CONSTRAINTS Some further examples include fix: all !fix all atoms\u2028 fix: C N !fix species C and N\u2028 fix: C 1 !fix position of atom C 1\u2028 fix: C{1,3,5-10} !fix positions of atoms C1, C3, C5,C6,C7,C8,C9,C10\u2028 fix: all unfix: H !fix positions of all atoms except H The last example in particularly useful in the case of molecular crystals, when you might want to allow the H atoms to move but keep all of the heavy atoms in the positions determined by diffraction. To fix the individual Cartesian components of an atom's position use the full syntax of the ionic_constraints block, where each constraint removes one degree of freedom. For example %BLOCK IONIC_CONSTRAINTS 1 W 1 1.0000000000 0.0000000000 0.0000000000 2 W 1 0.0000000000 1.0000000000 0.0000000000 3 W 1 0.0000000000 0.0000000000 1.0000000000 4 W 2 1.0000000000 0.0000000000 0.0000000000 %ENDBLOCK IONIC_CONSTRAINTS The 1 st line says that constraint number 1 is to fix the x coordinate of Tungsten atom 1. The 2 nd line says that constraint number 2 is to fix the y coordinate of Tungsten atom 1. etc. To fix an atom in 3D requires 3 constraints to remove all 3 degrees of freedom. The ionic_constraints block can also be used to impose any arbitary linear constraint, such as to restrict an atom to move in a plane or along a line, or to fix the centre of mass. A constraint may involve more than 1 atom, and hence can span mulitple lines, but each constraint operates on 1 degree of freedom. It cannot be used to fix a bond length - that is a non-linear constraint - see below for more details. The general syntax for constraint i i operating on atom j j of element X at position r^j r^j is %BLOCK IONIC_CONSTRAINTS ... i X j a1 a2 a3 ... %ENDBLOCK IONIC_CONSTRAINTS and the constraint is specfied as \\begin{equation} C^i={\\bf a^i}\\cdot{\\bf r^j} \\end{equation} where C^i C^i is given by the initial conditions. For example to fix the second S atom to move in the plane parallel to y=x y=x use this: %BLOCK IONIC_CONSTRAINTS 1 S 2 -1 1 0 %ENDBLOCK IONIC_CONSTRAINTS Cell Constraints Cell constraints can be used with all forms of geometry optimization and molecular dynamics that allow the cell size/shape to vary. Some simple short cuts exist, such as to keep the unit cell fixed during the optimisation FIX_CELL : T or to fix the volume (but not the shape) of the unit cell FIX_VOL : T It is also possible to apply an arbitary set of constraints to the cell angles and cell lengths using the CELL_CONSTRAINTS block. %BLOCK CELL_CONSTRAINTS a b c alpha beta gamma %ENDBLOCK CELL_CONSTRAINTS Setting an element to zero means to keep it fixed. Two or more elements set to the same positive integer, means that these elements should be kept equal during the geometry optimisation. For example %BLOCK CELL_CONSTRAINTS 0 0 0 4 5 6 %ENDBLOCK CELL_CONSTRAINTS would keep all cell lengths fixed, and allow the three cell angles to vary independently, and %BLOCK CELL_CONSTRAINTS 0 0 0 4 4 6 %ENDBLOCK CELL_CONSTRAINTS would enforce \\alpha=\\beta\\neq\\gamma \\alpha=\\beta\\neq\\gamma and keep the cell lengths fixed. Symmetry The application of symmetry with constraints (for ionic positions and/or cell vectors) needs to be considered carefully. In general, if symmetry is on, then there is no need to add a constraint to explicitly impose a restriction that is implied by the symmetry. If there is a need for an additional restriction, then that can be added on top of the symmetry, but the user needs to be careful that the additional constraint does not conflict with symmetry. If in doubt, turn symmetry off and impose all the desired constraints explicitly. Non-linear Constraints CASTEP can also support non-linear constraints, such as fixed bond length, in both molecular dynamics, and also in geometry optimization if using GEOM_METHOD=DELOCALISED : %BLOCK NONLINEAR_CONSTRAINTS constraint_type atom1 atom2 (atom3 (atom 4)) ... %ENDBLOCK NONLINEAR_CONSTRAINTS where the first element specifies a constraint type (distance, bend angle or torsion angle). Then depending on the type of constraint, either 2, 3 or 4 atoms need to be specified, and the corresponding quantity (distance, bend angle or torsion angle) is held constant at the initial value. As for (linear) ionic constraints, atoms are specified by species and number within that species. In addition, it is necessary to specify which periodic image of the cell the atom is located in (so constraints can straddle a cell boundary). For instance %BLOCK NONLINEAR_CONSTRAINTS distance H 4 0 0 0 O 2 0 1 0 bend H 5 0 0 0 C 1 1 0 1 H 2 0 0 0 torsion H 6 0 0 0 H 3 1 0 0 H 1 0 0 1 H 9 1 1 1 0 %ENDBLOCK NONLINEAR_CONSTRAINTS specifies: the distance between the 4 th hydrogen atom and the 2 nd oxygen atom in the adjacent ( 0 1 0 ) cell the bend angle defined by the 5 th hydrogen atom, the 1 st carbon atom in the ( 1 0 1 ) cell and the 2 nd hydrogen atom the torsion angle defined by 4 hydrogen atoms, etc.","title":"Constraints"},{"location":"documentation/Geometry_Optimisation/constraints/#atomic-constraints","text":"CASTEP can impose various forms of linear or non-linear constraints upon the positions of the atoms. This can be used with all forms of geometry optimization and molecular dynamics. Some simple short cuts exist, such as to keep all the atoms fixed: FIX_ALL_IONS : T or to fix the Centre of Mass: FIX_COM : T It is also possible to specify constraints on individual atoms, using the IONIC_CONSTRAINTS block. The simplest case is to control which atoms remain fixed during a geometry optimisation. e.g. %BLOCK IONIC_CONSTRAINTS fix: C 1 !fix position of atom C 1 %ENDBLOCK IONIC_CONSTRAINTS Some further examples include fix: all !fix all atoms\u2028 fix: C N !fix species C and N\u2028 fix: C 1 !fix position of atom C 1\u2028 fix: C{1,3,5-10} !fix positions of atoms C1, C3, C5,C6,C7,C8,C9,C10\u2028 fix: all unfix: H !fix positions of all atoms except H The last example in particularly useful in the case of molecular crystals, when you might want to allow the H atoms to move but keep all of the heavy atoms in the positions determined by diffraction. To fix the individual Cartesian components of an atom's position use the full syntax of the ionic_constraints block, where each constraint removes one degree of freedom. For example %BLOCK IONIC_CONSTRAINTS 1 W 1 1.0000000000 0.0000000000 0.0000000000 2 W 1 0.0000000000 1.0000000000 0.0000000000 3 W 1 0.0000000000 0.0000000000 1.0000000000 4 W 2 1.0000000000 0.0000000000 0.0000000000 %ENDBLOCK IONIC_CONSTRAINTS The 1 st line says that constraint number 1 is to fix the x coordinate of Tungsten atom 1. The 2 nd line says that constraint number 2 is to fix the y coordinate of Tungsten atom 1. etc. To fix an atom in 3D requires 3 constraints to remove all 3 degrees of freedom. The ionic_constraints block can also be used to impose any arbitary linear constraint, such as to restrict an atom to move in a plane or along a line, or to fix the centre of mass. A constraint may involve more than 1 atom, and hence can span mulitple lines, but each constraint operates on 1 degree of freedom. It cannot be used to fix a bond length - that is a non-linear constraint - see below for more details. The general syntax for constraint i i operating on atom j j of element X at position r^j r^j is %BLOCK IONIC_CONSTRAINTS ... i X j a1 a2 a3 ... %ENDBLOCK IONIC_CONSTRAINTS and the constraint is specfied as \\begin{equation} C^i={\\bf a^i}\\cdot{\\bf r^j} \\end{equation} where C^i C^i is given by the initial conditions. For example to fix the second S atom to move in the plane parallel to y=x y=x use this: %BLOCK IONIC_CONSTRAINTS 1 S 2 -1 1 0 %ENDBLOCK IONIC_CONSTRAINTS","title":"Atomic constraints"},{"location":"documentation/Geometry_Optimisation/constraints/#cell-constraints","text":"Cell constraints can be used with all forms of geometry optimization and molecular dynamics that allow the cell size/shape to vary. Some simple short cuts exist, such as to keep the unit cell fixed during the optimisation FIX_CELL : T or to fix the volume (but not the shape) of the unit cell FIX_VOL : T It is also possible to apply an arbitary set of constraints to the cell angles and cell lengths using the CELL_CONSTRAINTS block. %BLOCK CELL_CONSTRAINTS a b c alpha beta gamma %ENDBLOCK CELL_CONSTRAINTS Setting an element to zero means to keep it fixed. Two or more elements set to the same positive integer, means that these elements should be kept equal during the geometry optimisation. For example %BLOCK CELL_CONSTRAINTS 0 0 0 4 5 6 %ENDBLOCK CELL_CONSTRAINTS would keep all cell lengths fixed, and allow the three cell angles to vary independently, and %BLOCK CELL_CONSTRAINTS 0 0 0 4 4 6 %ENDBLOCK CELL_CONSTRAINTS would enforce \\alpha=\\beta\\neq\\gamma \\alpha=\\beta\\neq\\gamma and keep the cell lengths fixed.","title":"Cell Constraints"},{"location":"documentation/Geometry_Optimisation/constraints/#symmetry","text":"The application of symmetry with constraints (for ionic positions and/or cell vectors) needs to be considered carefully. In general, if symmetry is on, then there is no need to add a constraint to explicitly impose a restriction that is implied by the symmetry. If there is a need for an additional restriction, then that can be added on top of the symmetry, but the user needs to be careful that the additional constraint does not conflict with symmetry. If in doubt, turn symmetry off and impose all the desired constraints explicitly.","title":"Symmetry"},{"location":"documentation/Geometry_Optimisation/constraints/#non-linear-constraints","text":"CASTEP can also support non-linear constraints, such as fixed bond length, in both molecular dynamics, and also in geometry optimization if using GEOM_METHOD=DELOCALISED : %BLOCK NONLINEAR_CONSTRAINTS constraint_type atom1 atom2 (atom3 (atom 4)) ... %ENDBLOCK NONLINEAR_CONSTRAINTS where the first element specifies a constraint type (distance, bend angle or torsion angle). Then depending on the type of constraint, either 2, 3 or 4 atoms need to be specified, and the corresponding quantity (distance, bend angle or torsion angle) is held constant at the initial value. As for (linear) ionic constraints, atoms are specified by species and number within that species. In addition, it is necessary to specify which periodic image of the cell the atom is located in (so constraints can straddle a cell boundary). For instance %BLOCK NONLINEAR_CONSTRAINTS distance H 4 0 0 0 O 2 0 1 0 bend H 5 0 0 0 C 1 1 0 1 H 2 0 0 0 torsion H 6 0 0 0 H 3 1 0 0 H 1 0 0 1 H 9 1 1 1 0 %ENDBLOCK NONLINEAR_CONSTRAINTS specifies: the distance between the 4 th hydrogen atom and the 2 nd oxygen atom in the adjacent ( 0 1 0 ) cell the bend angle defined by the 5 th hydrogen atom, the 1 st carbon atom in the ( 1 0 1 ) cell and the 2 nd hydrogen atom the torsion angle defined by 4 hydrogen atoms, etc.","title":"Non-linear Constraints"},{"location":"documentation/Geometry_Optimisation/files/","text":".geom The .geom file is the primary output file, and contains the unit cell, positions of the atoms and the forces on the atoms for each step of the geometry optimisation. The format of this file is very similar to the .md file. BEGIN header END header 0 F F F F <-- c -1.1089287934762380E+000 -1.1089287934762380E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 0.0000000000000000E+000 0.0000000000000000E+000 0.0000000000000000E+000 <-- R H 2 0.0000000000000000E+000 0.0000000000000000E+000 1.8897261258369291E+000 <-- R H 1 5.2328399876121735E-008 -1.0421543664521416E-007 7.0009877481903737E-002 <-- F H 2 -5.2328399876121735E-008 1.0421543664521414E-007 -7.0009877481903737E-002 <-- F 1 F F F T <-- c -1.1238786617585625E+000 -1.1238786617585625E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 9.4833861449528325E-008 -1.8886784811136898E-007 1.2687770000486739E-001 <-- R H 2 -9.4833861449528339E-008 1.8886784811136895E-007 1.7628484258320618E+000 <-- R H 1 -3.5821658412345467E-009 7.1341230429117867E-009 4.3459352502549203E-002 <-- F H 2 3.5821658412345467E-009 -7.1341230429117867E-009 -4.3459352502549203E-002 <-- F 5 T T T T <-- c -1.1282766172341445E+000 -1.1282766172341445E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 -3.9595146097124387E-007 7.8856409239690845E-007 2.1772199021621047E-001 <-- R H 2 3.9595146097124376E-007 -7.8856409239690845E-007 1.6720041356207189E+000 <-- R H 1 -8.2747158669639466E-009 1.6479675454026804E-008 1.5340573808683700E-006 <-- F H 2 8.2747158669639466E-009 -1.6479675454026804E-008 -1.5340573808683700E-006 <-- F All quantities are reported in atomic units (this cannot be changed by any parameter) <-- c Reports the iteration number and whether the convergence criteria are satisfied. <-- E Energy (total energy, enthalpy) <-- h Unit cell vectors <-- S Stress on unit cell (only reported if the cell is allowed to change) <-- R Cartesian positions of atoms <-- F Force on atoms The '\u2190 c' line also reports the status of 4 convergence flags (either F=false or T=true). These are (in order): dE - has the energy change/atom been below geom_energy_tol for the last geom_convergence_win steps? Fmax - is the largest component of any force below geom_force_tol? dRmax - is the largest change in position for any atom below geom_disp_tol? Smax - is the largest component of the stress tensor below geom_stress_tol?","title":"Files"},{"location":"documentation/Geometry_Optimisation/files/#geom","text":"The .geom file is the primary output file, and contains the unit cell, positions of the atoms and the forces on the atoms for each step of the geometry optimisation. The format of this file is very similar to the .md file. BEGIN header END header 0 F F F F <-- c -1.1089287934762380E+000 -1.1089287934762380E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 0.0000000000000000E+000 0.0000000000000000E+000 0.0000000000000000E+000 <-- R H 2 0.0000000000000000E+000 0.0000000000000000E+000 1.8897261258369291E+000 <-- R H 1 5.2328399876121735E-008 -1.0421543664521416E-007 7.0009877481903737E-002 <-- F H 2 -5.2328399876121735E-008 1.0421543664521414E-007 -7.0009877481903737E-002 <-- F 1 F F F T <-- c -1.1238786617585625E+000 -1.1238786617585625E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 9.4833861449528325E-008 -1.8886784811136898E-007 1.2687770000486739E-001 <-- R H 2 -9.4833861449528339E-008 1.8886784811136895E-007 1.7628484258320618E+000 <-- R H 1 -3.5821658412345467E-009 7.1341230429117867E-009 4.3459352502549203E-002 <-- F H 2 3.5821658412345467E-009 -7.1341230429117867E-009 -4.3459352502549203E-002 <-- F 5 T T T T <-- c -1.1282766172341445E+000 -1.1282766172341445E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 -3.9595146097124387E-007 7.8856409239690845E-007 2.1772199021621047E-001 <-- R H 2 3.9595146097124376E-007 -7.8856409239690845E-007 1.6720041356207189E+000 <-- R H 1 -8.2747158669639466E-009 1.6479675454026804E-008 1.5340573808683700E-006 <-- F H 2 8.2747158669639466E-009 -1.6479675454026804E-008 -1.5340573808683700E-006 <-- F All quantities are reported in atomic units (this cannot be changed by any parameter) <-- c Reports the iteration number and whether the convergence criteria are satisfied. <-- E Energy (total energy, enthalpy) <-- h Unit cell vectors <-- S Stress on unit cell (only reported if the cell is allowed to change) <-- R Cartesian positions of atoms <-- F Force on atoms The '\u2190 c' line also reports the status of 4 convergence flags (either F=false or T=true). These are (in order): dE - has the energy change/atom been below geom_energy_tol for the last geom_convergence_win steps? Fmax - is the largest component of any force below geom_force_tol? dRmax - is the largest change in position for any atom below geom_disp_tol? Smax - is the largest component of the stress tensor below geom_stress_tol?","title":".geom"},{"location":"documentation/Geometry_Optimisation/keywords/","text":"To perform a geometry optimisation set the task parameter task : geomopt The convergence criteria have the following default values, each of which can be set independently. geom_energy_tol : Tolerance on energy change between iterations (default: 2.0e-5 eV) geom_force_tol : Tolerance on maximum force on each atom (default: 0.05 eV/ANG) geom_stress_tol : Tolerance on maximum stress on cell (default: 0.1 GPa) geom_disp_tol : Tolerance on change in atom positions between iterations (default: 0.001: Ang) geom_max_iter : Maximum number of iterations (default: 30) It is possible to change the optimisation method, and to choose a preconditioner. geom_method : LBFGS (default), BFGS, TPSD, DAMPEDMD, FIRE geom_preconditioner : EXP / FF / ID # EXPonential, Force Field, Identity (default) It is useful to set the following two parameters in a geometry optimisation. These will cause CASTEP to write a new cell/cif file with the final optimised coordinates write_cell_structure : T write_cif_structure : T","title":"Keywords"},{"location":"documentation/Geometry_Optimisation/overview/","text":"The essence of the calculation is for the ions and electrons in the supercell to be moved around stepwise until the forces on the atoms and the change in total energy between steps fall below some predefined convergence tolerance. The ionic positions are optimised using quasi-Newton methods. For each configuration of the ionic positions the electronic configuration is optimised using the method of conjugate gradients. The flow of the calculation is thus; Move ions into new positions using geometry optimisation algorithm Find electronic energy and forces for this ionic configuration Compare total energy with previous configurations and check if forces within tolerance limits If structure not optimised start at (1) and generate new set of ionic positions This cycle is performed until the forces fall within the tolerance limit and the energy should then be a local minimum. With periodic boundary conditions (as used by CASTEP) it is also possible to change the size and shape of the cell, in addition to (or instead of) moving the ions. In this case, the stress is calculated in addition to the forces, and this is used to change the cell, until the stress falls within a given tolerance. Finally, when considering the change in the cell, it is also possible to apply an external pressure. Hence it is the enthalpy, which is the appropriate free energy in this scenario, which is minimised instead of the energy. Finite-basis set corrections It should be noted, that with a plane-wave basis set (as used by CASTEP) there is an important side-effect of changing the size and/or shape of the cell - it changes the basis set used for the electronic states. Many DFT programs ignore this effect, which means that if the cell vectors change by more than a few %, the final structure is evaluated with a non-self-consistent basis, with a different cut-off energy to that intended. In CASTEP, there are two choices here: to either keep the cut-off energy constant (which results in the number and meaning of the plane-waves used in the basis changing from step-to-step) or to keep the number of plane-waves constant (which results in a change in the cut-off energy and in the meaning of the plane-waves used from step-to-step). The constant-cutoff/variable-number of plane-waves approach is the CASTEP default as it is the most physically reasonable. The constant number of plane-waves approach means that the quality of the calculation is changing from step-to-step. The effect of changing lattice vectors on the basis set can also be corrected to first-order using the 'finite basis set correction'. This can be calculated by the change in total energy for a small change in the cut-off energy at the start of a calculation, and then used as a correction to the energy and the stress. This is especially important in variable-cell calculations, for which it is activated by default. Advanced settings For geometry optimisation, there are a variety of different algorithms available which can be selected by the geom_method parameter in the param file. The choices are: LBFGS - the low-memory version of BFGS - the default option BFGS - widely-used quasi-Newton minimization TPSD - two-point steepest descent DELOCALIZED - a BFGS-based minimizer using delocalized internal coordinates DMD - optimally damped MD FIRE - fast inertial relaxation engine - a modified MD approach NB These are all 'local optimisations', i.e. the final structure depends upon the initial configuration and is not the global minimum. For those interested in finding the global minimum, then there are associated projects using Genetic Algorithms and AIRSS. The first 3 methods can do variable-cell or fixed-cell optimization, whereas the last 3 are only fixed-cell (for now). LBFGS/BFGS is generally the fastest method, and since v19, LBFGS has supported new preconditioners which should make it generally faster still. TPSD (unlike LBFGS/BFGS) has no built-in history, so should be much slower - however, the CASTEP implementation has a very efficient preconditioner which makes up for this, and the lack of history means that variable-cell optimisation with additional cell constraints is much more efficient than the equivalent calculation in LBFGS/BFGS. The DELOCALIZED minimizer is the only supported method to use delocalized internal coordinates, as opposed to absolute or fractional coordinates, and as such, should be best for optimizing large structures such as molecule-in-a-box with many low-energy soft modes. The two MD-based methods are generally less efficient, but can handle arbitrary constraints well, and have sometimes out-performed other methods for very anisotropic systems, such as molecule-on-a-surface etc.","title":"Overview"},{"location":"documentation/Geometry_Optimisation/overview/#finite-basis-set-corrections","text":"It should be noted, that with a plane-wave basis set (as used by CASTEP) there is an important side-effect of changing the size and/or shape of the cell - it changes the basis set used for the electronic states. Many DFT programs ignore this effect, which means that if the cell vectors change by more than a few %, the final structure is evaluated with a non-self-consistent basis, with a different cut-off energy to that intended. In CASTEP, there are two choices here: to either keep the cut-off energy constant (which results in the number and meaning of the plane-waves used in the basis changing from step-to-step) or to keep the number of plane-waves constant (which results in a change in the cut-off energy and in the meaning of the plane-waves used from step-to-step). The constant-cutoff/variable-number of plane-waves approach is the CASTEP default as it is the most physically reasonable. The constant number of plane-waves approach means that the quality of the calculation is changing from step-to-step. The effect of changing lattice vectors on the basis set can also be corrected to first-order using the 'finite basis set correction'. This can be calculated by the change in total energy for a small change in the cut-off energy at the start of a calculation, and then used as a correction to the energy and the stress. This is especially important in variable-cell calculations, for which it is activated by default.","title":"Finite-basis set corrections"},{"location":"documentation/Geometry_Optimisation/overview/#advanced-settings","text":"For geometry optimisation, there are a variety of different algorithms available which can be selected by the geom_method parameter in the param file. The choices are: LBFGS - the low-memory version of BFGS - the default option BFGS - widely-used quasi-Newton minimization TPSD - two-point steepest descent DELOCALIZED - a BFGS-based minimizer using delocalized internal coordinates DMD - optimally damped MD FIRE - fast inertial relaxation engine - a modified MD approach NB These are all 'local optimisations', i.e. the final structure depends upon the initial configuration and is not the global minimum. For those interested in finding the global minimum, then there are associated projects using Genetic Algorithms and AIRSS. The first 3 methods can do variable-cell or fixed-cell optimization, whereas the last 3 are only fixed-cell (for now). LBFGS/BFGS is generally the fastest method, and since v19, LBFGS has supported new preconditioners which should make it generally faster still. TPSD (unlike LBFGS/BFGS) has no built-in history, so should be much slower - however, the CASTEP implementation has a very efficient preconditioner which makes up for this, and the lack of history means that variable-cell optimisation with additional cell constraints is much more efficient than the equivalent calculation in LBFGS/BFGS. The DELOCALIZED minimizer is the only supported method to use delocalized internal coordinates, as opposed to absolute or fractional coordinates, and as such, should be best for optimizing large structures such as molecule-in-a-box with many low-energy soft modes. The two MD-based methods are generally less efficient, but can handle arbitrary constraints well, and have sometimes out-performed other methods for very anisotropic systems, such as molecule-on-a-surface etc.","title":"Advanced settings"},{"location":"documentation/Geometry_Optimisation/tools/","text":"JMol can read a .geom file and animate the movement of atoms during the optimisation. See tutorials for more examples.","title":"Tools"},{"location":"documentation/Getting_Started/basic_cell_file/","text":"This is a basic overview of the cell file. See the full cell file page for more details. The cell file is one of CASTEP's two main input files. It contains all of the information about the crystal lattice and the atomic positions, as well as additional information such as Brillouin zone sampling ('k-points'), pseudopotentials, and atomic properties. The file itself is a free-format keyword-driven text file, consisting of keywords and blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. Most of the keywords and blocks are optional, but CASTEP requires two block entries: a block to specify the lattice, and another to specify the atomic elements and positions within the cell. Lattice There are two main ways to set the crystal lattice in the cell file. The lattice_abc block specifies the lattice constants in terms of the lengths of the lattice vectors ( \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} ) and angles (alpha, beta and gamma): %block lattice_abc a b c alpha beta gamma %endblock lattice_abc This doesn't specify how the cell is to be oriented in the Cartesian coordinate system, so CASTEP uses the convention that \\mathbf{a} \\mathbf{a} is along the x-axis, and \\mathbf{b} \\mathbf{b} is in the x-y plane. Alternatively, you can specify the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} directly in terms of their Cartesian components, using the lattice_cart block. Note that these are specified as row vectors: %block lattice_cart [unit] a_x a_y a_z b_x b_y b_z c_x c_y c_z %endblock lattice_cart The first line is optional, and specifies a length unit; the default is ang , meaning Angstroms. Atomic positions The positions of the atoms within a cell may be specified in either fractional coordinates (i.e. the coordinates in the basis of the lattice vectors) or Cartesian coordinates: %block positions_frac symbol u v w %endblock positions_frac where symbol is the chemical symbol for the atomic element, and u , v and w are the fractional components of the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} , respectively, such that the Cartesian positions vector of the atom, \\mathbf{r} \\mathbf{r} , is \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} To add a second atom, simply add a second line with the new information, and similarly for additional atoms. An alternative is to specify the atomic coordinates with reference to their absolute Cartesian coordinates: %block positions_abs [unit] symbol x y z %endblock positions_abs where [unit] is an optional length unit (default: ang , meaning Angstroms), symbol is the chemical symbol for the atomic element, and x , y and z are the Cartesian coordinates of the atom, such that the position vector, \\mathbf{r}=(x,y,z) \\mathbf{r}=(x,y,z) . Comments It can be convenient to add comments to a cell file, not only to explain why certain choices were made, but also as a way of disabling input lines without removing them from the file. Both ! and # are accepted as comment characters, and anything to the right of these will be ignored by CASTEP. For example, the cell section # Place a single atom at the origin %block positions_abs bohr C 0.00000000 0.00000000 0.00000000 !Si 0.00000000 0.00000000 0.00000000 %endblock positions_abs has a comment explaining the atomic coordinates, and a single carbon atom at the origin. The second atomic position is commented out, so CASTEP will ignore it.","title":"cell File"},{"location":"documentation/Getting_Started/basic_cell_file/#lattice","text":"There are two main ways to set the crystal lattice in the cell file. The lattice_abc block specifies the lattice constants in terms of the lengths of the lattice vectors ( \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} ) and angles (alpha, beta and gamma): %block lattice_abc a b c alpha beta gamma %endblock lattice_abc This doesn't specify how the cell is to be oriented in the Cartesian coordinate system, so CASTEP uses the convention that \\mathbf{a} \\mathbf{a} is along the x-axis, and \\mathbf{b} \\mathbf{b} is in the x-y plane. Alternatively, you can specify the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} directly in terms of their Cartesian components, using the lattice_cart block. Note that these are specified as row vectors: %block lattice_cart [unit] a_x a_y a_z b_x b_y b_z c_x c_y c_z %endblock lattice_cart The first line is optional, and specifies a length unit; the default is ang , meaning Angstroms.","title":"Lattice"},{"location":"documentation/Getting_Started/basic_cell_file/#atomic-positions","text":"The positions of the atoms within a cell may be specified in either fractional coordinates (i.e. the coordinates in the basis of the lattice vectors) or Cartesian coordinates: %block positions_frac symbol u v w %endblock positions_frac where symbol is the chemical symbol for the atomic element, and u , v and w are the fractional components of the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} , respectively, such that the Cartesian positions vector of the atom, \\mathbf{r} \\mathbf{r} , is \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} To add a second atom, simply add a second line with the new information, and similarly for additional atoms. An alternative is to specify the atomic coordinates with reference to their absolute Cartesian coordinates: %block positions_abs [unit] symbol x y z %endblock positions_abs where [unit] is an optional length unit (default: ang , meaning Angstroms), symbol is the chemical symbol for the atomic element, and x , y and z are the Cartesian coordinates of the atom, such that the position vector, \\mathbf{r}=(x,y,z) \\mathbf{r}=(x,y,z) .","title":"Atomic positions"},{"location":"documentation/Getting_Started/basic_cell_file/#comments","text":"It can be convenient to add comments to a cell file, not only to explain why certain choices were made, but also as a way of disabling input lines without removing them from the file. Both ! and # are accepted as comment characters, and anything to the right of these will be ignored by CASTEP. For example, the cell section # Place a single atom at the origin %block positions_abs bohr C 0.00000000 0.00000000 0.00000000 !Si 0.00000000 0.00000000 0.00000000 %endblock positions_abs has a comment explaining the atomic coordinates, and a single carbon atom at the origin. The second atomic position is commented out, so CASTEP will ignore it.","title":"Comments"},{"location":"documentation/Getting_Started/basic_param_file/","text":"This is a basic overview of the param file. See the full param file page for more details. The param file is one of CASTEP's two main input files. It contains all of the information about the kind of simulation your wish CASTEP to perform, as well as details of how CASTEP should perform them and additional simulations and analyses. The file itself is a free-format keyword-driven text file, consisting largely of single-line keywords, although there are a small number of blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. All of the keywords and blocks are optional, but you will almost always want to change at least some. Task This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file . Cut-off energy The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV. XC functional Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"param File"},{"location":"documentation/Getting_Started/basic_param_file/#task","text":"This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file .","title":"Task"},{"location":"documentation/Getting_Started/basic_param_file/#cut-off-energy","text":"The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV.","title":"Cut-off energy"},{"location":"documentation/Getting_Started/basic_param_file/#xc-functional","text":"Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"XC functional"},{"location":"documentation/Getting_Started/built_in_help/","text":"CASTEP has an in-built help option to assist with using particular keywords. Information on using CASTEP can be seen by using: castep -h To get more information on a particular input file keyword (e.g. kpoint_mp_grid ) use: castep -h kpoint_mp_grid If you don't know the keyword you need to use, then you can search on a particular keyword. This returns a list of keywords that you might be interested in, e.g. to look at all keywords which contain a reference to symmetry. castep -s symmetry Finally, to list all keywords, use: castep -h all To find out which version of CASTEP you have, use: castep -v","title":"Command line help"},{"location":"documentation/Getting_Started/intro/","text":"CASTEP is a software package to calculate the properties of materials. It is based on quantum mechanics, in a form known as density functional theory, and can simulate a wide range of materials proprieties including energetics, structure at the atomic level, vibrational properties, and many experimental characterisation methods, such as infra-red and Raman spectra, NMR, and core-level spectra. This documentation This documentation focuses on using CASTEP at the command-line, as a stand-alone program. You can build two versions of CASTEP: a \"serial\" version called castep.serial , which is primarily designed to run on a single CPU core; or a parallel version called castep.mpi , which uses the message passing interface (MPI) to run on more than one core. Most of this documentation applies equally to both versions, but for simplicity we will focus on the serial version in most of the examples. We will refer to the CASTEP command itself as castep , which you will need to change to castep.serial or castep.mpi , as appropriate. In this documentation, anything in a fixed width font like this is text to type, either on the command-line or in a CASTEP input file. For CASTEP's input files, there is sometimes a choice between different settings, and this will be indicated using the | symbol, meaning \"or\". For example, setting : choice_1|choice_2|choice_3 If some of the entries are optional, they will have square brackets around them [like this] , for example: setting : choice_1|choice_2|choice_3 [unit of choice]","title":"Introduction"},{"location":"documentation/Getting_Started/intro/#this-documentation","text":"This documentation focuses on using CASTEP at the command-line, as a stand-alone program. You can build two versions of CASTEP: a \"serial\" version called castep.serial , which is primarily designed to run on a single CPU core; or a parallel version called castep.mpi , which uses the message passing interface (MPI) to run on more than one core. Most of this documentation applies equally to both versions, but for simplicity we will focus on the serial version in most of the examples. We will refer to the CASTEP command itself as castep , which you will need to change to castep.serial or castep.mpi , as appropriate. In this documentation, anything in a fixed width font like this is text to type, either on the command-line or in a CASTEP input file. For CASTEP's input files, there is sometimes a choice between different settings, and this will be indicated using the | symbol, meaning \"or\". For example, setting : choice_1|choice_2|choice_3 If some of the entries are optional, they will have square brackets around them [like this] , for example: setting : choice_1|choice_2|choice_3 [unit of choice]","title":"This documentation"},{"location":"documentation/Getting_Started/restarting/","text":"Checkpointing and Restarting CASTEP provides a mechanism for saving intermediate and final states of the calculation and for restarting or continuing from a saved state. At the end of every calculation which completes normally, CASTEP writes two files <seed>.check and <seed>.castep_bin which are binary-format files containing a complete state of the calculation including input parameters, cell variables, electron densities and any results or intermediate quantities whose calculation has completed. All inputs and results reported in the .castep file are saved to the checkpoint: indeed a lost .castep file from a completed calculation may be (mostly) regenerated using a minimal continuation run. .check vs .castep_bin The only difference between .check and .castep_bin is that the .check file contains the converged ground-state wavefunctions but .castep_bin does not, and therefore requires much less disk space to store. This makes it useful for purposes of archiving a calculation. When continuing from a .castep_bin CASTEP will regenerate the ground state wavefunctions non-selfconsistently using the ground-state density from the file. Checkpointing during a calculation An incomplete calculation can be completed in a new run by adding the parameters keyword continuation : default in the .param file and rerunning CASTEP as before with the same <seed> command-line argument. This is the usual way of continuing a run interrupted, for example, by the job time limit on a batch scheduling system. To benefit from continuation, a checkpoint file must have been written in the original run. There are three parameters keywords which may be used to do this: num_backup_iter <n> write a checkpoint every <n> (default 5) geometry MD or phonon steps backup_interval <s> write a checkpoint every <s> seconds run_time <s> write a checkpoint and exit at the first opportunity after <s> seconds have elapsed. These may be used to periodically checkpoint many lengthy post-SCF tasks including geometry optimization, MD, phonon calculations, but checkpointing of spectral and magres tasks is not supported via this mechanism. Neither is checkpointing possible within an extremely lengthy SCF calculation, but see the next section for an alternative. Checkpoint files are portable, and independent of data-distribution, so the continuation run may use a different number of parallel nodes, data distribution, OpenMP etc. They are also portable across computers, so a run may be started on one computer and finished on another, which may be helpful to balance use of computer resources. Advanced keywords One additional related parameters keyword which finds occasional use is a simple one-liner stop which can be added to the .param file while a run is in progress. CASTEP rereads the .param file at every checkpoint opportunity and if this is present will perform a graceful exit after writing the checkpoint files. Which periodic and end-of-run checkpoint files are written may be controlled by the parameters keyword write_checkpoint which takes values none : to suppress checkpoints completely minimal writes only .castep_bin all : writes both .check and .castep_bin Continuing from completed calculations The checkpoint/restart mechanism may also be used to \"chain\" runs or initialise a modified run with the results of a previous one. The .param file of the new run should contain continuation : <oldseed>.check Parameters values stored in and read from <oldseed>.check will be used, unless overridden by the new .param file, which therefore needs only a minimal number of entries. The .cell file is usually just copy of the original, but may also be modified if needed. Modifying task is a good way to \"chain\" calculations, for example performing a geometry optimisation followed by a spectral calculation. Info Not all parameter or cell keywords can be overridden upon continuation. castep --help <parameter-name> will report whether a variable is modifiable on continuation","title":"Checkpoint and Restart"},{"location":"documentation/Getting_Started/restarting/#checkpointing-and-restarting","text":"CASTEP provides a mechanism for saving intermediate and final states of the calculation and for restarting or continuing from a saved state. At the end of every calculation which completes normally, CASTEP writes two files <seed>.check and <seed>.castep_bin which are binary-format files containing a complete state of the calculation including input parameters, cell variables, electron densities and any results or intermediate quantities whose calculation has completed. All inputs and results reported in the .castep file are saved to the checkpoint: indeed a lost .castep file from a completed calculation may be (mostly) regenerated using a minimal continuation run. .check vs .castep_bin The only difference between .check and .castep_bin is that the .check file contains the converged ground-state wavefunctions but .castep_bin does not, and therefore requires much less disk space to store. This makes it useful for purposes of archiving a calculation. When continuing from a .castep_bin CASTEP will regenerate the ground state wavefunctions non-selfconsistently using the ground-state density from the file.","title":"Checkpointing and Restarting"},{"location":"documentation/Getting_Started/restarting/#checkpointing-during-a-calculation","text":"An incomplete calculation can be completed in a new run by adding the parameters keyword continuation : default in the .param file and rerunning CASTEP as before with the same <seed> command-line argument. This is the usual way of continuing a run interrupted, for example, by the job time limit on a batch scheduling system. To benefit from continuation, a checkpoint file must have been written in the original run. There are three parameters keywords which may be used to do this: num_backup_iter <n> write a checkpoint every <n> (default 5) geometry MD or phonon steps backup_interval <s> write a checkpoint every <s> seconds run_time <s> write a checkpoint and exit at the first opportunity after <s> seconds have elapsed. These may be used to periodically checkpoint many lengthy post-SCF tasks including geometry optimization, MD, phonon calculations, but checkpointing of spectral and magres tasks is not supported via this mechanism. Neither is checkpointing possible within an extremely lengthy SCF calculation, but see the next section for an alternative. Checkpoint files are portable, and independent of data-distribution, so the continuation run may use a different number of parallel nodes, data distribution, OpenMP etc. They are also portable across computers, so a run may be started on one computer and finished on another, which may be helpful to balance use of computer resources. Advanced keywords One additional related parameters keyword which finds occasional use is a simple one-liner stop which can be added to the .param file while a run is in progress. CASTEP rereads the .param file at every checkpoint opportunity and if this is present will perform a graceful exit after writing the checkpoint files. Which periodic and end-of-run checkpoint files are written may be controlled by the parameters keyword write_checkpoint which takes values none : to suppress checkpoints completely minimal writes only .castep_bin all : writes both .check and .castep_bin","title":"Checkpointing during a calculation"},{"location":"documentation/Getting_Started/restarting/#continuing-from-completed-calculations","text":"The checkpoint/restart mechanism may also be used to \"chain\" runs or initialise a modified run with the results of a previous one. The .param file of the new run should contain continuation : <oldseed>.check Parameters values stored in and read from <oldseed>.check will be used, unless overridden by the new .param file, which therefore needs only a minimal number of entries. The .cell file is usually just copy of the original, but may also be modified if needed. Modifying task is a good way to \"chain\" calculations, for example performing a geometry optimisation followed by a spectral calculation. Info Not all parameter or cell keywords can be overridden upon continuation. castep --help <parameter-name> will report whether a variable is modifiable on continuation","title":"Continuing from completed calculations"},{"location":"documentation/Getting_Started/running_castep/","text":"CASTEP has two main input files, called the cell file and the param file . The cell file defines the structure of the material (or molecule) you wish to study, and the param file defines the kind of simulation CASTEP should perform. The cell and param files should be named using the same prefix, which CASTEP calls the \"seedname\", with the extensions .cell and .param , respectively. For example, for a calculation called mytest , you need the input files mytest.cell mytest.param and the calculation is run with the command castep mytest The main CASTEP output file will be names using the same seedname and the .castep extension, i.e. in the above example it would be called mytest.castep . If this file already exists, CASTEP will append its output to it. When CASTEP completes successfully, it writes additional files such as the .bib file, which contains references to key papers for the theory and methods CASTEP used. If CASTEP encounters a serious problem, it will stop and write an error message to a .err file. If you are using the parallel version of CASTEP on many cores, you may see error files from each of these cores. They are named using the same seedname, but with the numeric process ID added, e.g. if CASTEP is run on 2 cores and a serious problem occurs, you might see the files mytest.0001.err mytest.0002.err These files contain useful information about what went wrong, so it is always worth looking at them. See the Troubleshooting Guide for details of how to find and fix common problems.","title":"Running CASTEP"},{"location":"documentation/Groundstate/dftd/","text":"Long-range dispersion corrections TODOS do the TSSURF and TSSCS schemes work/do anything? are the aperiodic versions of TSSCS and MBD still a thing? What elements are supported for D3? General recommendations for types of systems -- are these ok? Add others? Check note about small cells and the TS, XDM abd MBD methods. Is the solution just to use a bigger supercell? Rule of thumb? Background Why and when are long range-dispersion methods needed? van der Waals (vdW) interactions are ubiquitous in nature but aren't accounted for by standard local and semilocal density functional approximations (i.e. LDA or GGAs). In particular, the long-range attractive part of the vdW interaction between system components (London dispersion interaction) is not captured. Including such dispersion effects is essential for accurately describing certain systems, especially for systems that are not bound ionically or covalently, e.g. gas molecules. The use of a dispersion method is strongly recommended when intermolecular interactions are expected to play a key role such as in molecular crystals, stacked 2D materials, and generally any weakly-bound system. Types of correction schemes There are several families of dispersion methods. A good summary of these can be found in the 2016 review by Grimme et al. We will summarise these categories here and, for those implemented in CASTEP, link to the relevant keywords. Semiempirical/semiclassical treatments Here the dispersion energy is calculated atom-wise (typically pair-wise) and is added to the DFT energy of the underlying functional. Note that a specific damping parameter (and function) is usually used to combine a given underlying functional (e.g. PBE) with a dispersion correction (e.g. D3). This means, for example, that the D3 correction to the PBE functional may be different to the D3 correction to HSE. Methods include: The Tkatchenko\u2212Scheffler scheme ( TS ) The TS-based many-body dispersion scheme ( MBD ) Grimme's D2 and D3 methods The exchange-dipole moment model ( XDM ) Nonlocal density-based treatments (not implemented in CASTEP) Here non-local functionals of the electronic density are constructed. Methods include the van der Waals functionals (e.g. vdW-DF2 and vdW-DF-cx ) and Vydrov and Van Voorhis functionals (e.g. VV10 ). Effective one-electron potentials (not implemented in CASTEP) Finally, the many-body correlated motion of electrons can be, to some extent, captured empiricially by using effective one-electron potentials. Examples of these include: semi-local functionals such as the Minnesota functionals (e.g. M06 ) and external potentials such as the dispersion-corrected atom-centered potentials (see e.g. van Santen 2015 ). General recommendations TODO -- check these Every application will have its own set of important features and it is not possible to say with certainty which density functional approximation will be the most appropriate. With that said, here are some suggestions for different types of materials: Molecular crystals: D3/D3-BJ/XDM/MBD in combination with GGA or hybrid functionals ( Dolgonos et al. 2019 ). Metals: vdW-DFs developed with solid state materials in mind (see e.g. Klime\u0161 et al. 2011 ). TODO: what about methods available in CASTEP? Interactions between molecules and surfaces of metals: vdW-DFs or dispersion methods that include screening, e.g. TSSCS MOFs: dispersion corrected (e.g. TS, D3, etc.) GGAs Layered vdW materials: Beyond pairwise appraches, e.g. D3 ^* ^* or MBD. TODO: others? ^* ^* See note below for how to include the three-body terms in the CASTEP D3 correction. Again, please do your own testing and consult relevant reviews and benchmarking papers. For the TS, MBD and XDM methods you may get a warning if your unit cell is small (where the lattice constants are comparable to the vdW radii). In such cases, try to use larger unit cells until your dispersion correction converges. TODO: any other solutions? Not all XC_FUNCTIONAL values are supported for all schemes - if in doubt use PBE. Each scheme has default parameters defined for a subset of elements (see table below). For other elements you need to define custom parameters using the SEDC_CUSTOM_PARAMS keyword in the .cell file. Using dispersion corrections in CASTEP .param file keywords In the .param file, set: SEDC_APPLY : true turns on dispersion correction. SEDC_SCHEME : The semi-empirical dispersion/van der Waals correction scheme to use. Default is NONE , other possible values listed in the table below. SEDC_SCHEME Available from CASTEP version Compatible XC functionals Elements supported Stresses Phonons * TS Predates 2012 PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Up to Z=54 with first row Lanthanides Analytic DFPT & FD TSSURF Not sure if working TSSCS Not sure if working Up to Z=54 with first row Lanthanides Analytic MBD (Alias: MBD*) 2015? Rewritten (and fixed) for CASTEP 18 PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Up to Z=54 with first row Lanthanides Numeric FD G06 (= D2) Predates 2012 PBE, BLYP, BP86, B3LYP, TPSS Up to Z= 54 Analytic DFPT & FD D3 CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD D3-BJ CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD OBS Predates 2012 LDA, PW91 Up to Z=57 Analytic DFPT & FD JCHS Predates 2012 PBE, BLYP, B3LYP, TPSS H, C, N, O, F, Cl, Br Analytic DFPT & FD XDM CASTEP 20 PBE Up to Z=102 Analytic FD * DFPT: Density functional perturbation theory; FD: finite displacement. All of the above methods support analytic forces. .cell file keywords In the .cell file you can optionally set custom parameters for each species: C6 (eV \u00c5 ^6 ^6 ): Available for TS, MBD*, and Grimme schemes. R0 (\u00c5): Available for TS, MBD*, and Grimme schemes. alpha (\u00c5 ^3 ^3 ): Available for TS, MBD*, and OBS schemes. I (eV): Available for the OBS scheme. Rvdw (\u00c5): Available for the OBS scheme. You set them like this: %BLOCK SEDC_CUSTOM_PARAMS ! example values for test purposes only - don't use these... ! He C6:1.00 R0:2.00 Ne C6:10.00 R0:4.00 %ENDBLOCK SEDC_CUSTOM_PARAMS Method details and customisation Tkatchenko\u2212Scheffler schemes A density-dependent, atom pairwise dispersion-correction scheme. SEDC_SCHEME : TS Phys. Rev. Lett.,102, 073005 (2009) Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Elements up to Z=54 (Xe) together with first row Lanthanides are supported. SEDC_SCHEME : TSSCS # TS with self-consistent screening Phys. Rev. Lett., 108, 236402 (2012) SEDC_SCHEME : TSSURF Phys. Rev. Lett., 108, 146103 (2012) Customisation keywords for all TS schemes .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the TS methods, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised. Many-body dispersion Beyond what can be included in simple pairwise dispersion approaches, MBD introduces: (1) many-body energy (Axilrod-Teller and higher-order) and (2) long-range Coulomb response (screening) that serves to modify the polarizabilities of interacting species. SEDC_SCHEME : MBD # (Alias: MBD*) Phys. Rev. Lett., 108, 236402 (2012) J. Chem. Phys. 140, 18A508 (2014) Note that the two aliases MBD and MBD* both refer to the revised version of MBD which employs range-separation (rs) of the self-consistent screening (SCS) of polarizabilities and the calculation of the long-range correlation energy, i.e. the MBD@rs-scs method. TODO : in older versions of CASTEP was this the case? From what version can be rely on that info? Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Elements up to Z=54 (Xe) together with first row Lanthanides are supported. Note that in the current implementation, only numeric stresses are available. Customisation keywords for MBD scheme .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping functionin the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the MBD method, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised. Grimme D corrections D2 Note that default D2 parameters are available only for the PBE, BLYP, BP86, B3LYP, TPSS functionals. You can also customise the correction parameters using the following keywords: SEDC_SCHEME : G06 # This is CASTEP's name for the Grimme D2 correction J. Comput. Chem. 27, 1787, (2006) Customisation keywords G06 .param file SEDC_S6_G06 Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_G06 Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For Grimme's D2 method, C6 (eV \u00c5 ^6 ^6 ) and R0 (\u00c5) can be customised. D3 Grimme's DFT-D3 method. The D3 scheme with Becke-Johnson damping (D3-BJ) is generally more accurate than the 'zero-damping' method (D3). Restrictions: Default D3 parameters are available for the PBE, PBE0 and HF functionals. TODO: what elements are supported? By default the three-body term is not included . To include it, set d3_threebody: True within a devel_code block in the .param file. Turn on IPRINT > 1 to get more information on what has been included in the D3 correction. In the current implementation, users cannot supply custom parameters for this correction scheme. SEDC_SCHEME : D3 J. Chem. Phys. 132, 154104 (2010) SEDC_SCHEME : D3-BJ J. Comput. Chem. 32, 1456 (2011) This is the Grimme D3 scheme with Becke-Johnson damping. Note When running a D3-BJ calculation with IPRINT > 1 , you might see Dispersion version: D4 in the .castep output file. Confusingly, this does not mean the Grimme D4 method has been used, it's just an interal CASTEP version label for this correction scheme. Compilation flags: for the D3 correction, CASTEP must be compiled with GRIMMED3 := compile Note that for the D3 correction to work, CASTEP must be compiled with the following flag: # Grimme D3 library support. Options are none or compile GRIMMED3 := compile in the Makefile For CASTEP 20, the D3 library is included in the distribution and the setting the flag above should be sufficient. Exchange-dipole moment (XDM) method SEDC_SCHEME : XDM A unified density-functional treatment of dynamical, nondynamical, and dispersion correlations. J. Chem. Phys. 127, 124108 (2007) To use this correction with the PBE functional, you need to set: SEDC_APPLY = TRUE SEDC_SCHEME = XDM SEDC_SC_XDM = 1.0 where the SEDC_SC_XDM parameter is a global scaling factor. For other functionals you need to specify the following additional parameters: Customisation keywords for XDM .param file SEDC_A1_XDM Type: Real (float) Level: Expert Description: Customisable A1 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_A2_XDM Type: Physical (float) Level: Expert Description: Customisable A2 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SC_XDM Type: Real (float) Level: Expert Description: Customisable SC value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_C9_XDM Type: Logical Level: Basic Description: Specifies whether three-body dispersion coefficients are to be computed in the XDM semi-empirical dispersion/ van der Waals correction scheme. Modifiable: restart and on the fly Allowed values: TRUE or FALSE Default is FALSE Note that the specific parameters found here: http://schooner.chem.dal.ca/wiki/XDM are might not be directly transferable to CASTEP and careful further testing is necessary. Other Schemes SEDC_SCHEME : OBS # (Ortmann, Bechstedt and Schmidt) Semiempirical van der Waals correction to the density functional description of solids and molecular structures Phys. Rev. B 73, 205101, (2006) Customisation keywords \" SEDC_LAMBDA_OBS \" Type: Real (float) Level: Expert Description: Customisable lambda value for damping function in the the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . \" SEDC_N_OBS \" Type: Real (float) Level: Expert Description: Customisable n value for the damping function in the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SCHEME : JCHS # (Jure\u010dka, \u010cern\u00fd, Hobza and Salahub) J. Comput. Chem. 28, 555, (2007) Customisation keywords SEDC_SR_JCHS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_S6_JCHS Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_JCHS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL .","title":"Dispersion Corrections"},{"location":"documentation/Groundstate/dftd/#long-range-dispersion-corrections","text":"TODOS do the TSSURF and TSSCS schemes work/do anything? are the aperiodic versions of TSSCS and MBD still a thing? What elements are supported for D3? General recommendations for types of systems -- are these ok? Add others? Check note about small cells and the TS, XDM abd MBD methods. Is the solution just to use a bigger supercell? Rule of thumb?","title":"Long-range dispersion corrections"},{"location":"documentation/Groundstate/dftd/#background","text":"","title":"Background"},{"location":"documentation/Groundstate/dftd/#why-and-when-are-long-range-dispersion-methods-needed","text":"van der Waals (vdW) interactions are ubiquitous in nature but aren't accounted for by standard local and semilocal density functional approximations (i.e. LDA or GGAs). In particular, the long-range attractive part of the vdW interaction between system components (London dispersion interaction) is not captured. Including such dispersion effects is essential for accurately describing certain systems, especially for systems that are not bound ionically or covalently, e.g. gas molecules. The use of a dispersion method is strongly recommended when intermolecular interactions are expected to play a key role such as in molecular crystals, stacked 2D materials, and generally any weakly-bound system.","title":"Why and when are long range-dispersion methods needed?"},{"location":"documentation/Groundstate/dftd/#types-of-correction-schemes","text":"There are several families of dispersion methods. A good summary of these can be found in the 2016 review by Grimme et al. We will summarise these categories here and, for those implemented in CASTEP, link to the relevant keywords. Semiempirical/semiclassical treatments Here the dispersion energy is calculated atom-wise (typically pair-wise) and is added to the DFT energy of the underlying functional. Note that a specific damping parameter (and function) is usually used to combine a given underlying functional (e.g. PBE) with a dispersion correction (e.g. D3). This means, for example, that the D3 correction to the PBE functional may be different to the D3 correction to HSE. Methods include: The Tkatchenko\u2212Scheffler scheme ( TS ) The TS-based many-body dispersion scheme ( MBD ) Grimme's D2 and D3 methods The exchange-dipole moment model ( XDM ) Nonlocal density-based treatments (not implemented in CASTEP) Here non-local functionals of the electronic density are constructed. Methods include the van der Waals functionals (e.g. vdW-DF2 and vdW-DF-cx ) and Vydrov and Van Voorhis functionals (e.g. VV10 ). Effective one-electron potentials (not implemented in CASTEP) Finally, the many-body correlated motion of electrons can be, to some extent, captured empiricially by using effective one-electron potentials. Examples of these include: semi-local functionals such as the Minnesota functionals (e.g. M06 ) and external potentials such as the dispersion-corrected atom-centered potentials (see e.g. van Santen 2015 ).","title":"Types of correction schemes"},{"location":"documentation/Groundstate/dftd/#general-recommendations","text":"TODO -- check these Every application will have its own set of important features and it is not possible to say with certainty which density functional approximation will be the most appropriate. With that said, here are some suggestions for different types of materials: Molecular crystals: D3/D3-BJ/XDM/MBD in combination with GGA or hybrid functionals ( Dolgonos et al. 2019 ). Metals: vdW-DFs developed with solid state materials in mind (see e.g. Klime\u0161 et al. 2011 ). TODO: what about methods available in CASTEP? Interactions between molecules and surfaces of metals: vdW-DFs or dispersion methods that include screening, e.g. TSSCS MOFs: dispersion corrected (e.g. TS, D3, etc.) GGAs Layered vdW materials: Beyond pairwise appraches, e.g. D3 ^* ^* or MBD. TODO: others? ^* ^* See note below for how to include the three-body terms in the CASTEP D3 correction. Again, please do your own testing and consult relevant reviews and benchmarking papers. For the TS, MBD and XDM methods you may get a warning if your unit cell is small (where the lattice constants are comparable to the vdW radii). In such cases, try to use larger unit cells until your dispersion correction converges. TODO: any other solutions? Not all XC_FUNCTIONAL values are supported for all schemes - if in doubt use PBE. Each scheme has default parameters defined for a subset of elements (see table below). For other elements you need to define custom parameters using the SEDC_CUSTOM_PARAMS keyword in the .cell file.","title":"General recommendations"},{"location":"documentation/Groundstate/dftd/#using-dispersion-corrections-in-castep","text":"","title":"Using dispersion corrections in CASTEP"},{"location":"documentation/Groundstate/dftd/#param-file-keywords","text":"In the .param file, set: SEDC_APPLY : true turns on dispersion correction. SEDC_SCHEME : The semi-empirical dispersion/van der Waals correction scheme to use. Default is NONE , other possible values listed in the table below. SEDC_SCHEME Available from CASTEP version Compatible XC functionals Elements supported Stresses Phonons * TS Predates 2012 PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Up to Z=54 with first row Lanthanides Analytic DFPT & FD TSSURF Not sure if working TSSCS Not sure if working Up to Z=54 with first row Lanthanides Analytic MBD (Alias: MBD*) 2015? Rewritten (and fixed) for CASTEP 18 PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Up to Z=54 with first row Lanthanides Numeric FD G06 (= D2) Predates 2012 PBE, BLYP, BP86, B3LYP, TPSS Up to Z= 54 Analytic DFPT & FD D3 CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD D3-BJ CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD OBS Predates 2012 LDA, PW91 Up to Z=57 Analytic DFPT & FD JCHS Predates 2012 PBE, BLYP, B3LYP, TPSS H, C, N, O, F, Cl, Br Analytic DFPT & FD XDM CASTEP 20 PBE Up to Z=102 Analytic FD * DFPT: Density functional perturbation theory; FD: finite displacement. All of the above methods support analytic forces.","title":".param file keywords"},{"location":"documentation/Groundstate/dftd/#cell-file-keywords","text":"In the .cell file you can optionally set custom parameters for each species: C6 (eV \u00c5 ^6 ^6 ): Available for TS, MBD*, and Grimme schemes. R0 (\u00c5): Available for TS, MBD*, and Grimme schemes. alpha (\u00c5 ^3 ^3 ): Available for TS, MBD*, and OBS schemes. I (eV): Available for the OBS scheme. Rvdw (\u00c5): Available for the OBS scheme. You set them like this: %BLOCK SEDC_CUSTOM_PARAMS ! example values for test purposes only - don't use these... ! He C6:1.00 R0:2.00 Ne C6:10.00 R0:4.00 %ENDBLOCK SEDC_CUSTOM_PARAMS","title":".cell file keywords"},{"location":"documentation/Groundstate/dftd/#method-details-and-customisation","text":"","title":"Method details and customisation"},{"location":"documentation/Groundstate/dftd/#tkatchenkoscheffler-schemes","text":"A density-dependent, atom pairwise dispersion-correction scheme. SEDC_SCHEME : TS Phys. Rev. Lett.,102, 073005 (2009) Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Elements up to Z=54 (Xe) together with first row Lanthanides are supported. SEDC_SCHEME : TSSCS # TS with self-consistent screening Phys. Rev. Lett., 108, 236402 (2012) SEDC_SCHEME : TSSURF Phys. Rev. Lett., 108, 146103 (2012) Customisation keywords for all TS schemes .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the TS methods, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised.","title":"Tkatchenko\u2212Scheffler schemes"},{"location":"documentation/Groundstate/dftd/#many-body-dispersion","text":"Beyond what can be included in simple pairwise dispersion approaches, MBD introduces: (1) many-body energy (Axilrod-Teller and higher-order) and (2) long-range Coulomb response (screening) that serves to modify the polarizabilities of interacting species. SEDC_SCHEME : MBD # (Alias: MBD*) Phys. Rev. Lett., 108, 236402 (2012) J. Chem. Phys. 140, 18A508 (2014) Note that the two aliases MBD and MBD* both refer to the revised version of MBD which employs range-separation (rs) of the self-consistent screening (SCS) of polarizabilities and the calculation of the long-range correlation energy, i.e. the MBD@rs-scs method. TODO : in older versions of CASTEP was this the case? From what version can be rely on that info? Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Elements up to Z=54 (Xe) together with first row Lanthanides are supported. Note that in the current implementation, only numeric stresses are available. Customisation keywords for MBD scheme .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping functionin the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the MBD method, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised.","title":"Many-body dispersion "},{"location":"documentation/Groundstate/dftd/#grimme-d-corrections","text":"D2 Note that default D2 parameters are available only for the PBE, BLYP, BP86, B3LYP, TPSS functionals. You can also customise the correction parameters using the following keywords: SEDC_SCHEME : G06 # This is CASTEP's name for the Grimme D2 correction J. Comput. Chem. 27, 1787, (2006) Customisation keywords G06 .param file SEDC_S6_G06 Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_G06 Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For Grimme's D2 method, C6 (eV \u00c5 ^6 ^6 ) and R0 (\u00c5) can be customised. D3 Grimme's DFT-D3 method. The D3 scheme with Becke-Johnson damping (D3-BJ) is generally more accurate than the 'zero-damping' method (D3). Restrictions: Default D3 parameters are available for the PBE, PBE0 and HF functionals. TODO: what elements are supported? By default the three-body term is not included . To include it, set d3_threebody: True within a devel_code block in the .param file. Turn on IPRINT > 1 to get more information on what has been included in the D3 correction. In the current implementation, users cannot supply custom parameters for this correction scheme. SEDC_SCHEME : D3 J. Chem. Phys. 132, 154104 (2010) SEDC_SCHEME : D3-BJ J. Comput. Chem. 32, 1456 (2011) This is the Grimme D3 scheme with Becke-Johnson damping. Note When running a D3-BJ calculation with IPRINT > 1 , you might see Dispersion version: D4 in the .castep output file. Confusingly, this does not mean the Grimme D4 method has been used, it's just an interal CASTEP version label for this correction scheme. Compilation flags: for the D3 correction, CASTEP must be compiled with GRIMMED3 := compile Note that for the D3 correction to work, CASTEP must be compiled with the following flag: # Grimme D3 library support. Options are none or compile GRIMMED3 := compile in the Makefile For CASTEP 20, the D3 library is included in the distribution and the setting the flag above should be sufficient.","title":"Grimme D corrections"},{"location":"documentation/Groundstate/dftd/#exchange-dipole-moment-xdm-method","text":"SEDC_SCHEME : XDM A unified density-functional treatment of dynamical, nondynamical, and dispersion correlations. J. Chem. Phys. 127, 124108 (2007) To use this correction with the PBE functional, you need to set: SEDC_APPLY = TRUE SEDC_SCHEME = XDM SEDC_SC_XDM = 1.0 where the SEDC_SC_XDM parameter is a global scaling factor. For other functionals you need to specify the following additional parameters: Customisation keywords for XDM .param file SEDC_A1_XDM Type: Real (float) Level: Expert Description: Customisable A1 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_A2_XDM Type: Physical (float) Level: Expert Description: Customisable A2 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SC_XDM Type: Real (float) Level: Expert Description: Customisable SC value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_C9_XDM Type: Logical Level: Basic Description: Specifies whether three-body dispersion coefficients are to be computed in the XDM semi-empirical dispersion/ van der Waals correction scheme. Modifiable: restart and on the fly Allowed values: TRUE or FALSE Default is FALSE Note that the specific parameters found here: http://schooner.chem.dal.ca/wiki/XDM are might not be directly transferable to CASTEP and careful further testing is necessary.","title":"Exchange-dipole moment (XDM) method "},{"location":"documentation/Groundstate/dftd/#other-schemes","text":"SEDC_SCHEME : OBS # (Ortmann, Bechstedt and Schmidt) Semiempirical van der Waals correction to the density functional description of solids and molecular structures Phys. Rev. B 73, 205101, (2006) Customisation keywords \" SEDC_LAMBDA_OBS \" Type: Real (float) Level: Expert Description: Customisable lambda value for damping function in the the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . \" SEDC_N_OBS \" Type: Real (float) Level: Expert Description: Customisable n value for the damping function in the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SCHEME : JCHS # (Jure\u010dka, \u010cern\u00fd, Hobza and Salahub) J. Comput. Chem. 28, 555, (2007) Customisation keywords SEDC_SR_JCHS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_S6_JCHS Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_JCHS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL .","title":"Other Schemes"},{"location":"documentation/Groundstate/intro/","text":"One of the most fundamental tasks for CASTEP is to take a crystal lattice and set of atomic positions, and compute the electronic density and total energy. Once the lattice and atomic positions have been specified, you can tell CASTEP to compute the energy by setting the task keyword in the param file : task : energy Your cell and param files should be named using the same prefix, which CASTEP calls the \"seedname\", and the extensions .cell and .param , respectively. For example, for a calculation called mytest , you need the input files mytest.cell mytest.param and the calculation is run with the command castep mytest CASTEP computes the energy by solving the Kohn-Sham equations iteratively, using the 'self-consistent field' (SCF) method.","title":"Overview"},{"location":"documentation/Groundstate/nlxc/","text":"","title":"Nlxc"},{"location":"documentation/Groundstate/population_analysis/","text":"Population analysis At the end of a single point calculation, the ground state electron density is obtained. The electrons are distributed such that the total energy functional is minimised, meaning that they do not belong to individual atoms anymore. However, it is often useful as well as insightful to partition the total electron density to atomic or bond contributions. While such population analyses have no direct connection to experimental observables, they provide a chemical interpretation of possible charge transfer within the system. There are many flavours of charge partitioning, of which CASTEP can perform the Mulliken population analysis (see also here , here and here ) and the Hirshfeld definition . Mulliken population analysis The total number of electrons N N of a quantum mechanical system can be found by evaluating the sum \\begin{equation} N = \\sum _ \\mu (\\mathbf{P} \\mathbf{S}) _ {\\mu\\mu} \\end{equation} where \\mathbf{P} \\mathbf{P} and \\mathbf{S} \\mathbf{S} are the density and overlap matrices expressed in a suitable basis set \\boldsymbol{\\chi} \\boldsymbol{\\chi} , respectively. The overlap matrix elements are obtained as \\begin{equation} S _ {\\mu\\nu} = \\langle \\chi _ \\mu | \\chi _ \\nu \\rangle \\textrm{.} \\end{equation} The density matrix results from evaluating the density operator using the basis set \\begin{equation} P _ {\\mu\\nu} = \\langle \\chi _ \\mu | \\hat{P} | \\chi _ \\nu \\rangle \\end{equation} where the single-particle density operator is expressed in terms of the single-particle wavefunctions \\psi _ i \\psi _ i and the corresponding occupancies f _ i f _ i as \\begin{equation} \\hat{P} = \\sum _ i f _ i \\; |\\psi _ i \\rangle \\langle \\psi _ i | \\textrm{,} \\end{equation} therefore \\begin{equation} P _ {\\mu\\nu} = \\sum _ i f _ i \\; \\langle \\chi _ \\mu | \\psi _ i \\rangle \\langle \\psi _ i | \\chi _ \\nu \\rangle \\textrm{.} \\end{equation} If the basis set \\boldsymbol{\\chi} \\boldsymbol{\\chi} is local (i.e. functions with compact support), individual terms (\\mathbf{P} \\mathbf{S}) _ {\\mu\\mu} (\\mathbf{P} \\mathbf{S}) _ {\\mu\\mu} in the total charge expression may be associated with the spatial region corresponding to the individual basis function \\chi _ \\mu \\chi _ \\mu . If these basis functions are centred on atoms, the contributions belonging to a particular atom A A are defined as the charge of A A : \\begin{equation} N _ A = \\sum _ {\\mu \\in A} (\\mathbf{P} \\mathbf{S}) _ {\\mu\\mu} \\textrm{.} \\end{equation} Conveniently, the off-diagonal elements of \\mathbf{P} \\mathbf{S} \\mathbf{P} \\mathbf{S} are partitioned into bond contributions between atoms A A and B B as \\begin{equation} N _ {AB} = \\sum _ {\\mu \\in A} \\sum _ {\\nu \\in B} (\\mathbf{P} \\mathbf{S}) _ {\\mu\\nu} \\textrm{.} \\end{equation} To assign a charge to an atom, \\begin{equation} q _ A = Z' _ A - N _ A \\end{equation} is calculated, where Z' Z' is the pseudoatom nuclear charge. The CASTEP implementation In CASTEP, the solution of the electronic problem results in a set of Kohn-Sham orbitals \\psi _ i \\psi _ i , which are expressed in terms of plane-wave functions. Plane-waves are non-local, therefore not directly suitable for Mulliken population analysis. In order to obtain a suitable local basis, CASTEP solves the electronic problem of the isolated atom for each atomic specie present in the system, resulting in a set of atomic orbitals \\chi _ \\mu \\chi _ \\mu . Note that for this set of calculations, the same calculation settings (e.g. electronic cutoff and pseudopotentials) are used. With the atomic orbitals determined, the Mulliken population analysis can be performed by calculating the projections \\langle \\chi _ \\mu | \\psi _ i \\rangle \\langle \\chi _ \\mu | \\psi _ i \\rangle . CASTEP keywords The default behaviour is to compute the population analysis on completion of most tasks that determine the ground state electron density. Mulliken population analysis can be turned off by adding POPN_CALCULATE : FALSE to the .param file. The bond population analysis is computed between all atoms which are closer than a spatial cutoff (3 \u212b by default), which may be controlled using the .param keyword POPN_BOND_CUTOFF , for example POPN_BOND_CUTOFF : 4.0 to set the cutoff to 4 \u212b. To control the verbosity of the population analysis output, POPN_WRITE : ENHANCED which is the default setting, writes individual orbital as well as atomic and bond populations; POPN_WRITE : MINIMAL only writes atomic and bond populations; POPN_WRITE : NONE only writes bond populations. The .cell block SPECIES_LCAO_STATES controls the number of atomic orbitals, as specified by their main and angular quantum numbers, used for each atomic specie. By default, all valence states up to the next noble gas configuration are obtained and used in the population analysis, but these can be overridden, for example: %BLOCK SPECIES_LCAO_STATES H 3 %ENDBLOCK SPECIES_LCAO_STATES will use the 1s, 2s and 2p orbitals. Shallow core states, if explicitly treated as valance states, are included. For example, for atoms such as Na, where most pseudopotential definitions include shallow core states, 2s, 2p, 3s and 3p are all used in the population analysis. The Hirshfeld partitioning scheme The Hirshfeld population analysis partitions the total ground state electronic density \\rho(\\mathbf{r}) \\rho(\\mathbf{r}) into atomic densities using \\begin{equation} \\rho _ A(\\mathbf{r}) = w _ A(\\mathbf{r}) \\rho(\\mathbf{r}) \\end{equation} where w _ A(\\mathbf{r}) w _ A(\\mathbf{r}) is the sharing function belonging to atom A A . The sharing function is calculated from the spherically averaged isolated atom densities \\rho^\\textrm{isolated} \\rho^\\textrm{isolated} as \\begin{equation} w _ A(\\mathbf{r}) = \\frac{\\rho^\\textrm{isolated} _ A (\\mathbf{r})}{\\sum _ A \\rho^\\textrm{isolated} _ A (\\mathbf{r})} \\textrm{,} \\end{equation} where each \\rho^\\textrm{isolated} _ A \\rho^\\textrm{isolated} _ A is centred at the position \\mathbf{R} _ A \\mathbf{R} _ A of the nucleus of A A . The electronic charge attributed to atom A A is the integral \\begin{equation} N _ A = \\int \\mathrm{d} \\mathbf{r} \\rho _ A(\\mathbf{r}) \\textrm{,} \\end{equation} from which the total charge is obtained as \\begin{equation} q _ A = Z' _ A - N _ A \\textrm{.} \\end{equation} Other quantities, such as the volume of the bonded atom is calculated from the integral \\begin{equation} V _ A = \\int \\mathrm{d} \\mathbf{r} \\rho _ A(\\mathbf{r}) |\\mathbf{r} - \\mathbf{R} _ A|^3 \\textrm{,} \\end{equation} which are useful in other methods, such as the many-body and XDM ispersion schemes . The CASTEP implementation Similarly to the Mulliken population analysis, the ground state electron density of isolated atoms of every specie are determined in the post-processing step, using the same pseudopotential and calculation parameters as the main calculation. CASTEP keywords To switch on the Hirshfeld partitioning scheme, add CALCULATE_HIRSHFELD : TRUE to the .param file. This provides a basic analysis of the Hirshfeld charges. More information, such as atomic volumes, can be gained when using IPRINT : 2 or higher.","title":"Population analysis"},{"location":"documentation/Groundstate/population_analysis/#population-analysis","text":"At the end of a single point calculation, the ground state electron density is obtained. The electrons are distributed such that the total energy functional is minimised, meaning that they do not belong to individual atoms anymore. However, it is often useful as well as insightful to partition the total electron density to atomic or bond contributions. While such population analyses have no direct connection to experimental observables, they provide a chemical interpretation of possible charge transfer within the system. There are many flavours of charge partitioning, of which CASTEP can perform the Mulliken population analysis (see also here , here and here ) and the Hirshfeld definition .","title":"Population analysis"},{"location":"documentation/Groundstate/population_analysis/#mulliken-population-analysis","text":"The total number of electrons N N of a quantum mechanical system can be found by evaluating the sum \\begin{equation} N = \\sum _ \\mu (\\mathbf{P} \\mathbf{S}) _ {\\mu\\mu} \\end{equation} where \\mathbf{P} \\mathbf{P} and \\mathbf{S} \\mathbf{S} are the density and overlap matrices expressed in a suitable basis set \\boldsymbol{\\chi} \\boldsymbol{\\chi} , respectively. The overlap matrix elements are obtained as \\begin{equation} S _ {\\mu\\nu} = \\langle \\chi _ \\mu | \\chi _ \\nu \\rangle \\textrm{.} \\end{equation} The density matrix results from evaluating the density operator using the basis set \\begin{equation} P _ {\\mu\\nu} = \\langle \\chi _ \\mu | \\hat{P} | \\chi _ \\nu \\rangle \\end{equation} where the single-particle density operator is expressed in terms of the single-particle wavefunctions \\psi _ i \\psi _ i and the corresponding occupancies f _ i f _ i as \\begin{equation} \\hat{P} = \\sum _ i f _ i \\; |\\psi _ i \\rangle \\langle \\psi _ i | \\textrm{,} \\end{equation} therefore \\begin{equation} P _ {\\mu\\nu} = \\sum _ i f _ i \\; \\langle \\chi _ \\mu | \\psi _ i \\rangle \\langle \\psi _ i | \\chi _ \\nu \\rangle \\textrm{.} \\end{equation} If the basis set \\boldsymbol{\\chi} \\boldsymbol{\\chi} is local (i.e. functions with compact support), individual terms (\\mathbf{P} \\mathbf{S}) _ {\\mu\\mu} (\\mathbf{P} \\mathbf{S}) _ {\\mu\\mu} in the total charge expression may be associated with the spatial region corresponding to the individual basis function \\chi _ \\mu \\chi _ \\mu . If these basis functions are centred on atoms, the contributions belonging to a particular atom A A are defined as the charge of A A : \\begin{equation} N _ A = \\sum _ {\\mu \\in A} (\\mathbf{P} \\mathbf{S}) _ {\\mu\\mu} \\textrm{.} \\end{equation} Conveniently, the off-diagonal elements of \\mathbf{P} \\mathbf{S} \\mathbf{P} \\mathbf{S} are partitioned into bond contributions between atoms A A and B B as \\begin{equation} N _ {AB} = \\sum _ {\\mu \\in A} \\sum _ {\\nu \\in B} (\\mathbf{P} \\mathbf{S}) _ {\\mu\\nu} \\textrm{.} \\end{equation} To assign a charge to an atom, \\begin{equation} q _ A = Z' _ A - N _ A \\end{equation} is calculated, where Z' Z' is the pseudoatom nuclear charge.","title":"Mulliken population analysis"},{"location":"documentation/Groundstate/population_analysis/#the-castep-implementation","text":"In CASTEP, the solution of the electronic problem results in a set of Kohn-Sham orbitals \\psi _ i \\psi _ i , which are expressed in terms of plane-wave functions. Plane-waves are non-local, therefore not directly suitable for Mulliken population analysis. In order to obtain a suitable local basis, CASTEP solves the electronic problem of the isolated atom for each atomic specie present in the system, resulting in a set of atomic orbitals \\chi _ \\mu \\chi _ \\mu . Note that for this set of calculations, the same calculation settings (e.g. electronic cutoff and pseudopotentials) are used. With the atomic orbitals determined, the Mulliken population analysis can be performed by calculating the projections \\langle \\chi _ \\mu | \\psi _ i \\rangle \\langle \\chi _ \\mu | \\psi _ i \\rangle .","title":"The CASTEP implementation"},{"location":"documentation/Groundstate/population_analysis/#castep-keywords","text":"The default behaviour is to compute the population analysis on completion of most tasks that determine the ground state electron density. Mulliken population analysis can be turned off by adding POPN_CALCULATE : FALSE to the .param file. The bond population analysis is computed between all atoms which are closer than a spatial cutoff (3 \u212b by default), which may be controlled using the .param keyword POPN_BOND_CUTOFF , for example POPN_BOND_CUTOFF : 4.0 to set the cutoff to 4 \u212b. To control the verbosity of the population analysis output, POPN_WRITE : ENHANCED which is the default setting, writes individual orbital as well as atomic and bond populations; POPN_WRITE : MINIMAL only writes atomic and bond populations; POPN_WRITE : NONE only writes bond populations. The .cell block SPECIES_LCAO_STATES controls the number of atomic orbitals, as specified by their main and angular quantum numbers, used for each atomic specie. By default, all valence states up to the next noble gas configuration are obtained and used in the population analysis, but these can be overridden, for example: %BLOCK SPECIES_LCAO_STATES H 3 %ENDBLOCK SPECIES_LCAO_STATES will use the 1s, 2s and 2p orbitals. Shallow core states, if explicitly treated as valance states, are included. For example, for atoms such as Na, where most pseudopotential definitions include shallow core states, 2s, 2p, 3s and 3p are all used in the population analysis.","title":"CASTEP keywords"},{"location":"documentation/Groundstate/population_analysis/#the-hirshfeld-partitioning-scheme","text":"The Hirshfeld population analysis partitions the total ground state electronic density \\rho(\\mathbf{r}) \\rho(\\mathbf{r}) into atomic densities using \\begin{equation} \\rho _ A(\\mathbf{r}) = w _ A(\\mathbf{r}) \\rho(\\mathbf{r}) \\end{equation} where w _ A(\\mathbf{r}) w _ A(\\mathbf{r}) is the sharing function belonging to atom A A . The sharing function is calculated from the spherically averaged isolated atom densities \\rho^\\textrm{isolated} \\rho^\\textrm{isolated} as \\begin{equation} w _ A(\\mathbf{r}) = \\frac{\\rho^\\textrm{isolated} _ A (\\mathbf{r})}{\\sum _ A \\rho^\\textrm{isolated} _ A (\\mathbf{r})} \\textrm{,} \\end{equation} where each \\rho^\\textrm{isolated} _ A \\rho^\\textrm{isolated} _ A is centred at the position \\mathbf{R} _ A \\mathbf{R} _ A of the nucleus of A A . The electronic charge attributed to atom A A is the integral \\begin{equation} N _ A = \\int \\mathrm{d} \\mathbf{r} \\rho _ A(\\mathbf{r}) \\textrm{,} \\end{equation} from which the total charge is obtained as \\begin{equation} q _ A = Z' _ A - N _ A \\textrm{.} \\end{equation} Other quantities, such as the volume of the bonded atom is calculated from the integral \\begin{equation} V _ A = \\int \\mathrm{d} \\mathbf{r} \\rho _ A(\\mathbf{r}) |\\mathbf{r} - \\mathbf{R} _ A|^3 \\textrm{,} \\end{equation} which are useful in other methods, such as the many-body and XDM ispersion schemes .","title":"The Hirshfeld partitioning scheme"},{"location":"documentation/Groundstate/population_analysis/#the-castep-implementation_1","text":"Similarly to the Mulliken population analysis, the ground state electron density of isolated atoms of every specie are determined in the post-processing step, using the same pseudopotential and calculation parameters as the main calculation.","title":"The CASTEP implementation"},{"location":"documentation/Groundstate/population_analysis/#castep-keywords_1","text":"To switch on the Hirshfeld partitioning scheme, add CALCULATE_HIRSHFELD : TRUE to the .param file. This provides a basic analysis of the Hirshfeld charges. More information, such as atomic volumes, can be gained when using IPRINT : 2 or higher.","title":"CASTEP keywords"},{"location":"documentation/Groundstate/soc/","text":"keywords For a calculation of a non-spin polarised system with spin orbit coupling (e.g. GaAs) the following keywords should be set in the param file spin_treatment : vector spin_orbit_coupling : true spin_polarised : false relativistic_treatment : dirac If the system has a spin density (e.g. a ferromagnet or antiferromagnet) then the following keywords should be set in the para file spin_treatment : vector spin_orbit_coupling : true spin_polarised : true relativistic_treatment : dirac As the spin-orbit coupling is transmitted via the pseudopotential is is necessary to use j-dependent pseudopotentials. These can be read from file (UPF or uspso) or generated on the fly. At the moment the SOC19 set of OTFG norm-conserving potentials are suitable. These can be specified with the following block in the cell file ``` %block species_pot SOC19 %endblock species_pot Limitations","title":"Spin Orbit Coupling"},{"location":"documentation/Groundstate/soc/#keywords","text":"For a calculation of a non-spin polarised system with spin orbit coupling (e.g. GaAs) the following keywords should be set in the param file spin_treatment : vector spin_orbit_coupling : true spin_polarised : false relativistic_treatment : dirac If the system has a spin density (e.g. a ferromagnet or antiferromagnet) then the following keywords should be set in the para file spin_treatment : vector spin_orbit_coupling : true spin_polarised : true relativistic_treatment : dirac As the spin-orbit coupling is transmitted via the pseudopotential is is necessary to use j-dependent pseudopotentials. These can be read from file (UPF or uspso) or generated on the fly. At the moment the SOC19 set of OTFG norm-conserving potentials are suitable. These can be specified with the following block in the cell file ``` %block species_pot SOC19 %endblock species_pot","title":"keywords"},{"location":"documentation/Groundstate/soc/#limitations","text":"","title":"Limitations"},{"location":"documentation/Groundstate/spin_constraints/","text":"Introduction Spin constraints allow you to \u2018fix\u2019 the spins within DFT by adding an energy penalty to states which do not obey the constraint. These change the minimum energy state from being the normal ground state to only those which have the target spin. Theory Energy Penalty Function The easiest constraint is to fix the vector direction of the spin on a target atom. The energy penalty has the form: E_\\text{con} = \\lambda\\left(|\\mathbf{M}_I| - \\mathbf{e}_I \\cdot \\mathbf{M}_I\\right) \\geq 0 E_\\text{con} = \\lambda\\left(|\\mathbf{M}_I| - \\mathbf{e}_I \\cdot \\mathbf{M}_I\\right) \\geq 0 (eq1), where is the penalty constant, \\mathbf{M}_I \\mathbf{M}_I is the magnetic moment of atom I I , defined by \\mathbf{M}_I = \\int_\\Omega \\mathbf{m}(\\mathbf{r}) F_I(\\mathbf{r}) d^3r \\mathbf{M}_I = \\int_\\Omega \\mathbf{m}(\\mathbf{r}) F_I(\\mathbf{r}) d^3r where m(r) m(r) is the magnetization of the electrons at r r , and F_I(r) F_I(r) is a function approximating the electronic density of the atom I I . This integral sums up the total magnetic moments in a region around the atom. Eq (1) goes to zero as \\mathbf{M}_I \\mathbf{M}_I goes to \\mathbf{e}_I \\mathbf{e}_I and it is positive otherwise, so this leaves the target state unchanged and increases the energy of other states. The potential that arises from this can be found by taking the derivative of (1) with respect to the density: V_\\text{con}(\\mathbf{r}) = \\lambda F_I(\\mathbf{r}) \\left[\\left(\\frac{\\mathbf{M}_I}{|\\mathbf{M}_I|} - \\mathbf{e}_I \\right) \\cdot \\sigma\\ \\right] V_\\text{con}(\\mathbf{r}) = \\lambda F_I(\\mathbf{r}) \\left[\\left(\\frac{\\mathbf{M}_I}{|\\mathbf{M}_I|} - \\mathbf{e}_I \\right) \\cdot \\sigma\\ \\right] This is a local potential that pushes the density towards the constrained state. The strength of this \u201cpush\u201d is changed by the penalty constant . Due to the factor (the spin operator), the potential only has components in the spin space and tries to rotate the direction of spin, but not change the magnitude. Energy Penalty Constant The energy penalty constant ( \\lambda \\lambda ) must be large enough to overcome any natural features of the energy landscape. That is, it must be big enough to make the target minimum be the actual minimum of the system. On the other hand, making this value too big causes the numerics to become difficult to solve. CASTEP is built to solve things that act like physical systems and various parameters have been tuned to make it fast at this. Values that are too big, push the system away from being like a physical system and make it take a very long time to converge. There are a few tricks that we can play to speed this up. The first is to start with a low value of the \\lambda \\lambda and then increase it gradually. We do this by starting with a very low value, waiting until the system is converged, and then checking if the constraints are actually fulfilled (ie \\mathbf{M}_I = \\mathbf{e}_I \\mathbf{M}_I = \\mathbf{e}_I . If not, we double \\lambda \\lambda and converge again. We repeat this until the constraint is obeyed. Using Magnetic Constraints To apply a constraint to an atom, you must specify the spin in the cell file and add the extra tag FIX_SPIN for each atom on which you want to apply a constraint to block positions_frac or positions_abs in cell: %block positions_frac Fe 0.0 0.0 0.0 spin 2 0 0 FIX_SPIN Ni 0.5 0.5 0.5 spin 1 1 0 Mn 0.3 0.4 0.0 %endblock positions_frac This will set the system up with two Fe atoms as follows: Element Initial Spin Spin Constraint Fe 2 0 0 Along 1 0 0 Ni 1 1 0 None Mn None None It will then do the procedure mentioned in the previous section, doubling \\lambda \\lambda to achieve the target constraints. You can only add FIX_SPIN to any atom that you have specified the spin for. Convergence Some of the magnetic states can be difficult to converge, as the penalty potential still does not end up looking like a physical system. This causes the calculation to take a huge number of steps to reach convergence (if it even gets there!) You almost certainly need to decrease the value of spin_mix_amp which has a default of 0.8 but should be much lower (eg 0.5 or even less) for many of these systems. Alternatively, you can use metals_method: EDFT which uses EDFT instead of density mixing and this can improve the convergence.","title":"Spin Constraints"},{"location":"documentation/Groundstate/spin_constraints/#introduction","text":"Spin constraints allow you to \u2018fix\u2019 the spins within DFT by adding an energy penalty to states which do not obey the constraint. These change the minimum energy state from being the normal ground state to only those which have the target spin.","title":"Introduction"},{"location":"documentation/Groundstate/spin_constraints/#theory","text":"","title":"Theory"},{"location":"documentation/Groundstate/spin_constraints/#energy-penalty-function","text":"The easiest constraint is to fix the vector direction of the spin on a target atom. The energy penalty has the form: E_\\text{con} = \\lambda\\left(|\\mathbf{M}_I| - \\mathbf{e}_I \\cdot \\mathbf{M}_I\\right) \\geq 0 E_\\text{con} = \\lambda\\left(|\\mathbf{M}_I| - \\mathbf{e}_I \\cdot \\mathbf{M}_I\\right) \\geq 0 (eq1), where is the penalty constant, \\mathbf{M}_I \\mathbf{M}_I is the magnetic moment of atom I I , defined by \\mathbf{M}_I = \\int_\\Omega \\mathbf{m}(\\mathbf{r}) F_I(\\mathbf{r}) d^3r \\mathbf{M}_I = \\int_\\Omega \\mathbf{m}(\\mathbf{r}) F_I(\\mathbf{r}) d^3r where m(r) m(r) is the magnetization of the electrons at r r , and F_I(r) F_I(r) is a function approximating the electronic density of the atom I I . This integral sums up the total magnetic moments in a region around the atom. Eq (1) goes to zero as \\mathbf{M}_I \\mathbf{M}_I goes to \\mathbf{e}_I \\mathbf{e}_I and it is positive otherwise, so this leaves the target state unchanged and increases the energy of other states. The potential that arises from this can be found by taking the derivative of (1) with respect to the density: V_\\text{con}(\\mathbf{r}) = \\lambda F_I(\\mathbf{r}) \\left[\\left(\\frac{\\mathbf{M}_I}{|\\mathbf{M}_I|} - \\mathbf{e}_I \\right) \\cdot \\sigma\\ \\right] V_\\text{con}(\\mathbf{r}) = \\lambda F_I(\\mathbf{r}) \\left[\\left(\\frac{\\mathbf{M}_I}{|\\mathbf{M}_I|} - \\mathbf{e}_I \\right) \\cdot \\sigma\\ \\right] This is a local potential that pushes the density towards the constrained state. The strength of this \u201cpush\u201d is changed by the penalty constant . Due to the factor (the spin operator), the potential only has components in the spin space and tries to rotate the direction of spin, but not change the magnitude.","title":"Energy Penalty Function"},{"location":"documentation/Groundstate/spin_constraints/#energy-penalty-constant","text":"The energy penalty constant ( \\lambda \\lambda ) must be large enough to overcome any natural features of the energy landscape. That is, it must be big enough to make the target minimum be the actual minimum of the system. On the other hand, making this value too big causes the numerics to become difficult to solve. CASTEP is built to solve things that act like physical systems and various parameters have been tuned to make it fast at this. Values that are too big, push the system away from being like a physical system and make it take a very long time to converge. There are a few tricks that we can play to speed this up. The first is to start with a low value of the \\lambda \\lambda and then increase it gradually. We do this by starting with a very low value, waiting until the system is converged, and then checking if the constraints are actually fulfilled (ie \\mathbf{M}_I = \\mathbf{e}_I \\mathbf{M}_I = \\mathbf{e}_I . If not, we double \\lambda \\lambda and converge again. We repeat this until the constraint is obeyed.","title":"Energy Penalty Constant"},{"location":"documentation/Groundstate/spin_constraints/#using-magnetic-constraints","text":"To apply a constraint to an atom, you must specify the spin in the cell file and add the extra tag FIX_SPIN for each atom on which you want to apply a constraint to block positions_frac or positions_abs in cell: %block positions_frac Fe 0.0 0.0 0.0 spin 2 0 0 FIX_SPIN Ni 0.5 0.5 0.5 spin 1 1 0 Mn 0.3 0.4 0.0 %endblock positions_frac This will set the system up with two Fe atoms as follows: Element Initial Spin Spin Constraint Fe 2 0 0 Along 1 0 0 Ni 1 1 0 None Mn None None It will then do the procedure mentioned in the previous section, doubling \\lambda \\lambda to achieve the target constraints. You can only add FIX_SPIN to any atom that you have specified the spin for.","title":"Using Magnetic Constraints"},{"location":"documentation/Groundstate/spin_constraints/#convergence","text":"Some of the magnetic states can be difficult to converge, as the penalty potential still does not end up looking like a physical system. This causes the calculation to take a huge number of steps to reach convergence (if it even gets there!) You almost certainly need to decrease the value of spin_mix_amp which has a default of 0.8 but should be much lower (eg 0.5 or even less) for many of these systems. Alternatively, you can use metals_method: EDFT which uses EDFT instead of density mixing and this can improve the convergence.","title":"Convergence"},{"location":"documentation/Groundstate/xc/","text":"","title":"Xc"},{"location":"documentation/Input_Files/cell_file/","text":"This is a detailed description of options for CASTEP's cell file. See the basic cell file page for an overview. This page has the most frequently-used cell file options, but for a full set use CASTEP's built-in help . There is also a concise table of cell keywords . The cell file is one of CASTEP's two main input files. It contains all of the information about the crystal lattice and the atomic positions, as well as additional information such as Brillouin zone sampling ('k-points'), pseudopotentials, cell symmetry, external pressure, constraints on motion of the atoms or cell, and atomic properties such as the mass of each species. The file itself is a free-format keyword-driven text file, consisting of keywords and blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. Most of the keywords and blocks are optional, but CASTEP requires two block entries: a block to specify the lattice, and another to specify the atomic elements and positions within the cell. At the very least, the cell lattice vectors and ionic positions must be specified. Reasonable defaults are chosen for anything else not specified. For the purposes of the following definitions, all variables represented by R R are defined to be real numbers, those represented by I I are defined to be integers and those represented by C C are characters. Cell Lattice Vectors The cell lattice vectors may be specified in Cartesian coordinates or in terms of the lattice vector magnitudes and the angles between them ( a, b, c, \\alpha, \\beta, \\gamma a, b, c, \\alpha, \\beta, \\gamma ). Only one of LATTICE_CART and LATTICE_ABC may occur in a cell definition file. The definitions of these keywords are as follows: %BLOCK LATTICE_CART [units] a_x a_y a_z b_x b_y b_z c_x c_y c_z %ENDBLOCK LATTICE_CART Here a_x is the x-component of the first lattice vector, \\mathbf{a} \\mathbf{a} , b_y b_y is the y-component of the second lattice vector, \\mathbf{b} \\mathbf{b} , etc. [units] specifies the units in which the lattice vectors are defined. If not present, the default is \u00c5. %BLOCK LATTICE_ABC [units] a b c alpha beta gamma %ENDBLOCK LATTICE_ABC Here a is the value of the lattice constant \\vert\\mathbf{a}\\vert \\vert\\mathbf{a}\\vert , gamma is the value of the cell angle \\gamma \\gamma (in degrees) etc. If the lattice is specified in this manner, the absolute orientation is arbitrary. In this case the orientation is defined by applying the following constraints: \\mathbf{a} \\mathbf{a} lies along the x-axis \\mathbf{b} \\mathbf{b} lies in the xy plane \\mathbf{c} \\mathbf{c} forms a right-handed set with \\mathbf{a} \\mathbf{a} and \\mathbf{b} \\mathbf{b} [units] specifies the units in which the lattice vector magnitudes are defined. If not present, the default is \u00c5. Angles should be specified in degrees. Ionic Positions The ionic positions may be specified in fractional coordinates relative to the lattice vectors of the unit cell, or in absolute coordinates. Only one of POSITIONS_FRAC and POSITIONS_ABS may occur in a cell definition file. %BLOCK POSITIONS_FRAC CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK END POSITIONS_FRAC The first entry on a line is the symbol of the species (chemical element). Alternatively, the atomic number may be given instead, in which case CASTEP will be look up for chemical symbol. A symbol can have a maximum of three characters. The first alphabetical characters identify the element, from which default values for atomic mass etc. The next three entries on a line in POSITIONS_FRAC are real numbers representing the position of the ion in fractions of the unit cell lattice vectors. If the optional flag SPIN is present on a line, this sets the spin polarisation ( N^\\uparrow-N^\\downarrow N^\\uparrow-N^\\downarrow ) of the atom for initialisation of the spin density; for non-collinear spin calculations, the vector spin is specified as three numbers. If this flag is not present a non-spin polarised state will be assumed. %BLOCK POSITIONS_ABS [units] CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK POSITIONS_ABS The first entry on a line is the symbol or atomic number of the ionic species, as for POSITIONS_FRAC . The next three entries are real numbers representing the position of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5. The optional flag SPIN is defined above under POSITIONS_FRAC . Brillouin Zone Sampling (k-points) (N.B. in the following section the keywords with the prefixes KPOINT_ and KPOINTS_ are synonymous. KPOINT_ is the preferred usage.) The k-points at which the Brillouin zone is to be sampled during a self consistent calculation to find the electronic ground state may be defined either by specifying a list of k-points or a Monkhorst-Pack grid in terms of the dimensions of the k-point mesh or a minimum k-point density. The origin of the Monkhorst-Pack grid may be offset by a vector from the origin of the Brillouin zone. If no k-points are specified, the default will be a Monkhorst-Pack grid with a maximum spacing of 0.1\u00c5 ^{-1} ^{-1} and no offset of the origin. The KPOINT_LIST , KPOINT_MP_GRID and KPOINT_MP_SPACING keywords are mutually exclusive. KPOINT_MP_OFFSET may be specified in combination with either KPOINT_MP_GRID or KPOINT_MP_SPACING . %BLOCK KPOINT_LIST \\begin{array}{cccc} R_{1i} R_{1j} R_{1k} R_{1w} R_{2i} R_{2j} R_{2k} R_{2w} ... %ENDBLOCK KPOINT_LIST The first three entries on a line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The final entry on a line is the weight of the k-point relative to the others specified. The sum of the weights must be equal to 1. KPOINT_MP_GRID I_i I_j I_k This specifies the dimensions of the Monkhorst-Pack grid requested in the directions of the reciprocal space lattice vectors. The generated grid will be I_i\\times I_j\\times I_k I_i\\times I_j\\times I_k ; any symmetries generated (or supplied) will be used to reduce this number, when computing the irreducible wedge. KPOINT_MP_SPACING R [units] The single entry is the maximum distance between k-points on the Monkhorst-Pack grid. The dimensions of the grid will be chosen such that the maximum separation of k-points is less than this. [units] specifies the units in which the k-point spacing is defined, although note that the actual units used are 2\\pi 2\\pi units . If not present, the default is ang-1 , such that the spacing is in 2\\pi \u00c5^{-1} 2\\pi \u00c5^{-1} . KPOINT_MP_OFFSET R_i R_j R_k This specifies the offset of the Monkhorst-Pack grid with respect to the origin of the Brillouin zone. The three entries are the offset in fractional coordinates relative to the reciprocal lattice vectors. The k-point set for performing spectral calculations can be specified in the same manner, using version of the keywords above with SPECTRAL_ prepended. The same restrictions regarding mutually exclusive keywords apply. For a non-self-consistent spectral calculation, the k-points may be defined along a path through reciprocal space or a list of k-points. %BLOCK SPECTRAL_KPOINT_PATH R_{1i} R_{1j} R_{1k} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK SPECTRAL_KPOINT_PATH The three numbers on each line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The k-points define a continuous sequence of straight line segments, unless the keyword BREAK appears on a separate line within the sequence of k-points. In this case the continuous path will end at the k-point immediately preceding the BREAK keyword and resume at the k-point immediately following. The path will be open unless the first and last point in the list are identical . The maximum spacing of the points sampled along each line segment is defined by the keyword SPECTRAL_KPOINT_PATH_SPACING (default value 0.1 \\times 2\\pi 0.1 \\times 2\\pi \u00c5 ^{-1} ^{-1} ). If necessary, the actual spacing used may be smaller than this in order to ensure that the length of the line segment is an integer multiple of the spacing between points on that segment. Alternatively, the k-point set for performing a band structure calculation can be specified in the same manner as the main k-point set, using version of the keywords above with BS_ prepended. The same restrictions regarding mutually exclusive keywords apply. In this case, the k-point weight in SPECTRAL_KPOINT_LIST is optional. If omitted, the weights for each k-point are assumed to be equal. For a phonon spectrum calculation, the k-points may be defined along a path through reciprocal space or a list of k-points, in the same manner as for a spectral calculation. The corresponding keywords are identical to those for the band structure specification with the initial SPECTRAL_ replaced by PHONON_ , e.g. PHONON_KPOINT_PATH , PHONON_KPOINT_PATH_SPACING and PHONON_KPOINT_LIST . The same restrictions regarding mutually exclusive keywords apply. The block keyword PHONON_GAMMA_DIRECTIONS specifies the directions in which the gamma point will be approached when calculating the non-analytic terms of the LO/TO splitting. Each line in this block will consist of a 3-vector specifying a direction in the basis of reciprocal lattice vectors. If this keyword is not present, the default will be a single vector determined as follows: If the gamma point is q_i = 0 q_i = 0 and there is a successor kpoint q_{i+1} q_{i+1} in the list, then it is q_{i+1} q_{i+1} . Otherwise if the gamma point is q_i =0 q_i =0 and there is a predecessor kpoint q_{i-1} q_{i-1} in the list then it is q_{i-1} q_{i-1} . Otherwise (i.e. a Gamma point only calculation) the a-axis of the reciprocal cell. For backwards compatibility the keywords beginning BS_ and OPTICS_ are synonyms for SPECTRAL_KPOINT_ and similarly those beginning. Cell Symmetry If no symmetry is specified in the cell definition file, the default is for no symmetry to be applied. SYMMETRY_GENERATE If this keyword is present in the cell, the highest symmetry group that applies to the structure of the cell will be found and the corresponding symmetry operations generated. SYMMETRY_TOL R [units] This parameter is the tolerance within which symmetry will be considered to be satisfied. If an ion is found within this distance of its symmetric position, the symmetry will be considered to be satisfied. [units] specifies the units in which the tolerance is defined. If not present, the default is \u00c5. Alternatively, the symmetry operations may be provided directly in a SYMMETRY_OPS block. The symmetry of the cell is represented as a series of symmetry operations under which the unit cell is invariant. Each operation is represented as a 3\\times 3 3\\times 3 array. %BLOCK SYMMETRY_OPS R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 ... %ENDBLOCK SYMMETRY_OPS Each of the first three lines contains 3 entries representing a row of a 3\\times3 3\\times3 array. These represent one symmetry rotation. The three entries on the following line contain the translation associated with this rotation. Constraints The movement of ions or the unit cell during a relaxation or molecular dynamics run may be constrained. The constraints on the ionic motion may by specified as a set of linear constraints. Each constraint is specified as a series of coefficients a_{ijk} a_{ijk} such that: $$ \\sum_{k=1}^{\\tt N_\\mathrm{species}} \\quad \\sum_{j=1}^{\\mathrm{N_\\mathrm{ions}}(k)} \\quad \\sum_{i=1}^{3} a_{ijk} \\verb#ionic_positions(i,j,k)# = constant $$ where \\mathrm{N_\\mathrm{ions}}(k) \\mathrm{N_\\mathrm{ions}}(k) is the number of ions in species k k . The change in the shape of the unit cell may also be constrained using the keyword CELL_CONSTRAINTS . The special case of constraining the centre of mass of the ions to remain fixed is supported by a logical keyword FIX_COM . Also all ionic positions or cell parameters may be fixed by specifying the keywords FIX_ALL_IONS or FIX_ALL_CELL to be TRUE respectively. If no ionic or cell constraints are specified in the cell definition file, the default is to fix the centre of mass. %BLOCK IONIC_CONSTRAINTS I_1 CCC_{1s} I_{1s} I_{n1} R_{1i} R_{1j} R_{1k} I_2 CCC_{2s} I_{2s} I_{n2} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK IONIC_CONSTRAINTS The first element on each line is an integer specifying the number of the constraint being specified. The second entry is either the symbol or atomic number of the species of the ion to which this constraint applies. The third element is the number of the ion within the species. The ordering of the ions in a species is the order in which they appear in the POSITIONS_FRAC or POSITIONS_ABS block in the cell definition file. The final three numbers are real numbers representing the coefficients of the Cartesian coordinates of the ionic position in the constraint sum. All coefficients in the sum not explicitly specified will be zero. On reading this data, the matrix of ionic constraints will be orthogonalised. %BLOCK CELL_CONSTRAINTS I_a I_b I_c I_alpha I_beta I_gamma %ENDBLOCK CELL_CONSTRAINTS The first three entries relate to the magnitude of the three lattice vectors a,b,c a,b,c and the second set of three entries to the angles \\alpha, \\beta, \\gamma \\alpha, \\beta, \\gamma . If the value of the entry corresponding to a magnitude or angle is zero, this quantity will remain fixed. If two or three entries contain the same integer, the corresponding quantities will be constrained to have the same value. If a positive integer greater than 0 occurs in entries 1 through 3 the same integer cannot occur in entries 4 through 6 as this would imply that a vector length and angle must have the same value. Species Characteristics The mass of a species, the pseudopotential which represents the ion and the size of the LCAO basis set used for population anslsyis may be specified in the cell definition file. %BLOCK SPECIES_MASS [units] CCC_1 I_1 R_1 CCC_2 I_2 R_2 ... %ENDBLOCK SPECIES_MASS [units] specifies the units in which the masses are defined. If not present, the default is atomic mass units. The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the mass of that species. Not all species need appear in the SPECIES_MASS block, any not present will assume the default mass for that species. If the initial alphabetical symbol specified for a species is not a standard element symbol in the periodic table, the mass of the species must be specified. %BLOCK SPECIES_POT CCC_1 I_1 <filename> CCC_2 I_2 <filename> ... %ENDBLOCK SPECIES_POT The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the filename of the file containing the definition of the pseudopotential representing the ionic species. The file to which this refers may be a definition of the parameters of the pseudopotential which is to be generated at runtime, or an old-style pseudopotential definition containing the data for the pseudopotential. Not all species need appear in the SPECIES_POT block. If a pseudopotential is not specified, the default pseudopotential parameters will be used to generate a pseudopotential for the element specified. If the initial alphabetical characters of a species label is not a standard element symbol in the periodic table, the potential for the species must be specified. The charge on the ion for each species will be derived from the pseudopotential corresponding to that ion. %BLOCK SPECIES_LCAO_STATES CCC_1 I_1 I_{B1} CCC_2 I_2 I_{B2} ... %ENDBLOCK SPECIES_LCAO_STATES The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second number is the number of angular momentum channels to use in the LCAO basis set for the species when performing population analysis. For example, to use the 2s and 2p states for C (The 1s state is a core state) this should be 2. By default, the number of states will be the appropriate number to complete the valence shell to the next noble gas. If shallow core states are excluded from a pseudopotential, the value of SPECIES_LCAO_STATES for that species should be included in the cell file to ensure a meaningful basis set is used. External Pressure An external pressure may be applied to the unit cell by specifying a pressure tensor. %BLOCK EXTERNAL_PRESSURE [units] R_{xx} R_{xy} R_{xz} R_{yy} R_{yz} R_{zz} %ENDBLOCK EXTERNAL_PRESSURE [units] specifies the units in which the pressure is defined. If not present, the default is GPa. Entry R_{xx} R_{xx} is the xx xx -component of the pressure, R_{xy} R_{xy} the xy xy -component etc. The default is to apply no external pressure. Ionic Velocities The initial ionic velocities may be specified in Cartesian coordinates in a cell definition file. %BLOCK IONIC_VELOCITIES [units] CCC_1 V_{1x} V_{1y} V_{1z} CCC_2 V_{2x} V_{2y} V_{2z} ... %ENDBLOCK IONIC_VELOCITIES The first entry on a line is the chemical symbol (or atomic number) of the ionic species. The correct symbol will be looked up for the atomic species if the atomic number is specified. A symbol can have a maximum of three characters. The next three entries are real numbers representing the velocity of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5/ps. If this keyword is not present and a molecular dynamics calculation is performed, the ionic velocities will be randomly initialised with the appropriate temperature.","title":"cell file"},{"location":"documentation/Input_Files/cell_file/#cell-lattice-vectors","text":"The cell lattice vectors may be specified in Cartesian coordinates or in terms of the lattice vector magnitudes and the angles between them ( a, b, c, \\alpha, \\beta, \\gamma a, b, c, \\alpha, \\beta, \\gamma ). Only one of LATTICE_CART and LATTICE_ABC may occur in a cell definition file. The definitions of these keywords are as follows: %BLOCK LATTICE_CART [units] a_x a_y a_z b_x b_y b_z c_x c_y c_z %ENDBLOCK LATTICE_CART Here a_x is the x-component of the first lattice vector, \\mathbf{a} \\mathbf{a} , b_y b_y is the y-component of the second lattice vector, \\mathbf{b} \\mathbf{b} , etc. [units] specifies the units in which the lattice vectors are defined. If not present, the default is \u00c5. %BLOCK LATTICE_ABC [units] a b c alpha beta gamma %ENDBLOCK LATTICE_ABC Here a is the value of the lattice constant \\vert\\mathbf{a}\\vert \\vert\\mathbf{a}\\vert , gamma is the value of the cell angle \\gamma \\gamma (in degrees) etc. If the lattice is specified in this manner, the absolute orientation is arbitrary. In this case the orientation is defined by applying the following constraints: \\mathbf{a} \\mathbf{a} lies along the x-axis \\mathbf{b} \\mathbf{b} lies in the xy plane \\mathbf{c} \\mathbf{c} forms a right-handed set with \\mathbf{a} \\mathbf{a} and \\mathbf{b} \\mathbf{b} [units] specifies the units in which the lattice vector magnitudes are defined. If not present, the default is \u00c5. Angles should be specified in degrees.","title":"Cell Lattice Vectors"},{"location":"documentation/Input_Files/cell_file/#ionic-positions","text":"The ionic positions may be specified in fractional coordinates relative to the lattice vectors of the unit cell, or in absolute coordinates. Only one of POSITIONS_FRAC and POSITIONS_ABS may occur in a cell definition file. %BLOCK POSITIONS_FRAC CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK END POSITIONS_FRAC The first entry on a line is the symbol of the species (chemical element). Alternatively, the atomic number may be given instead, in which case CASTEP will be look up for chemical symbol. A symbol can have a maximum of three characters. The first alphabetical characters identify the element, from which default values for atomic mass etc. The next three entries on a line in POSITIONS_FRAC are real numbers representing the position of the ion in fractions of the unit cell lattice vectors. If the optional flag SPIN is present on a line, this sets the spin polarisation ( N^\\uparrow-N^\\downarrow N^\\uparrow-N^\\downarrow ) of the atom for initialisation of the spin density; for non-collinear spin calculations, the vector spin is specified as three numbers. If this flag is not present a non-spin polarised state will be assumed. %BLOCK POSITIONS_ABS [units] CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK POSITIONS_ABS The first entry on a line is the symbol or atomic number of the ionic species, as for POSITIONS_FRAC . The next three entries are real numbers representing the position of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5. The optional flag SPIN is defined above under POSITIONS_FRAC .","title":"Ionic Positions"},{"location":"documentation/Input_Files/cell_file/#brillouin-zone-sampling-k-points","text":"(N.B. in the following section the keywords with the prefixes KPOINT_ and KPOINTS_ are synonymous. KPOINT_ is the preferred usage.) The k-points at which the Brillouin zone is to be sampled during a self consistent calculation to find the electronic ground state may be defined either by specifying a list of k-points or a Monkhorst-Pack grid in terms of the dimensions of the k-point mesh or a minimum k-point density. The origin of the Monkhorst-Pack grid may be offset by a vector from the origin of the Brillouin zone. If no k-points are specified, the default will be a Monkhorst-Pack grid with a maximum spacing of 0.1\u00c5 ^{-1} ^{-1} and no offset of the origin. The KPOINT_LIST , KPOINT_MP_GRID and KPOINT_MP_SPACING keywords are mutually exclusive. KPOINT_MP_OFFSET may be specified in combination with either KPOINT_MP_GRID or KPOINT_MP_SPACING . %BLOCK KPOINT_LIST \\begin{array}{cccc} R_{1i} R_{1j} R_{1k} R_{1w} R_{2i} R_{2j} R_{2k} R_{2w} ... %ENDBLOCK KPOINT_LIST The first three entries on a line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The final entry on a line is the weight of the k-point relative to the others specified. The sum of the weights must be equal to 1. KPOINT_MP_GRID I_i I_j I_k This specifies the dimensions of the Monkhorst-Pack grid requested in the directions of the reciprocal space lattice vectors. The generated grid will be I_i\\times I_j\\times I_k I_i\\times I_j\\times I_k ; any symmetries generated (or supplied) will be used to reduce this number, when computing the irreducible wedge. KPOINT_MP_SPACING R [units] The single entry is the maximum distance between k-points on the Monkhorst-Pack grid. The dimensions of the grid will be chosen such that the maximum separation of k-points is less than this. [units] specifies the units in which the k-point spacing is defined, although note that the actual units used are 2\\pi 2\\pi units . If not present, the default is ang-1 , such that the spacing is in 2\\pi \u00c5^{-1} 2\\pi \u00c5^{-1} . KPOINT_MP_OFFSET R_i R_j R_k This specifies the offset of the Monkhorst-Pack grid with respect to the origin of the Brillouin zone. The three entries are the offset in fractional coordinates relative to the reciprocal lattice vectors. The k-point set for performing spectral calculations can be specified in the same manner, using version of the keywords above with SPECTRAL_ prepended. The same restrictions regarding mutually exclusive keywords apply. For a non-self-consistent spectral calculation, the k-points may be defined along a path through reciprocal space or a list of k-points. %BLOCK SPECTRAL_KPOINT_PATH R_{1i} R_{1j} R_{1k} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK SPECTRAL_KPOINT_PATH The three numbers on each line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The k-points define a continuous sequence of straight line segments, unless the keyword BREAK appears on a separate line within the sequence of k-points. In this case the continuous path will end at the k-point immediately preceding the BREAK keyword and resume at the k-point immediately following. The path will be open unless the first and last point in the list are identical . The maximum spacing of the points sampled along each line segment is defined by the keyword SPECTRAL_KPOINT_PATH_SPACING (default value 0.1 \\times 2\\pi 0.1 \\times 2\\pi \u00c5 ^{-1} ^{-1} ). If necessary, the actual spacing used may be smaller than this in order to ensure that the length of the line segment is an integer multiple of the spacing between points on that segment. Alternatively, the k-point set for performing a band structure calculation can be specified in the same manner as the main k-point set, using version of the keywords above with BS_ prepended. The same restrictions regarding mutually exclusive keywords apply. In this case, the k-point weight in SPECTRAL_KPOINT_LIST is optional. If omitted, the weights for each k-point are assumed to be equal. For a phonon spectrum calculation, the k-points may be defined along a path through reciprocal space or a list of k-points, in the same manner as for a spectral calculation. The corresponding keywords are identical to those for the band structure specification with the initial SPECTRAL_ replaced by PHONON_ , e.g. PHONON_KPOINT_PATH , PHONON_KPOINT_PATH_SPACING and PHONON_KPOINT_LIST . The same restrictions regarding mutually exclusive keywords apply. The block keyword PHONON_GAMMA_DIRECTIONS specifies the directions in which the gamma point will be approached when calculating the non-analytic terms of the LO/TO splitting. Each line in this block will consist of a 3-vector specifying a direction in the basis of reciprocal lattice vectors. If this keyword is not present, the default will be a single vector determined as follows: If the gamma point is q_i = 0 q_i = 0 and there is a successor kpoint q_{i+1} q_{i+1} in the list, then it is q_{i+1} q_{i+1} . Otherwise if the gamma point is q_i =0 q_i =0 and there is a predecessor kpoint q_{i-1} q_{i-1} in the list then it is q_{i-1} q_{i-1} . Otherwise (i.e. a Gamma point only calculation) the a-axis of the reciprocal cell. For backwards compatibility the keywords beginning BS_ and OPTICS_ are synonyms for SPECTRAL_KPOINT_ and similarly those beginning.","title":"Brillouin Zone Sampling (k-points)"},{"location":"documentation/Input_Files/cell_file/#cell-symmetry","text":"If no symmetry is specified in the cell definition file, the default is for no symmetry to be applied. SYMMETRY_GENERATE If this keyword is present in the cell, the highest symmetry group that applies to the structure of the cell will be found and the corresponding symmetry operations generated. SYMMETRY_TOL R [units] This parameter is the tolerance within which symmetry will be considered to be satisfied. If an ion is found within this distance of its symmetric position, the symmetry will be considered to be satisfied. [units] specifies the units in which the tolerance is defined. If not present, the default is \u00c5. Alternatively, the symmetry operations may be provided directly in a SYMMETRY_OPS block. The symmetry of the cell is represented as a series of symmetry operations under which the unit cell is invariant. Each operation is represented as a 3\\times 3 3\\times 3 array. %BLOCK SYMMETRY_OPS R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 ... %ENDBLOCK SYMMETRY_OPS Each of the first three lines contains 3 entries representing a row of a 3\\times3 3\\times3 array. These represent one symmetry rotation. The three entries on the following line contain the translation associated with this rotation.","title":"Cell Symmetry"},{"location":"documentation/Input_Files/cell_file/#constraints","text":"The movement of ions or the unit cell during a relaxation or molecular dynamics run may be constrained. The constraints on the ionic motion may by specified as a set of linear constraints. Each constraint is specified as a series of coefficients a_{ijk} a_{ijk} such that: $$ \\sum_{k=1}^{\\tt N_\\mathrm{species}} \\quad \\sum_{j=1}^{\\mathrm{N_\\mathrm{ions}}(k)} \\quad \\sum_{i=1}^{3} a_{ijk} \\verb#ionic_positions(i,j,k)# = constant $$ where \\mathrm{N_\\mathrm{ions}}(k) \\mathrm{N_\\mathrm{ions}}(k) is the number of ions in species k k . The change in the shape of the unit cell may also be constrained using the keyword CELL_CONSTRAINTS . The special case of constraining the centre of mass of the ions to remain fixed is supported by a logical keyword FIX_COM . Also all ionic positions or cell parameters may be fixed by specifying the keywords FIX_ALL_IONS or FIX_ALL_CELL to be TRUE respectively. If no ionic or cell constraints are specified in the cell definition file, the default is to fix the centre of mass. %BLOCK IONIC_CONSTRAINTS I_1 CCC_{1s} I_{1s} I_{n1} R_{1i} R_{1j} R_{1k} I_2 CCC_{2s} I_{2s} I_{n2} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK IONIC_CONSTRAINTS The first element on each line is an integer specifying the number of the constraint being specified. The second entry is either the symbol or atomic number of the species of the ion to which this constraint applies. The third element is the number of the ion within the species. The ordering of the ions in a species is the order in which they appear in the POSITIONS_FRAC or POSITIONS_ABS block in the cell definition file. The final three numbers are real numbers representing the coefficients of the Cartesian coordinates of the ionic position in the constraint sum. All coefficients in the sum not explicitly specified will be zero. On reading this data, the matrix of ionic constraints will be orthogonalised. %BLOCK CELL_CONSTRAINTS I_a I_b I_c I_alpha I_beta I_gamma %ENDBLOCK CELL_CONSTRAINTS The first three entries relate to the magnitude of the three lattice vectors a,b,c a,b,c and the second set of three entries to the angles \\alpha, \\beta, \\gamma \\alpha, \\beta, \\gamma . If the value of the entry corresponding to a magnitude or angle is zero, this quantity will remain fixed. If two or three entries contain the same integer, the corresponding quantities will be constrained to have the same value. If a positive integer greater than 0 occurs in entries 1 through 3 the same integer cannot occur in entries 4 through 6 as this would imply that a vector length and angle must have the same value.","title":"Constraints"},{"location":"documentation/Input_Files/cell_file/#species-characteristics","text":"The mass of a species, the pseudopotential which represents the ion and the size of the LCAO basis set used for population anslsyis may be specified in the cell definition file. %BLOCK SPECIES_MASS [units] CCC_1 I_1 R_1 CCC_2 I_2 R_2 ... %ENDBLOCK SPECIES_MASS [units] specifies the units in which the masses are defined. If not present, the default is atomic mass units. The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the mass of that species. Not all species need appear in the SPECIES_MASS block, any not present will assume the default mass for that species. If the initial alphabetical symbol specified for a species is not a standard element symbol in the periodic table, the mass of the species must be specified. %BLOCK SPECIES_POT CCC_1 I_1 <filename> CCC_2 I_2 <filename> ... %ENDBLOCK SPECIES_POT The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the filename of the file containing the definition of the pseudopotential representing the ionic species. The file to which this refers may be a definition of the parameters of the pseudopotential which is to be generated at runtime, or an old-style pseudopotential definition containing the data for the pseudopotential. Not all species need appear in the SPECIES_POT block. If a pseudopotential is not specified, the default pseudopotential parameters will be used to generate a pseudopotential for the element specified. If the initial alphabetical characters of a species label is not a standard element symbol in the periodic table, the potential for the species must be specified. The charge on the ion for each species will be derived from the pseudopotential corresponding to that ion. %BLOCK SPECIES_LCAO_STATES CCC_1 I_1 I_{B1} CCC_2 I_2 I_{B2} ... %ENDBLOCK SPECIES_LCAO_STATES The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second number is the number of angular momentum channels to use in the LCAO basis set for the species when performing population analysis. For example, to use the 2s and 2p states for C (The 1s state is a core state) this should be 2. By default, the number of states will be the appropriate number to complete the valence shell to the next noble gas. If shallow core states are excluded from a pseudopotential, the value of SPECIES_LCAO_STATES for that species should be included in the cell file to ensure a meaningful basis set is used.","title":"Species Characteristics"},{"location":"documentation/Input_Files/cell_file/#external-pressure","text":"An external pressure may be applied to the unit cell by specifying a pressure tensor. %BLOCK EXTERNAL_PRESSURE [units] R_{xx} R_{xy} R_{xz} R_{yy} R_{yz} R_{zz} %ENDBLOCK EXTERNAL_PRESSURE [units] specifies the units in which the pressure is defined. If not present, the default is GPa. Entry R_{xx} R_{xx} is the xx xx -component of the pressure, R_{xy} R_{xy} the xy xy -component etc. The default is to apply no external pressure.","title":"External Pressure"},{"location":"documentation/Input_Files/cell_file/#ionic-velocities","text":"The initial ionic velocities may be specified in Cartesian coordinates in a cell definition file. %BLOCK IONIC_VELOCITIES [units] CCC_1 V_{1x} V_{1y} V_{1z} CCC_2 V_{2x} V_{2y} V_{2z} ... %ENDBLOCK IONIC_VELOCITIES The first entry on a line is the chemical symbol (or atomic number) of the ionic species. The correct symbol will be looked up for the atomic species if the atomic number is specified. A symbol can have a maximum of three characters. The next three entries are real numbers representing the velocity of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5/ps. If this keyword is not present and a molecular dynamics calculation is performed, the ionic velocities will be randomly initialised with the appropriate temperature.","title":"Ionic Velocities"},{"location":"documentation/Input_Files/cell_keywords/","text":"This is a concise list of the common keywords for CASTEP's cell input file. The definitions of the keywords are given in more detail in the section on the cell file . Keyword in the cell file Type Default Description LATTICE_CART ^1 ^1 B -- The cell lattice vectors in Cartesian coordinates. LATTICE_ABC ^1 ^1 B -- The cell lattice vectors specified in $ a, b, c, \\alpha, \\beta, \\gamma $ format. POSITIONS_FRAC ^2 ^2 B -- The positions of the ions in fraction coordinates with respect to the lattice vectors. POSITIONS_ABS ^2 ^2 B -- The positions of the ions in absolute coordinates. KPOINT_LIST ^3 ^3 B -- A list of k-points in the Brillouin zone with associated weights. KPOINT_MP_GRID ^3 ^3 W -- The k-points defined as a Monkhorst-Pack grid by specifying the grid dimensions in each direction. KPOINT_MP_SPACING ^3 ^3 P 0.1 \u00c5^{-1} \u00c5^{-1} The k-points as a Monkhorst-Pack grid by specifying the maximum distance between k-points. KPOINT_MP_OFFSET V 0,0,0 The offset of the origin of the Monkhorst-Pack grid in fractional coordinates relative to the reciprocal lattice vectors. SPECTRAL_KPOINT_PATH ^4 ^4 B -- A list of k-points in the Brillouin zone which defines the path along which a band-structure calculation will be performed. SPECTRAL_KPOINT_PATH_SPACING P 0.1 \u00c5^{-1} \u00c5^{-1} Specifies the maximum spacing between k-points along the path for which a band structure calculation will be performed. SPECTRAL_KPOINT_LIST ^4 ^4 B SCF k-points A list of k-points at which a band-structure calculation will be performed. SPECTRAL_KPOINT_MP_GRID ^4 ^4 W -- The k-points for optical matrix element calculations defined as a Monkhorst-Pack grid by specifying the grid dimensions in each direction. SPECTRAL_KPOINT_MP_SPACING ^4 ^4 P 0.1 \u00c5 ^{-1} ^{-1} The k-points for optical matrix element calculations as a Monkhorst-Pack grid by specifying the maximum distance between k-points. SPECTRAL_KPOINT_MP_OFFSET V 0,0,0 The offset of the origin of the Monkhorst-Pack grid for optical matrix element calculations in fractional coordinates relative to the reciprocal lattice vectors. PHONON_KPOINT_PATH ^5 ^5 B -- A list of k-points in the Brillouin zone which defines the path along which a phonon calculation will be performed. PHONON_KPOINT_PATH_SPACING P 0.1 \u00c5 ^{-1} ^{-1} Specifies the maximum spacing between k-points along the path for which a phonon calculation will be performed. PHONON_KPOINT_LIST ^5 ^5 B SCF k-points A list of k-points at which a phonon calculation will be performed. PHONON_GAMMA_DIRECTIONS B See text The directions in which the gamma point will be approached for calculation of the LO/TO splitting. SYMMETRY_GENERATE ^6 ^6 D no symmetry If this is present, the highest symmtery group of the cell will found and the corresponding symmetry operations generated. SYMMETRY_OPS ^6 ^6 B no symmetry The symmetry operations that apply to the cell. SYMMETRY_TOL P 0.01 \u00c5 The tolerance within which symmetry will be enforced. IONIC_CONSTRAINTS B no constraints The constraints on the motion of ions during relaxation or MD. FIX_ALL_IONS L FALSE Constrain all ionic positions to remain fixed. FIX_ALL_CELL L FALSE Constrain all cell parameters to remain fixed. FIX_COM L TRUE Constrain the centre of mass of the ions to remain fixed. CELL_CONSTRAINTS B no constraints The constraints on changes in the cell shape during relaxation or MD. SPECIES_MASS B atomic mass The masses of the ionic species. SPECIES_POT B see text The names of the pseudopotentials associated with each species. SPECIES_LCAO_STATES B see text The number of angular momentum states to use in the LCAO basis set for this species when performing population analysis. EXTERNAL_PRESSURE B no pressure The external pressure tensor. IONIC_VELOCITIES B random The velocities of the ions in Cartesian coordinates. For the argument types, B indicates block data, P means a physical value, L is a logical value, D is a keyword that may simply be defined (present) or not, V is a real vector and W is an integer vector. ^1 ^1 Only one of LATTICE_CART and LATTICE_ABC maybe present in a cell file. ^2 ^2 Only one of POSITIONS_FRAC and POSITIONS_ABS may be present in a cell file. ^3 ^3 Only one of KPOINTS_LIST , KPOINTS_MP_GRID and KPOINTS_MP_SPACING may be present in a cell file. ^4 ^4 Only one of SPECTRAL_KPOINT_PATH , SPECTRAL_KPOINTS_MP_GRID , SPECTRAL_KPOINTS_MP_SPACING and SPECTRAL_KPOINT_LIST may be present in a cell file. ^5 ^5 Only one of PHONON_KPOINT_PATH and PHONON_KPOINT_LIST may be present in a cell file. ^6 ^6 Only one of SYMMETRY_GENERATE and SYMMETRY_OPS may be present in a cell file.","title":"cell keywords"},{"location":"documentation/Input_Files/output_files/","text":"CASTEP writes output data in a variety of files. Some of these will be in human readable ASCII format (i.e. plaintext) and can be read with commands such as less or more on linux, or with a simple text editor (textedit, notepad etc). Other files will be in binary format and are designed to be read or processed with an external program. Groundstate .castep ASCII. CASTEP's main outputfile. .bib ASCII. Bibtex file containing citations to the methods CASTEP has used in the calculation. .check Binary. This checkpoint file contains the results of the calculation including the groundstate charge density and wavefunctions. It is typically a very large file. Will be read by CASTEP when performing a continuation calculation. Also read by postprocessing software such as c2x. .check_bak Binary. backup of the checkpoint file. .cst_esp Binary. Electrostatic potential. .usp ASCII. Pseudoptential data, written for each species. See the page on reading usp headers .uspso ASCII. Pseudoptential data, written for each species. This is the J-dependant version of the .usp . See the page on reading usp headers .bands ASCII. Kohn-Sham eigenvalues at the requested k-points. Can be used to plot band structures or density of states. Note that the eigenvalues are given in atomic units (Hartree). .den_fmt ASCII. Charge density. Only written if write_formatted_density : T . .pot_fmt ASCII. Groundstate potential. Only written if write_formatted_potential : T . .chdiff Binary. Difference between the groundstate charge density and a superposition of atomic densities. Only written if calculate_densdiff : T .chdiff_fmt ASCII. same data as .chdiff in human readable format. Only written if calculate_densdiff : T and write_formatted_density : T . .xrd_sf ASCII. X-ray structure factors. See the documentation page Geometry Optimisation *.geom ASCII. State of the system (coordinates, unit cell etc) at each step of the geometry optimisation. See for specification. Can be used to animate the geometry optimisation - can be read with Jmol. Molecular Dynamics *.md ASCII. State of the system (coordinates, unit cell etc) at each step of the molecular dynamics simulation. Same format as the .geom file. See for specification. Can be used to animate the geometry optimisation - can be Spectral .pdos_bin Binary. Matrix elements used for plotting a projected density of states. Used by Optados. .ome_bin Binary. Matrix elements used for calculating optical properties. Used by Optados. .dome_bin Binary. Diagonal elements of the optical matrix elements. Used by Optados to plot densities of states / spectral properties using adaptive smearing. .elnes_bin Binary. Matrix elements used for plotting the core-loss spectrum. Used by Optados. .orbitals Binary. Kohn-Sham states at each kpoints. Used by orbital2bands to make a reorganised .bands file for a cleaner looking bandstructure. Phonon .phonon ASCII. Phonon eigenvalues and eigenvectors. Magres .magres ASCII. Contain the NMR tensors (depending on magres_task shielding, EFG or J). Read by MagresView or the Soprano python libraries. _current.dat ASCII. Written if MAGRES_WRITE_RESPONSE=True . Used to compute NICS (nucleus independent chemical shifts) see https://www.ccpnc.ac.uk/docs/nics Transition state search .ts ASCII. See the specification in the documentation pages","title":"output files"},{"location":"documentation/Input_Files/output_files/#groundstate","text":".castep ASCII. CASTEP's main outputfile. .bib ASCII. Bibtex file containing citations to the methods CASTEP has used in the calculation. .check Binary. This checkpoint file contains the results of the calculation including the groundstate charge density and wavefunctions. It is typically a very large file. Will be read by CASTEP when performing a continuation calculation. Also read by postprocessing software such as c2x. .check_bak Binary. backup of the checkpoint file. .cst_esp Binary. Electrostatic potential. .usp ASCII. Pseudoptential data, written for each species. See the page on reading usp headers .uspso ASCII. Pseudoptential data, written for each species. This is the J-dependant version of the .usp . See the page on reading usp headers .bands ASCII. Kohn-Sham eigenvalues at the requested k-points. Can be used to plot band structures or density of states. Note that the eigenvalues are given in atomic units (Hartree). .den_fmt ASCII. Charge density. Only written if write_formatted_density : T . .pot_fmt ASCII. Groundstate potential. Only written if write_formatted_potential : T . .chdiff Binary. Difference between the groundstate charge density and a superposition of atomic densities. Only written if calculate_densdiff : T .chdiff_fmt ASCII. same data as .chdiff in human readable format. Only written if calculate_densdiff : T and write_formatted_density : T . .xrd_sf ASCII. X-ray structure factors. See the documentation page","title":"Groundstate"},{"location":"documentation/Input_Files/output_files/#geometry-optimisation","text":"*.geom ASCII. State of the system (coordinates, unit cell etc) at each step of the geometry optimisation. See for specification. Can be used to animate the geometry optimisation - can be read with Jmol.","title":"Geometry Optimisation"},{"location":"documentation/Input_Files/output_files/#molecular-dynamics","text":"*.md ASCII. State of the system (coordinates, unit cell etc) at each step of the molecular dynamics simulation. Same format as the .geom file. See for specification. Can be used to animate the geometry optimisation - can be","title":"Molecular Dynamics"},{"location":"documentation/Input_Files/output_files/#spectral","text":".pdos_bin Binary. Matrix elements used for plotting a projected density of states. Used by Optados. .ome_bin Binary. Matrix elements used for calculating optical properties. Used by Optados. .dome_bin Binary. Diagonal elements of the optical matrix elements. Used by Optados to plot densities of states / spectral properties using adaptive smearing. .elnes_bin Binary. Matrix elements used for plotting the core-loss spectrum. Used by Optados. .orbitals Binary. Kohn-Sham states at each kpoints. Used by orbital2bands to make a reorganised .bands file for a cleaner looking bandstructure.","title":"Spectral"},{"location":"documentation/Input_Files/output_files/#phonon","text":".phonon ASCII. Phonon eigenvalues and eigenvectors.","title":"Phonon"},{"location":"documentation/Input_Files/output_files/#magres","text":".magres ASCII. Contain the NMR tensors (depending on magres_task shielding, EFG or J). Read by MagresView or the Soprano python libraries. _current.dat ASCII. Written if MAGRES_WRITE_RESPONSE=True . Used to compute NICS (nucleus independent chemical shifts) see https://www.ccpnc.ac.uk/docs/nics","title":"Magres"},{"location":"documentation/Input_Files/output_files/#transition-state-search","text":".ts ASCII. See the specification in the documentation pages","title":"Transition state search"},{"location":"documentation/Input_Files/param_file/","text":"This is a detailed description of options for CASTEP's param file. See the basic param file page for an overview. This page has the most frequently-used param file options, but for a full set use CASTEP's built-in help . The param file is one of CASTEP's two main input files. It contains all of the information about the kind of simulation your wish CASTEP to perform, as well as details of how CASTEP should perform them and additional simulations and analyses. The file itself is a free-format keyword-driven text file, consisting largely of single-line keywords, although there are a small number of blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. All of the keywords and blocks are optional, but you will almost always want to change at least some. Task This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file . Cut-off energy The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV. XC functional Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"param file"},{"location":"documentation/Input_Files/param_file/#task","text":"This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file .","title":"Task"},{"location":"documentation/Input_Files/param_file/#cut-off-energy","text":"The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV.","title":"Cut-off energy"},{"location":"documentation/Input_Files/param_file/#xc-functional","text":"Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"XC functional"},{"location":"documentation/Molecular_Dynamics/basics/","text":"Fundamental to MD calculations is the calculation time-step. An appropriate value for the simulation should be specified in the parameters file in the following way. md_delta_t = 2 fs Any valid unit of time can be used when specifying the time-step. The number of time-steps to perform is specified with e.g. md_num_iter = 500 NB This is the number of steps to be calculated in this run. It is NOT the accumulated total number of steps in a series of continuation runs. The \"MD time\" value in the <seed>.castep file records the cumulative time. Ensembles The following statistical ensembles can be simulated using CASTEP. NVE In this ensemble the number of atoms (N), the shape and volume (V) of the simulation cell and the energy (E) remain constant. The conserved energy is the Born-Oppenheimer Hamiltonian E = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} E = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} in atomic units. This ensemble is selected using the command md_ensemble = NVE in the parameters file. The actual value of the conserved energy will be the result of the initial self-consistent DFT calculation plus the kinetic energy of the initial ionic velocities. These ionic velocities are defined in one of three ways. By explicit user definition of ionic velocities in the cell file, e.g. %BLOCK IONIC_VELOCITIES auv H xxxxx yyyyy zzzzz H xxxxx yyyyy zzzzz O xxxxx yyyyy zzzzz %ENDBLOCK IONIC_VELOCITIES using any valid unit of velocity (auv is atomic unit of velocity), etc. By definition of an initial temperature in the parameters file, e.g. md_temperature = 293 K Note that this can be specified using any valid unit of temperature. In this case initial velocities are assigned randomly such that the total linear momentum is zero and the instantaneous temperature matches that specified. The system will reach equilibrium with a somewhat different temperature due to equipartition of kinetic and potential energy. By continuation from an equilibrated run at the desired temperature. This could be a run in any of the other available ensembles. This will also use the cell and ionic positions from the continuation file. See the section on continuation for details. Velocities read from a continuation file will always take precedence. If no continuation file is used, and both md_temperature and an IONIC_VELOCITIES block are specified, the md_temperature keyword will be ignored. By default, pressure is not calculated during an NVE run. To override this use the command calculate_stress = true in the parameters file. NVT This ensemble is selected with md_ensemble = NVT The system will be evolved to a specific temperature defined using the md_temperature keyword as used above. Initial velocities are assigned based on this temperature, read from an IONIC_VELOCITIES block in the cell file, or read from a continuation file in the same way as above. Temperature control can be implemented by one of several methods, all of which have been shown to correctly sample the canonical ensemble. The first of these is the deterministic Nose-Hoover chain method of Tuckerman et al 3 and is selected with md_thermostat = nose-hoover in the parameters file. In the NVT case, a single Nose-Hoover chain is coupled to all particle degrees of freedom. The length of the chain can also be specified, e.g. md_nhc_length = 5 for a chain of five thermostats. In the Nose-Hoover case with a chain of M M thermostats acting of N_{f} N_{f} ionic degrees of freedom, the conserved quantity is the pseudo-Hamiltonian \\begin{equation} \\mathcal{H} = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} \\end{equation} \\begin{equation} \\mathcal{H} = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} \\end{equation} where the Q_{i} Q_{i} are the thermostat fictitious masses assigned automatically from the specified ion relaxation time and \\xi_{i} \\xi_{i} are the thermostat degrees of freedom. This is printed with the label Hamilt Energy: at each time-step. A Nose-Hoover thermostat with no chain (i.e. with M M =1 ) is known to not be ergodic and hence should be avoided. The second method of controlling temperature is through the stochastic Langevin thermostat. md_thermostat = langevin In this case the printed Hamiltonian energy is the value of equation above. This is not conserved by the dynamics, but should exhibit no long term drift from the equilibrium value. Finally, the temperature may be controled via the Hoover-Langevin thermostat. md_thermostat = hoover-langevin which is the fusion of a deterministic Nose-Hoover thermostat acting directly on the physical system, with a Langevin thermostat operating on the Nose-Hoover variables, in order to guarantee ergodicity. With each method, a suitable relaxation time for the thermostatic process should be specified. This can use any supported unit of time, e.g md_ion_t = 2.4 ps for a thermostat relaxation time of 2.4 picoseconds. The Hoover-Langevin thermostat is the LEAST sensitive to the choice of this value. As with the NVE ensemble, pressure is not calculated by default. This is overridden in the same way as the NVE case. NPH In this ensemble the size and (if desired) shape of the simulation cell varies to regulate pressure. No thermostat is applied and hence the enthalpy (H) is conserved. This ensemble is specified with the following: md_ensemble = NPH The external pressure is set in the cell definition file using any valid unit of pressure. The required symmetry of the external pressure tensor implies that only the upper triangular components need be specified, e.g. %block external_pressure GPa 0.5 0.0 0.0 0.5 0.0 0.5 %endblock external_pressure to specify an isotropic external pressure of 0.5 Giga-Pascals. MD can also support non-isotropic pressure if using a variable-shape barostat. Velocities are assigned such that the initial temperature is equal to md_temperature , or are read from the cell definition file/continuation file as in the NVE/NVT cases. Two barostat schemes are available. The first restricts the dynamics of the cell to isotropic expansions and contractions. This follows the method of Andersen 4 and Hoover 1 2 as corrected by Martyna et al. 5 . This is selected using: md_barostat = andersen-hoover In this case the printed Hamiltonian energy is the enthalpy, plus the kinetic energy associated with the cell motion. \\begin{equation} \\label{eq:AndersenNPH} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + p_{\\epsilon}^{2}/2W \\end{equation} \\begin{equation} \\label{eq:AndersenNPH} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + p_{\\epsilon}^{2}/2W \\end{equation} The alternative scheme implements the method of Parrinello and Rahman 6 7 . Both the size and shape of the simulation cell are allowed to vary. The issue of cell rotations is eliminated by the use of a symmetrised pressure tensor. Note that as liquids cannot sustain shear, this method should only be used with solids. It should also be noted that this scheme is based on the modified Parrinello-Rahman method of Martyna, Tobias and Klien 5 . The following line in the parameters file selects this barostat. md_barostat = parrinello-rahman The cell dynamics contain nine degrees of freedom (of which six are independent) leading to a Hamiltonian energy of \\begin{equation} \\label{eq:ParRarNPH} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + \\mathrm{Tr}[{\\mathbf{p}_{g}\\mathbf{p}_{g}^{T}]}/2W \\end{equation} \\begin{equation} \\label{eq:ParRarNPH} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + \\mathrm{Tr}[{\\mathbf{p}_{g}\\mathbf{p}_{g}^{T}]}/2W \\end{equation} For both barostats, a relaxation time for the cell motions should be specified with an appropriate unit of time, for example: md_cell_t = 20 ps This time is used to calculate a fictitious mass W W for the cell dynamics and should be large compared to the characteristic time for the ionic dynamics. The NPH equations of motion require that pressure (stress) is calculated at each MD time-step. The value of calculate_stress is therefore irrelevant in this case. A variable cell implies variable reciprocal lattice vectors which has consequences for the plane-wave basis set. As the cell changes, the number of plane waves required to produce the specified cut-off energy changes. The user therefore has two options. The first is to fix the size of the basis set. fixed_npw = true The cut-off energy is now variable as is the quality of the basis set. This option should therefore only be used for calculations in which the volume changes are small and which are over-converged with respect to the number of plane waves. The second option is to allow the basis set to change at each time-step. fixed_npw = false which is the default value. This keeps the cut-off energy approximately constant by adding or subtracting plane waves from the basis set at each time-step. In either case, the effect of Pulay stress is reduced by applying a finite basis set correction to the pressure at each time-step. In the case of a fixed number of plane waves, the constant correction to energy is ignored. With variable number of plane waves the energy correction is no longer constant and is recalculated at each step. NPT The NPT ensemble is specified with the command: md_ensemble = NPT This can use either the Nose-Hoover or Langevin thermostat, and either Andersen-Hoover or Parrinello-Rahman barostat. In all cases, the dynamics can be shown to correctly sample the isothermal-isobaric ensemble 5 All options pertaining to the NPH and NVT ensembles apply. In the case of Langevin dynamics at NPT, the printed Hamiltonian energy is the same as in the NPH ensemble, i.e. that given by the equations above. In the case of Nose-Hoover NPT molecular dynamics, the Hamiltonian energy is given by \\begin{equation} \\label{eq:HooverNPT} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + p_{\\epsilon}^{2}/2W + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{bi}}^{2}}{2Q_{bi}} + k_{B}T\\sum_{i=1}^{M}\\xi_{bi} \\end{equation} \\begin{equation} \\label{eq:HooverNPT} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + p_{\\epsilon}^{2}/2W + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{bi}}^{2}}{2Q_{bi}} + k_{B}T\\sum_{i=1}^{M}\\xi_{bi} \\end{equation} in the case of isotropic cell dynamics, or \\begin{equation} \\label{eq:ParRarNPT} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + \\mathrm{Tr}[{\\mathbf{p}_{g}\\mathbf{p}_{g}^{T}]}/2W + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{bi}}^{2}}{2Q_{bi}} + 9k_{B}T\\xi_{b1} + k_{B}T\\sum_{i=2}^{M}\\xi_{bi} \\end{equation} \\begin{equation} \\label{eq:ParRarNPT} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + \\mathrm{Tr}[{\\mathbf{p}_{g}\\mathbf{p}_{g}^{T}]}/2W + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{bi}}^{2}}{2Q_{bi}} + 9k_{B}T\\xi_{b1} + k_{B}T\\sum_{i=2}^{M}\\xi_{bi} \\end{equation} in the Parrinello-Rahman case. Note that in each case the motion of the cell degree(s) of freedom couple to a second Nose-Hoover chain. W. G. Hoover. Canonical dynamics - equilibrium phase-space distributions. Phys. Rev. A, 31:1695-1697, 1985. \u21a9 W. G. Hoover. Constant-pressure equations of motion. Phys. Rev. A, 34:2499-2500, 1986. \u21a9 G. J. Martyna, M. L. Klein, and M. Tuckerman. Nose-hoover chains - the canonical ensemble via continuous dynamics. J. Chem. Phys., 97:2635-2643, 1992. \u21a9 H. C. Andersen. Molecular dynamics simulations at constant pressure and/or temperature. J. Chem. Phys., 71:2384, 1980. \u21a9 G. J. Martyna, J. T. Tobias, and M. L. Klein. Constant pressure molecular dynamics algorithms. J. Chem. Phys., 101(5):4177-4189, 1994. \u21a9 \u21a9 \u21a9 M. Parinello and A. Rahman. Crystal structure and pair potentials: A molecular-dynamics study. Phys. Rev. Lett., page 1196, 1980. \u21a9 M. Parrinello and A. Rahman. Polymorphic transitions in single-crystals - a new molecular- dynamics method. J. Appl. Phys., 52:7182-7190, 1981. \u21a9","title":"MD Basics"},{"location":"documentation/Molecular_Dynamics/basics/#ensembles","text":"The following statistical ensembles can be simulated using CASTEP.","title":"Ensembles"},{"location":"documentation/Molecular_Dynamics/basics/#nve","text":"In this ensemble the number of atoms (N), the shape and volume (V) of the simulation cell and the energy (E) remain constant. The conserved energy is the Born-Oppenheimer Hamiltonian E = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} E = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} in atomic units. This ensemble is selected using the command md_ensemble = NVE in the parameters file. The actual value of the conserved energy will be the result of the initial self-consistent DFT calculation plus the kinetic energy of the initial ionic velocities. These ionic velocities are defined in one of three ways. By explicit user definition of ionic velocities in the cell file, e.g. %BLOCK IONIC_VELOCITIES auv H xxxxx yyyyy zzzzz H xxxxx yyyyy zzzzz O xxxxx yyyyy zzzzz %ENDBLOCK IONIC_VELOCITIES using any valid unit of velocity (auv is atomic unit of velocity), etc. By definition of an initial temperature in the parameters file, e.g. md_temperature = 293 K Note that this can be specified using any valid unit of temperature. In this case initial velocities are assigned randomly such that the total linear momentum is zero and the instantaneous temperature matches that specified. The system will reach equilibrium with a somewhat different temperature due to equipartition of kinetic and potential energy. By continuation from an equilibrated run at the desired temperature. This could be a run in any of the other available ensembles. This will also use the cell and ionic positions from the continuation file. See the section on continuation for details. Velocities read from a continuation file will always take precedence. If no continuation file is used, and both md_temperature and an IONIC_VELOCITIES block are specified, the md_temperature keyword will be ignored. By default, pressure is not calculated during an NVE run. To override this use the command calculate_stress = true in the parameters file.","title":"NVE"},{"location":"documentation/Molecular_Dynamics/basics/#nvt","text":"This ensemble is selected with md_ensemble = NVT The system will be evolved to a specific temperature defined using the md_temperature keyword as used above. Initial velocities are assigned based on this temperature, read from an IONIC_VELOCITIES block in the cell file, or read from a continuation file in the same way as above. Temperature control can be implemented by one of several methods, all of which have been shown to correctly sample the canonical ensemble. The first of these is the deterministic Nose-Hoover chain method of Tuckerman et al 3 and is selected with md_thermostat = nose-hoover in the parameters file. In the NVT case, a single Nose-Hoover chain is coupled to all particle degrees of freedom. The length of the chain can also be specified, e.g. md_nhc_length = 5 for a chain of five thermostats. In the Nose-Hoover case with a chain of M M thermostats acting of N_{f} N_{f} ionic degrees of freedom, the conserved quantity is the pseudo-Hamiltonian \\begin{equation} \\mathcal{H} = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} \\end{equation} \\begin{equation} \\mathcal{H} = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} \\end{equation} where the Q_{i} Q_{i} are the thermostat fictitious masses assigned automatically from the specified ion relaxation time and \\xi_{i} \\xi_{i} are the thermostat degrees of freedom. This is printed with the label Hamilt Energy: at each time-step. A Nose-Hoover thermostat with no chain (i.e. with M M =1 ) is known to not be ergodic and hence should be avoided. The second method of controlling temperature is through the stochastic Langevin thermostat. md_thermostat = langevin In this case the printed Hamiltonian energy is the value of equation above. This is not conserved by the dynamics, but should exhibit no long term drift from the equilibrium value. Finally, the temperature may be controled via the Hoover-Langevin thermostat. md_thermostat = hoover-langevin which is the fusion of a deterministic Nose-Hoover thermostat acting directly on the physical system, with a Langevin thermostat operating on the Nose-Hoover variables, in order to guarantee ergodicity. With each method, a suitable relaxation time for the thermostatic process should be specified. This can use any supported unit of time, e.g md_ion_t = 2.4 ps for a thermostat relaxation time of 2.4 picoseconds. The Hoover-Langevin thermostat is the LEAST sensitive to the choice of this value. As with the NVE ensemble, pressure is not calculated by default. This is overridden in the same way as the NVE case.","title":"NVT"},{"location":"documentation/Molecular_Dynamics/basics/#nph","text":"In this ensemble the size and (if desired) shape of the simulation cell varies to regulate pressure. No thermostat is applied and hence the enthalpy (H) is conserved. This ensemble is specified with the following: md_ensemble = NPH The external pressure is set in the cell definition file using any valid unit of pressure. The required symmetry of the external pressure tensor implies that only the upper triangular components need be specified, e.g. %block external_pressure GPa 0.5 0.0 0.0 0.5 0.0 0.5 %endblock external_pressure to specify an isotropic external pressure of 0.5 Giga-Pascals. MD can also support non-isotropic pressure if using a variable-shape barostat. Velocities are assigned such that the initial temperature is equal to md_temperature , or are read from the cell definition file/continuation file as in the NVE/NVT cases. Two barostat schemes are available. The first restricts the dynamics of the cell to isotropic expansions and contractions. This follows the method of Andersen 4 and Hoover 1 2 as corrected by Martyna et al. 5 . This is selected using: md_barostat = andersen-hoover In this case the printed Hamiltonian energy is the enthalpy, plus the kinetic energy associated with the cell motion. \\begin{equation} \\label{eq:AndersenNPH} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + p_{\\epsilon}^{2}/2W \\end{equation} \\begin{equation} \\label{eq:AndersenNPH} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + p_{\\epsilon}^{2}/2W \\end{equation} The alternative scheme implements the method of Parrinello and Rahman 6 7 . Both the size and shape of the simulation cell are allowed to vary. The issue of cell rotations is eliminated by the use of a symmetrised pressure tensor. Note that as liquids cannot sustain shear, this method should only be used with solids. It should also be noted that this scheme is based on the modified Parrinello-Rahman method of Martyna, Tobias and Klien 5 . The following line in the parameters file selects this barostat. md_barostat = parrinello-rahman The cell dynamics contain nine degrees of freedom (of which six are independent) leading to a Hamiltonian energy of \\begin{equation} \\label{eq:ParRarNPH} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + \\mathrm{Tr}[{\\mathbf{p}_{g}\\mathbf{p}_{g}^{T}]}/2W \\end{equation} \\begin{equation} \\label{eq:ParRarNPH} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + \\mathrm{Tr}[{\\mathbf{p}_{g}\\mathbf{p}_{g}^{T}]}/2W \\end{equation} For both barostats, a relaxation time for the cell motions should be specified with an appropriate unit of time, for example: md_cell_t = 20 ps This time is used to calculate a fictitious mass W W for the cell dynamics and should be large compared to the characteristic time for the ionic dynamics. The NPH equations of motion require that pressure (stress) is calculated at each MD time-step. The value of calculate_stress is therefore irrelevant in this case. A variable cell implies variable reciprocal lattice vectors which has consequences for the plane-wave basis set. As the cell changes, the number of plane waves required to produce the specified cut-off energy changes. The user therefore has two options. The first is to fix the size of the basis set. fixed_npw = true The cut-off energy is now variable as is the quality of the basis set. This option should therefore only be used for calculations in which the volume changes are small and which are over-converged with respect to the number of plane waves. The second option is to allow the basis set to change at each time-step. fixed_npw = false which is the default value. This keeps the cut-off energy approximately constant by adding or subtracting plane waves from the basis set at each time-step. In either case, the effect of Pulay stress is reduced by applying a finite basis set correction to the pressure at each time-step. In the case of a fixed number of plane waves, the constant correction to energy is ignored. With variable number of plane waves the energy correction is no longer constant and is recalculated at each step.","title":"NPH"},{"location":"documentation/Molecular_Dynamics/basics/#npt","text":"The NPT ensemble is specified with the command: md_ensemble = NPT This can use either the Nose-Hoover or Langevin thermostat, and either Andersen-Hoover or Parrinello-Rahman barostat. In all cases, the dynamics can be shown to correctly sample the isothermal-isobaric ensemble 5 All options pertaining to the NPH and NVT ensembles apply. In the case of Langevin dynamics at NPT, the printed Hamiltonian energy is the same as in the NPH ensemble, i.e. that given by the equations above. In the case of Nose-Hoover NPT molecular dynamics, the Hamiltonian energy is given by \\begin{equation} \\label{eq:HooverNPT} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + p_{\\epsilon}^{2}/2W + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{bi}}^{2}}{2Q_{bi}} + k_{B}T\\sum_{i=1}^{M}\\xi_{bi} \\end{equation} \\begin{equation} \\label{eq:HooverNPT} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + p_{\\epsilon}^{2}/2W + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{bi}}^{2}}{2Q_{bi}} + k_{B}T\\sum_{i=1}^{M}\\xi_{bi} \\end{equation} in the case of isotropic cell dynamics, or \\begin{equation} \\label{eq:ParRarNPT} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + \\mathrm{Tr}[{\\mathbf{p}_{g}\\mathbf{p}_{g}^{T}]}/2W + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{bi}}^{2}}{2Q_{bi}} + 9k_{B}T\\xi_{b1} + k_{B}T\\sum_{i=2}^{M}\\xi_{bi} \\end{equation} \\begin{equation} \\label{eq:ParRarNPT} H = \\left<\\Psi|\\hat{H}_{e}|\\Psi\\right> + \\frac{1}{2} \\sum_{i=1}^{N}\\sum_{j=1}^{N}\\frac{Z_{i}Z_{j}} {|\\mathbf{R}_{i}-\\mathbf{R}_{j}|} +\\sum_{i=1}^{N}\\frac{P_{i}^{2}}{2M_{i}} + P_{ext}V + \\mathrm{Tr}[{\\mathbf{p}_{g}\\mathbf{p}_{g}^{T}]}/2W + \\sum_{i=1}^{M}\\frac{p_{\\xi_{i}}^{2}}{2Q_{i}} + N_{f}k_{B}T\\xi_{1} + k_{B}T\\sum_{i=2}^{M}\\xi_{i} + \\sum_{i=1}^{M}\\frac{p_{\\xi_{bi}}^{2}}{2Q_{bi}} + 9k_{B}T\\xi_{b1} + k_{B}T\\sum_{i=2}^{M}\\xi_{bi} \\end{equation} in the Parrinello-Rahman case. Note that in each case the motion of the cell degree(s) of freedom couple to a second Nose-Hoover chain. W. G. Hoover. Canonical dynamics - equilibrium phase-space distributions. Phys. Rev. A, 31:1695-1697, 1985. \u21a9 W. G. Hoover. Constant-pressure equations of motion. Phys. Rev. A, 34:2499-2500, 1986. \u21a9 G. J. Martyna, M. L. Klein, and M. Tuckerman. Nose-hoover chains - the canonical ensemble via continuous dynamics. J. Chem. Phys., 97:2635-2643, 1992. \u21a9 H. C. Andersen. Molecular dynamics simulations at constant pressure and/or temperature. J. Chem. Phys., 71:2384, 1980. \u21a9 G. J. Martyna, J. T. Tobias, and M. L. Klein. Constant pressure molecular dynamics algorithms. J. Chem. Phys., 101(5):4177-4189, 1994. \u21a9 \u21a9 \u21a9 M. Parinello and A. Rahman. Crystal structure and pair potentials: A molecular-dynamics study. Phys. Rev. Lett., page 1196, 1980. \u21a9 M. Parrinello and A. Rahman. Polymorphic transitions in single-crystals - a new molecular- dynamics method. J. Appl. Phys., 52:7182-7190, 1981. \u21a9","title":"NPT"},{"location":"documentation/Molecular_Dynamics/files/","text":"Understanding the Output In this chapter we shall briefly describe the output produced during a CASTEP calculation. Only the level of detail printed at iprint = 1 will be discussed. The .castep file Header As well as the usual information printed at the top of the output file, the molecular dynamics data specified in the parameters file is presented. ************************ Molecular Dynamics Parameters ************************ ensemble : NPT variable cell method : fixed basis quality pressure : see below temperature : 293.0 K using : Parrinello-Rahman barostat with characteristic cell time : 26.00 ps using : Langevin thermostat with characteristic ionic time : 16.95 ps time step : 0.2000E-02 ps number of MD steps : 500000 using best-fit first order extrapolation for wavefunctions backup results every : 5 steps MD SCF energy / atom convergence tol. : 0.1000E-04 eV MD SCF convergence tolerance window : 3 cycles ******************************************************************************* This amount of information presented in this section will obviously vary depending on the type of calculation being performed, but should be self-explanatory. Initial cell The information specified in the .cell file is then output. This will include the ionic positions, any user specified velocities if present, the usual pseudo-potential, k-point information, and details of any constraints. The total energy of the initial cell is then minimised, performing a finite basis set correction along the way if appropriate. The message Starting MD is then printed, and the MD calculation proper commences. As the first time-step will require data on forces, stress (for variable cell calculations) and energies, these are evaluated and printed at this point. Forces are output in the following format, using the force unit specified by the user, or the default of eV / Ang. ******************************** Forces ********************************* * * * Cartesian components (eV/A) * * --------------------------------------------------------------------- * * x y z * * * * Si 1 -0.02632 -0.02632 -0.02632 * * Si 2 -0.02653 -0.02617 -0.02617 * * Si 3 -0.02617 -0.02617 -0.02653 * * Si 4 -0.02617 -0.02653 -0.02617 * * Si 5 0.00075 0.05164 0.00075 * * Si 6 0.05204 0.05204 0.05204 * * Si 7 0.05164 0.00075 0.00075 * * Si 8 0.00075 0.00075 0.05164 * * * ************************************************************************* The stress tensor (if calculated) is output in the specified units of pressure, along with the corresponding scalar T=0 T=0 pressure, i.e. one third of the trace of the stress tensor. ***************** Stress Tensor ***************** * * * Cartesian components (GPa) * * --------------------------------------------- * * x y z * * * * x 0.009981 1.140649 1.140649 * * y 1.140649 0.009981 1.140649 * * z 1.140649 1.140649 0.009981 * * * * Pressure: -0.0100 * * * ************************************************* The current time and MD energies are then printed in the user specified energy units. Here potential energy refers to the total configurational energy of electrons plus ions obtained from the DFT calculation. Kinetic energy is the classical kinetic energy of the ions. Total energy refers to the sum of these two energies. The enthalpy and the relevant Hamiltonian energy for the ensemble as quoted in section ensembles is then printed. The temperature is also output at this point. Note that this is the ionic temperature only. If performing a calculation with finite temperature electrons (i.e. EDFT) the electron temperature may not be the same. Finally total pressure, i.e. the trace of the stress tensor plus the kinetic (ideal gas) pressure is printed in the user specified pressure units. xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx x MD Data: x x x x time : 0.000000 ps x x x x Potential Energy: -865.882944 eV x x Kinetic Energy: 0.265113 eV x x Total Energy: -865.617832 eV x x Enthalpy: -865.617735 eV x x Hamilt Energy: -865.617735 eV x x x x Temperature: 293.000000 K x x T/=0 Pressure: 0.172231 GPa x xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Iteration The MD simulation proper now begins. ================================================================= Starting MD iteration 1 ... ================================================================= Following this message the current cell information on the new configuration is printed and the energy is re-minimised to determine the new forces. The MD step is then performed and the updated forces, stress and energy information is printed in the same manner as above. ----------------------------------------------------------------- ... finished MD iteration 1 ----------------------------------------------------------------- The process repeats until the calculation is killed, or the specified number of MD iterations is completed. The .md file The .md file is provided as a single source for all the dynamical data produced by a CASTEP calculation. In all cases, data is printed in Hartree atomic units. Fortran formating data will be given here for all entries in this file for those who wish to import it into their own analysis codes. The CASTEP default behaviour is to record every single configuration in the .md file. This can therefore grow to quite a large size if doing a long MD run! The only exception to this, is if doing a non-DFT calculation, whereupon a sample of the configurations are written if md_sample_iter >0, otherwise no configurations are written. Note that unlike the .castep file, the .md file from a previous calculation with the same seedname will be overwritten, unless the new calculation is a continuation of the original. Header At the top of every .md file a header is written as below. The total length is four lines including blanks. The comments written are taken from the cell/parameter files. BEGIN header This is 8 atom cubic Si cell END header This is followed by a blank line. There is a single space at the start of each non-blank line. This header is written once only. Time and Energy Data The next entry will be the data for the first MD step. This begins with the current time on the first line, followed by the Total, Hamiltonian, and Kinetic energy on the second line with the label <-- E . 0.00000000E+000 -3.18206146E+001 -3.18108683E+001 9.74270683E-003 <-- E Formatting: format(12x,es18.8e3) format(9x,3(3x,es18.8e3),' <-- E') Thermodynamic Data The current temperature is then printed with the label <-- T . If the output is from a variable cell calculation, or calculate_stress has been explicitly set to true, the pressure is also printed with the label <-- P . 9.27876841E-04 <-- T 5.85402338E-06 <-- P Formatting: format(12x,es18.8,T73, ' <-- T') format(12x,es18.8,T73, ' <-- P') Cell Data For all calculations, the current matrix of cell vectors is printed with the label <-- h Each row gives the three Cartesian components of one of the cell vectors. 1.01599045E+001 0.00000000E+000 0.00000000E+000 <-- h 1.29430839E-017 1.01599045E+001 0.00000000E+000 <-- h 1.29430839E-017 1.29430839E-017 1.01599045E+001 <-- h Formatting: format(9x,3(3x,es18.8e3),' <-- h') format(9x,3(3x,es18.8e3),' <-- h') format(9x,3(3x,es18.8e3),' <-- h') The remaining cell data is only printed for variable cell calculations, regardless of the value of calculate_stress . First the velocity of each cell vector is printed with the label <-- hv . 2.80052926E-008 -1.42751448E-007 -1.35787248E-007 <-- hv -1.42751448E-007 2.76907508E-008 -1.44694219E-007 <-- hv -1.35787248E-007 -1.44694219E-007 2.71532850E-008 <-- hv Formatting: format(9x,3(3x,es18.8e3),' <-- hv') format(9x,3(3x,es18.8e3),' <-- hv') format(9x,3(3x,es18.8e3),' <-- hv') The full pressure tensor (including kinetic contributions) is then printed with the label <-- S in a similar fashion. -6.21684372E-006 3.03062374E-005 3.23291890E-005 <-- S 3.03062374E-005 -6.06171719E-006 3.31426773E-005 <-- S 3.23291890E-005 3.31426773E-005 -5.79666096E-006 <-- S Formatting: format(9x,3(3x,es18.8e3),' <-- S') format(9x,3(3x,es18.8e3),' <-- S') format(9x,3(3x,es18.8e3),' <-- S') Ionic Data Data on the current ionic configuration is then printed. Atoms are identified by their chemical symbol in the first column, and number of the atom within the species in the second. First the position vectors of all ions are printed with the label <-- R . Si 1 1.04834750E-002 1.15560090E-002 7.82230990E-003 <-- R Si 2 -3.20400394E-003 5.07172565E+000 5.10986361E+000 <-- R Si 3 5.07271954E+000 5.11656710E+000 -2.45225140E-003 <-- R Si 4 5.10789066E+000 -2.63240242E-002 5.09753015E+000 <-- R Si 5 7.57309188E+000 2.52845762E+000 7.57612741E+000 <-- R Si 6 2.55271297E+000 2.54057876E+000 2.53924276E+000 <-- R Si 7 2.53422324E+000 7.64091983E+000 7.62428191E+000 <-- R Si 8 7.63167143E+000 7.59610368E+000 2.52717191E+000 <-- R Formatting (for each atom): format(1x,a3,1x,i4,3(3x,es18.8e3),' <-- R') Velocities are then printed in a similar fashion. Si 1 5.77278549E-005 7.23673746E-005 4.30349159E-005 <-- V Si 2 -1.72415752E-005 -5.23270551E-005 1.75385181E-004 <-- V Si 3 -4.17085102E-005 2.14539848E-004 -1.78769096E-005 <-- V Si 4 1.58756714E-004 -1.60916056E-004 9.49147966E-005 <-- V Si 5 -2.70431102E-004 -7.18757382E-005 -2.43440176E-004 <-- V Si 6 7.51663795E-005 8.70332331E-008 -8.82271461E-006 <-- V Si 7 -4.19898677E-005 1.31687892E-004 3.60873179E-005 <-- V Si 8 7.97201068E-005 -1.33563298E-004 -7.92824105E-005 <-- V Formatting (for each atom): format(1x,a3,1x,i4,3(3x,es18.8e3),' <-- V') Finally forces are printed. Si 1 -4.23569381E-003 2.52214252E-003 -2.46018145E-003 <-- F Si 2 3.06338418E-003 -2.16206923E-003 -5.29928454E-003 <-- F Si 3 7.37259995E-004 -4.73479365E-003 -2.20030945E-003 <-- F Si 4 -6.89050954E-003 -2.25153379E-003 -8.37626756E-003 <-- F Si 5 4.53551291E-003 3.34757083E-003 1.02791157E-002 <-- F Si 6 2.06737343E-003 2.05175887E-003 2.70990363E-003 <-- F Si 7 -1.41457164E-003 -9.15433604E-004 1.54850432E-003 <-- F Si 8 2.13724448E-003 2.14235805E-003 3.79851935E-003 <-- F Formatting (for each atom): format(1x,a3,1x,i4,3(3x,es18.8e3),' <-- F') A blank line is then printed, and the process repeats with the data from the next time-step. The .hug file If you are using the Hugoniostat predictor-corrector method to generate a Hugoniot curve, each different state point generated has a different compression etc. This is summarized in the .hug file as follows: 0.990000000000 36.31531287 0.41888602 0.15771481 <-- cTPE 0.943272613764 40.07750465 0.63662992 1.62298398 <-- cTPE 0.865294155381 58.07130958 1.30346964 6.92736406 <-- cTPE The 4 data fields are: c - the ratio of the compressed to original cell vectors T - the temperature (in user units) - calculated as a time average of the instantaneous temperature of the configurations at this compression P - the pressure (in user units) - calculated as a time average E - the energy (in user units) - calculated as a time average","title":"MD Files"},{"location":"documentation/Molecular_Dynamics/files/#understanding-the-output","text":"In this chapter we shall briefly describe the output produced during a CASTEP calculation. Only the level of detail printed at iprint = 1 will be discussed.","title":"Understanding the Output"},{"location":"documentation/Molecular_Dynamics/files/#the-castep-file","text":"","title":"The .castep file"},{"location":"documentation/Molecular_Dynamics/files/#header","text":"As well as the usual information printed at the top of the output file, the molecular dynamics data specified in the parameters file is presented. ************************ Molecular Dynamics Parameters ************************ ensemble : NPT variable cell method : fixed basis quality pressure : see below temperature : 293.0 K using : Parrinello-Rahman barostat with characteristic cell time : 26.00 ps using : Langevin thermostat with characteristic ionic time : 16.95 ps time step : 0.2000E-02 ps number of MD steps : 500000 using best-fit first order extrapolation for wavefunctions backup results every : 5 steps MD SCF energy / atom convergence tol. : 0.1000E-04 eV MD SCF convergence tolerance window : 3 cycles ******************************************************************************* This amount of information presented in this section will obviously vary depending on the type of calculation being performed, but should be self-explanatory.","title":"Header"},{"location":"documentation/Molecular_Dynamics/files/#initial-cell","text":"The information specified in the .cell file is then output. This will include the ionic positions, any user specified velocities if present, the usual pseudo-potential, k-point information, and details of any constraints. The total energy of the initial cell is then minimised, performing a finite basis set correction along the way if appropriate. The message Starting MD is then printed, and the MD calculation proper commences. As the first time-step will require data on forces, stress (for variable cell calculations) and energies, these are evaluated and printed at this point. Forces are output in the following format, using the force unit specified by the user, or the default of eV / Ang. ******************************** Forces ********************************* * * * Cartesian components (eV/A) * * --------------------------------------------------------------------- * * x y z * * * * Si 1 -0.02632 -0.02632 -0.02632 * * Si 2 -0.02653 -0.02617 -0.02617 * * Si 3 -0.02617 -0.02617 -0.02653 * * Si 4 -0.02617 -0.02653 -0.02617 * * Si 5 0.00075 0.05164 0.00075 * * Si 6 0.05204 0.05204 0.05204 * * Si 7 0.05164 0.00075 0.00075 * * Si 8 0.00075 0.00075 0.05164 * * * ************************************************************************* The stress tensor (if calculated) is output in the specified units of pressure, along with the corresponding scalar T=0 T=0 pressure, i.e. one third of the trace of the stress tensor. ***************** Stress Tensor ***************** * * * Cartesian components (GPa) * * --------------------------------------------- * * x y z * * * * x 0.009981 1.140649 1.140649 * * y 1.140649 0.009981 1.140649 * * z 1.140649 1.140649 0.009981 * * * * Pressure: -0.0100 * * * ************************************************* The current time and MD energies are then printed in the user specified energy units. Here potential energy refers to the total configurational energy of electrons plus ions obtained from the DFT calculation. Kinetic energy is the classical kinetic energy of the ions. Total energy refers to the sum of these two energies. The enthalpy and the relevant Hamiltonian energy for the ensemble as quoted in section ensembles is then printed. The temperature is also output at this point. Note that this is the ionic temperature only. If performing a calculation with finite temperature electrons (i.e. EDFT) the electron temperature may not be the same. Finally total pressure, i.e. the trace of the stress tensor plus the kinetic (ideal gas) pressure is printed in the user specified pressure units. xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx x MD Data: x x x x time : 0.000000 ps x x x x Potential Energy: -865.882944 eV x x Kinetic Energy: 0.265113 eV x x Total Energy: -865.617832 eV x x Enthalpy: -865.617735 eV x x Hamilt Energy: -865.617735 eV x x x x Temperature: 293.000000 K x x T/=0 Pressure: 0.172231 GPa x xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx","title":"Initial cell"},{"location":"documentation/Molecular_Dynamics/files/#iteration","text":"The MD simulation proper now begins. ================================================================= Starting MD iteration 1 ... ================================================================= Following this message the current cell information on the new configuration is printed and the energy is re-minimised to determine the new forces. The MD step is then performed and the updated forces, stress and energy information is printed in the same manner as above. ----------------------------------------------------------------- ... finished MD iteration 1 ----------------------------------------------------------------- The process repeats until the calculation is killed, or the specified number of MD iterations is completed.","title":"Iteration"},{"location":"documentation/Molecular_Dynamics/files/#the-md-file","text":"The .md file is provided as a single source for all the dynamical data produced by a CASTEP calculation. In all cases, data is printed in Hartree atomic units. Fortran formating data will be given here for all entries in this file for those who wish to import it into their own analysis codes. The CASTEP default behaviour is to record every single configuration in the .md file. This can therefore grow to quite a large size if doing a long MD run! The only exception to this, is if doing a non-DFT calculation, whereupon a sample of the configurations are written if md_sample_iter >0, otherwise no configurations are written. Note that unlike the .castep file, the .md file from a previous calculation with the same seedname will be overwritten, unless the new calculation is a continuation of the original.","title":"The .md file"},{"location":"documentation/Molecular_Dynamics/files/#header_1","text":"At the top of every .md file a header is written as below. The total length is four lines including blanks. The comments written are taken from the cell/parameter files. BEGIN header This is 8 atom cubic Si cell END header This is followed by a blank line. There is a single space at the start of each non-blank line. This header is written once only.","title":"Header"},{"location":"documentation/Molecular_Dynamics/files/#time-and-energy-data","text":"The next entry will be the data for the first MD step. This begins with the current time on the first line, followed by the Total, Hamiltonian, and Kinetic energy on the second line with the label <-- E . 0.00000000E+000 -3.18206146E+001 -3.18108683E+001 9.74270683E-003 <-- E Formatting: format(12x,es18.8e3) format(9x,3(3x,es18.8e3),' <-- E')","title":"Time and Energy Data"},{"location":"documentation/Molecular_Dynamics/files/#thermodynamic-data","text":"The current temperature is then printed with the label <-- T . If the output is from a variable cell calculation, or calculate_stress has been explicitly set to true, the pressure is also printed with the label <-- P . 9.27876841E-04 <-- T 5.85402338E-06 <-- P Formatting: format(12x,es18.8,T73, ' <-- T') format(12x,es18.8,T73, ' <-- P')","title":"Thermodynamic Data"},{"location":"documentation/Molecular_Dynamics/files/#cell-data","text":"For all calculations, the current matrix of cell vectors is printed with the label <-- h Each row gives the three Cartesian components of one of the cell vectors. 1.01599045E+001 0.00000000E+000 0.00000000E+000 <-- h 1.29430839E-017 1.01599045E+001 0.00000000E+000 <-- h 1.29430839E-017 1.29430839E-017 1.01599045E+001 <-- h Formatting: format(9x,3(3x,es18.8e3),' <-- h') format(9x,3(3x,es18.8e3),' <-- h') format(9x,3(3x,es18.8e3),' <-- h') The remaining cell data is only printed for variable cell calculations, regardless of the value of calculate_stress . First the velocity of each cell vector is printed with the label <-- hv . 2.80052926E-008 -1.42751448E-007 -1.35787248E-007 <-- hv -1.42751448E-007 2.76907508E-008 -1.44694219E-007 <-- hv -1.35787248E-007 -1.44694219E-007 2.71532850E-008 <-- hv Formatting: format(9x,3(3x,es18.8e3),' <-- hv') format(9x,3(3x,es18.8e3),' <-- hv') format(9x,3(3x,es18.8e3),' <-- hv') The full pressure tensor (including kinetic contributions) is then printed with the label <-- S in a similar fashion. -6.21684372E-006 3.03062374E-005 3.23291890E-005 <-- S 3.03062374E-005 -6.06171719E-006 3.31426773E-005 <-- S 3.23291890E-005 3.31426773E-005 -5.79666096E-006 <-- S Formatting: format(9x,3(3x,es18.8e3),' <-- S') format(9x,3(3x,es18.8e3),' <-- S') format(9x,3(3x,es18.8e3),' <-- S')","title":"Cell Data"},{"location":"documentation/Molecular_Dynamics/files/#ionic-data","text":"Data on the current ionic configuration is then printed. Atoms are identified by their chemical symbol in the first column, and number of the atom within the species in the second. First the position vectors of all ions are printed with the label <-- R . Si 1 1.04834750E-002 1.15560090E-002 7.82230990E-003 <-- R Si 2 -3.20400394E-003 5.07172565E+000 5.10986361E+000 <-- R Si 3 5.07271954E+000 5.11656710E+000 -2.45225140E-003 <-- R Si 4 5.10789066E+000 -2.63240242E-002 5.09753015E+000 <-- R Si 5 7.57309188E+000 2.52845762E+000 7.57612741E+000 <-- R Si 6 2.55271297E+000 2.54057876E+000 2.53924276E+000 <-- R Si 7 2.53422324E+000 7.64091983E+000 7.62428191E+000 <-- R Si 8 7.63167143E+000 7.59610368E+000 2.52717191E+000 <-- R Formatting (for each atom): format(1x,a3,1x,i4,3(3x,es18.8e3),' <-- R') Velocities are then printed in a similar fashion. Si 1 5.77278549E-005 7.23673746E-005 4.30349159E-005 <-- V Si 2 -1.72415752E-005 -5.23270551E-005 1.75385181E-004 <-- V Si 3 -4.17085102E-005 2.14539848E-004 -1.78769096E-005 <-- V Si 4 1.58756714E-004 -1.60916056E-004 9.49147966E-005 <-- V Si 5 -2.70431102E-004 -7.18757382E-005 -2.43440176E-004 <-- V Si 6 7.51663795E-005 8.70332331E-008 -8.82271461E-006 <-- V Si 7 -4.19898677E-005 1.31687892E-004 3.60873179E-005 <-- V Si 8 7.97201068E-005 -1.33563298E-004 -7.92824105E-005 <-- V Formatting (for each atom): format(1x,a3,1x,i4,3(3x,es18.8e3),' <-- V') Finally forces are printed. Si 1 -4.23569381E-003 2.52214252E-003 -2.46018145E-003 <-- F Si 2 3.06338418E-003 -2.16206923E-003 -5.29928454E-003 <-- F Si 3 7.37259995E-004 -4.73479365E-003 -2.20030945E-003 <-- F Si 4 -6.89050954E-003 -2.25153379E-003 -8.37626756E-003 <-- F Si 5 4.53551291E-003 3.34757083E-003 1.02791157E-002 <-- F Si 6 2.06737343E-003 2.05175887E-003 2.70990363E-003 <-- F Si 7 -1.41457164E-003 -9.15433604E-004 1.54850432E-003 <-- F Si 8 2.13724448E-003 2.14235805E-003 3.79851935E-003 <-- F Formatting (for each atom): format(1x,a3,1x,i4,3(3x,es18.8e3),' <-- F') A blank line is then printed, and the process repeats with the data from the next time-step.","title":"Ionic Data"},{"location":"documentation/Molecular_Dynamics/files/#the-hug-file","text":"If you are using the Hugoniostat predictor-corrector method to generate a Hugoniot curve, each different state point generated has a different compression etc. This is summarized in the .hug file as follows: 0.990000000000 36.31531287 0.41888602 0.15771481 <-- cTPE 0.943272613764 40.07750465 0.63662992 1.62298398 <-- cTPE 0.865294155381 58.07130958 1.30346964 6.92736406 <-- cTPE The 4 data fields are: c - the ratio of the compressed to original cell vectors T - the temperature (in user units) - calculated as a time average of the instantaneous temperature of the configurations at this compression P - the pressure (in user units) - calculated as a time average E - the energy (in user units) - calculated as a time average","title":"The .hug file"},{"location":"documentation/Molecular_Dynamics/keywords/","text":"To perform a molecular dynamics calculation set the task parameter task : md To control the length of the dynamics simulation md_num_iter : number of MD steps (default 100) md_delta_t : MD timestep (default 1fs) To control the conditions for the dynamics md_ensemble : Ensemble (NVE, NVT, NPH, NPT, HUG) md_thermostat : Thermostat to use if not a constant energy ensemble. values: NOSE-HOOVER (default), LANGEVIN, HOOVER-LANGEVIN md_barostat : Barostat to use if not a constant volume ensemble. Values: ANDERSEN-HOOVER (default), PARRINELLO-RAHMAN md_temperature : Temperature to use if not a constant energy ensemble For the Hugoniot Thermostat md_hug_method : Hugoniostat method. Values: NONE (default), NVHUG, NPHUG md_hug_dir : Hugoniostat compression direction. Values: XDIR, YDIR, ZDIR, ISO (default) md_hug_t : Hugoniostat coupling constant. md_hug_compression : Hugoniostat compression ratio. Values from 0.0 to 1.0 (default) Path Integral MD (PIMD) MD_USE_PATHINT PIMD on/off MD_NUM_BEADS PIMD number of beads MD_PATHINT_INIT PIMD initialisation method MD_PATHINT_STAGING PIMD staging modes on/off MD_PATHINT_NUM_STAGES PIMD number of stages Advanced settings It is possible to change the tolerances for accepting the SCF groundstate during the molecular dynamics run. The default value are those for a single point energy e.g. the default for md_elec_energy_tol is the value of elec_energy_tol md_elec_energy_tol : MD total energy per atom convergence tolerance md_elec_eigenvalue_tol : MD eigenvalue convergence tolerance md_elec_force_tol : max force per atom convergence tolerance md_elec_convergence_win : MD convergence tolerance window MD_EQM_METHOD MD enhanced equilibration method MD_EQM_ION_T MD equilibration time for ions MD_EQM_CELL_T MD equilibration time for cell MD_EQM_T MD equilibration time MD_ION_T MD characteristic ionic time MD_CELL_T MD characteristic cell time MD_CELL_DAMP_RINGING Damp cell ringing mode MD_USE_PLUMED Use PLUMED metadynamics","title":"MD Keywords"},{"location":"documentation/Molecular_Dynamics/keywords/#path-integral-md-pimd","text":"MD_USE_PATHINT PIMD on/off MD_NUM_BEADS PIMD number of beads MD_PATHINT_INIT PIMD initialisation method MD_PATHINT_STAGING PIMD staging modes on/off MD_PATHINT_NUM_STAGES PIMD number of stages","title":"Path Integral MD (PIMD)"},{"location":"documentation/Molecular_Dynamics/keywords/#advanced-settings","text":"It is possible to change the tolerances for accepting the SCF groundstate during the molecular dynamics run. The default value are those for a single point energy e.g. the default for md_elec_energy_tol is the value of elec_energy_tol md_elec_energy_tol : MD total energy per atom convergence tolerance md_elec_eigenvalue_tol : MD eigenvalue convergence tolerance md_elec_force_tol : max force per atom convergence tolerance md_elec_convergence_win : MD convergence tolerance window MD_EQM_METHOD MD enhanced equilibration method MD_EQM_ION_T MD equilibration time for ions MD_EQM_CELL_T MD equilibration time for cell MD_EQM_T MD equilibration time MD_ION_T MD characteristic ionic time MD_CELL_T MD characteristic cell time MD_CELL_DAMP_RINGING Damp cell ringing mode MD_USE_PLUMED Use PLUMED metadynamics","title":"Advanced settings"},{"location":"documentation/Molecular_Dynamics/overview/","text":"Instead of using the forces to optimise the structure of the system, CASTEP can instead use the forces to accelerate the atoms (and cell-shape) in order to simulate dynamical properties - a method known as \"Molecular Dynamics\" or simply \"MD\". To perform this kind of calculation, set task : MD in your param file. CASTEP has a wide range of Molecular Dynamics (MD) capabilities, and can do equilibrium MD using a variety of ensembles: NVE - the microcanonical ensemble - with fixed number of atoms, volume of cell, and total energy conserved NVT - the canonical ensemble - with constant temperature not constant energy - due to the application of a thermostat NPH - constant external pressure and enthalpy - due to the application of a barostat NPT - constant external pressure and temperature - due to the application of a barostat and a thermostat HUG - the Hugoniostat - a special thermo-barostat algorithm to find states on the Hugoniot curve Of these, NPT is the closest to most real-life experiments. Of the different thermostats, CASTEP supports Nose-Hoover, Nose-Hoover chains, Langevin and Hoover-Langevin. Of the different barostats, CASTEP supports the isotropic Andersen-Hoover barostat, and the anisotropic Parrinello-Rahman barostat. CASTEP also supports the Berendsen thermostat and barostat, as a route to faster equilibration before switching to one of the above thermostats/barostats for production data. As well as generating different classical ensembles, CASTEP can also generate a state on the Hugoniot using the Hugoniostat algorithm. In fact, CASTEP can generate multiple sets of points on the Hugoniot curve in a single calculation. CASTEP can also go beyond the Born-Oppenheimer approximation to do quantum dynamics, using Path Integral Molecular Dynamics (PIMD), in either NVT or NPT ensembles, using the Langevin thermostat. In all MD schemes, CASTEP can support both linear and non-linear constraints on the ionic positions and/or on the cell vectors. The detailed trajectory information is written to a <seed>.md file, which is a structured text file (similar to the <seed>.geom file), for ease of manipulation and post-calculation analysis.","title":"MD Overview"},{"location":"documentation/Molecular_Dynamics/pimd/","text":"For some systems, with light atoms and/or at low temperatures, the zero-point motion of the atom (rather than the electrons) can become significant. This requires a level of theory beyond the Born-Oppenheimer approximation, which assuming that the nuclei can be treated as classical point charges. One way of doing this, is the Feynman Path Integral approach to quantum mechanics, and using the isomorphism of a ring of classical \"beads and springs\" to represent a quantum particle. This approach is combined with MD to generate an ensemble of configurations, and so the approach is known as Path Integral Molecular Dynamics (PIMD). With this approach, quantum expectation values can be calculated by trajectory averages. Hence classical MD analysis techniques can be used to generate quantum values. Keywords PIMD is a form of MD, and so all the usual MD keywords apply. NB the only supported md_thermostat is Langevin but this works with all values of md_barostat . To activate PIMD, the key variables are: md_use_pathint : true md_num_beads : 2 which turns on PIMD and 2 beads. It is important to note that the number of beads is an extra convergence parameter - the discretized ring becomes a continuous path integral in the limit that the number of beads tends to infinity. In practice, this is usually 2 -- 128 for light atoms (e.g. hydrogen) at temperatures > 10K. For lower temperatures, the number of beads goes up significantly. num_farms : 2 This is an important way to parallelize a PIMD calculation. With task farming, each bead can be assigned to a farm, so the number of farms should be either 1 (no farming) or md_num_beads . Then the PIMD calculation can be run in parallel on num_farms blocks of processors, where the number of processors in each block is determined by the usual CASTEP+DFT parallelization strategies (k-points, g-vectors, bands etc). More advanced keywords are: md_pathint_init : point / Gaussian md_pathint_staging : true This determines how the initial beads positions for a given atom are assigned. 'point' puts all the beads at the same point, whilst 'Gaussian' uses a Gaussian spreading function, which is analyticaly correct for a free particle to estimate the delocalization at the given temperature. The staging mode transformation is a key way to eliminate the natural harmonics in the dynamics of the ring of beads, which would otherwise significantly reduce the time step required, particularly at low temperatures. Output files When doing a PIMD calculation, there is md_num_beads times more information generated! Hence if using farming, then only the centroid position of and velocity etc of each ring of beads (corresponding to the classical position of each atom) is output to the .castep file. The coordinate data for each value of imaginary time (the cyclic index labelling the beads for each atom) is written to individual farmXXX.castep where XXX is the farm number. If not farming, then all this data is written to the single .castep file. The size of each ring for each atom at each real timestep is analysed in terms of the 'radius of gyration' tensor, and the 3 RGY eigenvalues and corresponding eigenvectors are also output to the master .castep file. In addition, there are beadXXX.md files produced, one per imaginary time value (number of beads). These can be used for different MD analysis techniques, and can also be merged using scripts such as pimerge.pl to put all the bead data for each value of real time into the same file, which can be useful for visualization of the bead dynamics. Working with i-pi i-pi is a 3 rd -party python package for doing PIMD. This needs other codes, such as CASTEP, to generate the forces for a given configuration, and can then do different forms of PIMD, including centroid PIMD, which is not natively supported by CASTEP. i-pi communicates to CASTEP via internet sockets. The support for this is built into CASTEP from v22 or later. There is an example of running i-pi with CASTEP in the examples/castep directory, along with a 'run_me' script that launches the i-pi server, creates a set of sub-directories (one per bead), and then launches the separate CASTEP clients. If doing PIMD in this mode, then you do not set PIMD variables in the .param file but rather in an i-pi input.xml file. The CASTEP .param file keywords needed are: task : socketdriver socket_port: 31415 socket_host: localhost where the task tells CASTEP to communicate with i-pi on socket_port (in this case, it is sent the bead coordinates and returns the energy and forces). The socket_host can be localhost, or an internet host, if running on a remote server. For more information, see the i-pi website .","title":"PIMD"},{"location":"documentation/Molecular_Dynamics/pimd/#keywords","text":"PIMD is a form of MD, and so all the usual MD keywords apply. NB the only supported md_thermostat is Langevin but this works with all values of md_barostat . To activate PIMD, the key variables are: md_use_pathint : true md_num_beads : 2 which turns on PIMD and 2 beads. It is important to note that the number of beads is an extra convergence parameter - the discretized ring becomes a continuous path integral in the limit that the number of beads tends to infinity. In practice, this is usually 2 -- 128 for light atoms (e.g. hydrogen) at temperatures > 10K. For lower temperatures, the number of beads goes up significantly. num_farms : 2 This is an important way to parallelize a PIMD calculation. With task farming, each bead can be assigned to a farm, so the number of farms should be either 1 (no farming) or md_num_beads . Then the PIMD calculation can be run in parallel on num_farms blocks of processors, where the number of processors in each block is determined by the usual CASTEP+DFT parallelization strategies (k-points, g-vectors, bands etc). More advanced keywords are: md_pathint_init : point / Gaussian md_pathint_staging : true This determines how the initial beads positions for a given atom are assigned. 'point' puts all the beads at the same point, whilst 'Gaussian' uses a Gaussian spreading function, which is analyticaly correct for a free particle to estimate the delocalization at the given temperature. The staging mode transformation is a key way to eliminate the natural harmonics in the dynamics of the ring of beads, which would otherwise significantly reduce the time step required, particularly at low temperatures.","title":"Keywords"},{"location":"documentation/Molecular_Dynamics/pimd/#output-files","text":"When doing a PIMD calculation, there is md_num_beads times more information generated! Hence if using farming, then only the centroid position of and velocity etc of each ring of beads (corresponding to the classical position of each atom) is output to the .castep file. The coordinate data for each value of imaginary time (the cyclic index labelling the beads for each atom) is written to individual farmXXX.castep where XXX is the farm number. If not farming, then all this data is written to the single .castep file. The size of each ring for each atom at each real timestep is analysed in terms of the 'radius of gyration' tensor, and the 3 RGY eigenvalues and corresponding eigenvectors are also output to the master .castep file. In addition, there are beadXXX.md files produced, one per imaginary time value (number of beads). These can be used for different MD analysis techniques, and can also be merged using scripts such as pimerge.pl to put all the bead data for each value of real time into the same file, which can be useful for visualization of the bead dynamics.","title":"Output files"},{"location":"documentation/Molecular_Dynamics/pimd/#working-with-i-pi","text":"i-pi is a 3 rd -party python package for doing PIMD. This needs other codes, such as CASTEP, to generate the forces for a given configuration, and can then do different forms of PIMD, including centroid PIMD, which is not natively supported by CASTEP. i-pi communicates to CASTEP via internet sockets. The support for this is built into CASTEP from v22 or later. There is an example of running i-pi with CASTEP in the examples/castep directory, along with a 'run_me' script that launches the i-pi server, creates a set of sub-directories (one per bead), and then launches the separate CASTEP clients. If doing PIMD in this mode, then you do not set PIMD variables in the .param file but rather in an i-pi input.xml file. The CASTEP .param file keywords needed are: task : socketdriver socket_port: 31415 socket_host: localhost where the task tells CASTEP to communicate with i-pi on socket_port (in this case, it is sent the bead coordinates and returns the energy and forces). The socket_host can be localhost, or an internet host, if running on a remote server. For more information, see the i-pi website .","title":"Working with i-pi"},{"location":"documentation/Molecular_Dynamics/restarts/","text":"Check-pointing, Continuation and Parameter Changes As with any other calculation in CASTEP, checkpoint files are written at regular intervals. Should the calculation be interrupted for whatever reason, it is possible to continue from the point at which the checkpoint file was last written. Check-pointing is performed by dumping all pertinent data to a .check file. The interval at which this check-pointing occurs can be controlled in two ways. The first option is to specify the number of md steps between checkpoints. num_backup_iter = 5 Alternatively, the wall-clock time (in seconds) between backups can be specified with: backup_interval = 60 Both can be specified but backup_interval will be preferred over num_backup_iter if both are set. To disable either option, set the corresponding parameter to zero. The name of the checkpoint file will be the calculation seed-name followed by \".check\". This can be overridden with: checkpoint = my_md_run.check To continue an MD calculation from a checkpoint file, ensure that the .check file, the .castep file and the .md file from the previous run are present in the current directory. If the seed-name of the new run is the same as for the old, the command continuation = default will suffice. To continue the run from a checkpoint file my_md_run.check use: continuation = my_md_run.check Note the standard CASTEP behaviour is to append new data to the end of existing files (such as .castep and .md) to avoid loosing data from earlier runs. This is not the case for the .check file, which is overwritten with new data. For this reason, the default CASTEP behaviour is to make a backup of the .check file, before over-writing it, so as to minimize the risk of data loss. Changing Parameters on Continuation Check-pointing is particularly useful for MD calculations where we often require many thousands of time-steps to extract useful information. Another important benefit is the ability to halt a calculation, and continue from a checkpoint with a revised set of MD parameters. For example one may wish to alter the target thermostat temperature, or the cell relaxation time without having to restart the run from the unequilibrated configuration. All options described in the above sections can be changed on a restart, i.e. it is possible to change ensemble, thermostat and barostat schemes, relaxation times, time-step, constraints, etc. by specifying new values in the input files for the new run. It is not possible to change the number of atoms/electrons in the cell upon a restart. Care must be taken when changing parameters on a restart. For example a large discontinuous change in the specified temperature or pressure will perturb a system away from equilibrium. In such cases the system should not be sampled until re-equilibrated. Although it is possible to change electronic minimisation schemes/parameters on a restart, this is somewhat unwise for obvious reasons. On-The-Fly Parameter Changes In fact, molecular dynamics parameters can be changed without having to halt the calculation at all! At the end of each MD step, the parameters file is re-read. Any parameters in this file which differ from those currently in use will be updated before the next MD step commences. It is therefore possible to alter the state of a running calculation by simply making changes to the parameters file while the calculation is running. The same considerations/restrictions which apply to changing parameters on a restart apply to these on the fly changes.","title":"MD Restarts"},{"location":"documentation/Molecular_Dynamics/restarts/#check-pointing-continuation-and-parameter-changes","text":"As with any other calculation in CASTEP, checkpoint files are written at regular intervals. Should the calculation be interrupted for whatever reason, it is possible to continue from the point at which the checkpoint file was last written. Check-pointing is performed by dumping all pertinent data to a .check file. The interval at which this check-pointing occurs can be controlled in two ways. The first option is to specify the number of md steps between checkpoints. num_backup_iter = 5 Alternatively, the wall-clock time (in seconds) between backups can be specified with: backup_interval = 60 Both can be specified but backup_interval will be preferred over num_backup_iter if both are set. To disable either option, set the corresponding parameter to zero. The name of the checkpoint file will be the calculation seed-name followed by \".check\". This can be overridden with: checkpoint = my_md_run.check To continue an MD calculation from a checkpoint file, ensure that the .check file, the .castep file and the .md file from the previous run are present in the current directory. If the seed-name of the new run is the same as for the old, the command continuation = default will suffice. To continue the run from a checkpoint file my_md_run.check use: continuation = my_md_run.check Note the standard CASTEP behaviour is to append new data to the end of existing files (such as .castep and .md) to avoid loosing data from earlier runs. This is not the case for the .check file, which is overwritten with new data. For this reason, the default CASTEP behaviour is to make a backup of the .check file, before over-writing it, so as to minimize the risk of data loss.","title":"Check-pointing, Continuation and Parameter Changes"},{"location":"documentation/Molecular_Dynamics/restarts/#changing-parameters-on-continuation","text":"Check-pointing is particularly useful for MD calculations where we often require many thousands of time-steps to extract useful information. Another important benefit is the ability to halt a calculation, and continue from a checkpoint with a revised set of MD parameters. For example one may wish to alter the target thermostat temperature, or the cell relaxation time without having to restart the run from the unequilibrated configuration. All options described in the above sections can be changed on a restart, i.e. it is possible to change ensemble, thermostat and barostat schemes, relaxation times, time-step, constraints, etc. by specifying new values in the input files for the new run. It is not possible to change the number of atoms/electrons in the cell upon a restart. Care must be taken when changing parameters on a restart. For example a large discontinuous change in the specified temperature or pressure will perturb a system away from equilibrium. In such cases the system should not be sampled until re-equilibrated. Although it is possible to change electronic minimisation schemes/parameters on a restart, this is somewhat unwise for obvious reasons.","title":"Changing Parameters on Continuation"},{"location":"documentation/Molecular_Dynamics/restarts/#on-the-fly-parameter-changes","text":"In fact, molecular dynamics parameters can be changed without having to halt the calculation at all! At the end of each MD step, the parameters file is re-read. Any parameters in this file which differ from those currently in use will be updated before the next MD step commences. It is therefore possible to alter the state of a running calculation by simply making changes to the parameters file while the calculation is running. The same considerations/restrictions which apply to changing parameters on a restart apply to these on the fly changes.","title":"On-The-Fly Parameter Changes"},{"location":"documentation/Molecular_Dynamics/tools/","text":"JMol can read a .md file and animate the motion of the atoms. See the tutorials for examples of more tools for MD.","title":"MD Tools"},{"location":"documentation/NMR/NMR_overview/","text":"Diamagnetic Insulators By a diamagnetic insulator we mean a system with an electronic gap between its highest occupied state and lowest unoccupied state, and all of the electronic spins are paired, simple examples are diamond, quartz, glycine\u2026 This class of materials is the most suitable for calculations as the main NMR interactions, magnetic sielding, J-coupling and electric field gradients can all be computed. Magnetic Shielding In a diamagnetic insulator this arises from orbital currents induced by an external magnetic field. This current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , produces a non-uniform induced magnetic field in the material, which is given by the Biot-Savart law as {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. The shielding tensor is defined as the ratio between this induced field, and the external applied field {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. It can thus be seen that the question of computing the shielding tensor is that of computing the induced electronic current. J-coupling The J-coupling is a small perturbation to the electronic ground-state of the system and we can identify it as a derivative of the total energy E, of the system {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} An equivalent expression arises from considering one nuclear spin (L) as perturbation which creates a magnetic field at a second (receiving) nucleus (K) {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. Eqn.~\\ref{eq:J} tells us that the question of computing J is essentially that of computing the magnetic field induced indirectly by a nuclear magnetic moment. When spin-orbit coupling is neglected we can consider the field as arising from two, essentially independent, mechanisms. Firstly, the magnetic moment can interact with electronic charge inducing an orbital current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , which in turn creates a magnetic field at the other nuclei in the system. This mechanism is similar to the case of magnetic shielding in insulators. The second mechanism arises from the interaction of the magnetic moment with the electronic spin, causing an electronic spin polarisation. By working to first order in these quantities we can write the magnetic field at atom {\\rm K} {\\rm K} induced by the magnetic moment of atom {\\rm L} {\\rm L} as {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. Several quantum chemistry packages provide the ability to compute J coupling tensors in molecular systems (see Ref 1 } for a review of methods). An approach to compute J tensors within the planewave-pseudopotential approach has recently been developed. 2 EFG For a nucleus with spin > > \u00bd the NMR response will include an interaction between the quadrupole moment of the nucleus, Q, and the electric field gradient (EFG) generated by the surrounding electronic structure. The EFG is a second rank, symmetric, traceless tensor G({\\bf r}) G({\\bf r}) given by G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} where \\alpha,\\beta,\\gamma \\alpha,\\beta,\\gamma denote the Cartesian coordinates x,y,z and E_{\\alpha}({\\bf r}) E_{\\alpha}({\\bf r}) is the local electric field at the position {\\bf r} {\\bf r} , which can be calculated from the charge density n({\\bf r}) n({\\bf r}) : \\begin{equation} E_{\\alpha}({\\bf r})=\\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3} (r_{\\alpha}-r_{\\alpha}'). \\end{equation} The EFG tensor is then equal to \\begin{equation}\\label{eq:efg_rs} G_{\\alpha\\beta}({\\bf r}) = \\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3}\\left[ \\delta_{\\alpha\\beta} -3 \\frac{(r_{\\alpha}-r_{\\alpha}')(r_{\\beta}-r_{\\beta}')}{|{\\bf r}-{\\bf r}'|^2}\\right]. \\end{equation} The computation of electric field gradient tensors is less demanding than either shielding or J-coupling tensors as it requires only knowledge of the electronic ground state. The LAPW approach in its implementation within the Wien series of codes\\cite{blaha90} has been widely used and shown to reliably predict Electric Field Gradient (EFG) tensors 3 . The equivalent formalism for the planewave/PAW approach is reported in Ref.~\\cite{profeta03}. The quadrupolar coupling constant, C _Q _Q and the asymmetry parameter, \\eta_Q \\eta_Q can be obtained from the the diagonalized electric field gradient tensor whose eigenvalues are labelled V _{xx} _{xx} , V _{yy} _{yy} , V _{zz} _{zz} , such that |V_{zz}|>|V_{yy}|>|V_{xx}| |V_{zz}|>|V_{yy}|>|V_{xx}| : \\begin{equation} C_{Q}=\\frac{eV_{zz}Q}{h}, \\end{equation} where h is Planck's constant and \\begin{equation} \\eta_Q=\\frac{V_{xx}-V_{yy}}{V_{zz}}. \\end{equation} Helgaker, T.; Jaszunski, M.; Pecul, M.Progress in Nuclear Magnetic Resonance Spectroscopy2008,53, 249 \u2013 268 \u21a9 Joyce, S. A.; Yates, J. R.; Pickard, C. J.; Mauri, F.J. Chem. Phys.2007,127, 204107 \u21a9 Blaha, P.; Sorantin, P.; Ambrosch, C.; Schwarz, K.Hyperfine Interact.1989,51, 917 \u21a9","title":"NMR Overview"},{"location":"documentation/NMR/NMR_overview/#diamagnetic-insulators","text":"By a diamagnetic insulator we mean a system with an electronic gap between its highest occupied state and lowest unoccupied state, and all of the electronic spins are paired, simple examples are diamond, quartz, glycine\u2026 This class of materials is the most suitable for calculations as the main NMR interactions, magnetic sielding, J-coupling and electric field gradients can all be computed.","title":"Diamagnetic Insulators"},{"location":"documentation/NMR/NMR_overview/#magnetic-shielding","text":"In a diamagnetic insulator this arises from orbital currents induced by an external magnetic field. This current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , produces a non-uniform induced magnetic field in the material, which is given by the Biot-Savart law as {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. The shielding tensor is defined as the ratio between this induced field, and the external applied field {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. It can thus be seen that the question of computing the shielding tensor is that of computing the induced electronic current.","title":"Magnetic Shielding"},{"location":"documentation/NMR/NMR_overview/#j-coupling","text":"The J-coupling is a small perturbation to the electronic ground-state of the system and we can identify it as a derivative of the total energy E, of the system {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} An equivalent expression arises from considering one nuclear spin (L) as perturbation which creates a magnetic field at a second (receiving) nucleus (K) {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. Eqn.~\\ref{eq:J} tells us that the question of computing J is essentially that of computing the magnetic field induced indirectly by a nuclear magnetic moment. When spin-orbit coupling is neglected we can consider the field as arising from two, essentially independent, mechanisms. Firstly, the magnetic moment can interact with electronic charge inducing an orbital current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , which in turn creates a magnetic field at the other nuclei in the system. This mechanism is similar to the case of magnetic shielding in insulators. The second mechanism arises from the interaction of the magnetic moment with the electronic spin, causing an electronic spin polarisation. By working to first order in these quantities we can write the magnetic field at atom {\\rm K} {\\rm K} induced by the magnetic moment of atom {\\rm L} {\\rm L} as {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. Several quantum chemistry packages provide the ability to compute J coupling tensors in molecular systems (see Ref 1 } for a review of methods). An approach to compute J tensors within the planewave-pseudopotential approach has recently been developed. 2","title":"J-coupling"},{"location":"documentation/NMR/NMR_overview/#efg","text":"For a nucleus with spin > > \u00bd the NMR response will include an interaction between the quadrupole moment of the nucleus, Q, and the electric field gradient (EFG) generated by the surrounding electronic structure. The EFG is a second rank, symmetric, traceless tensor G({\\bf r}) G({\\bf r}) given by G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} where \\alpha,\\beta,\\gamma \\alpha,\\beta,\\gamma denote the Cartesian coordinates x,y,z and E_{\\alpha}({\\bf r}) E_{\\alpha}({\\bf r}) is the local electric field at the position {\\bf r} {\\bf r} , which can be calculated from the charge density n({\\bf r}) n({\\bf r}) : \\begin{equation} E_{\\alpha}({\\bf r})=\\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3} (r_{\\alpha}-r_{\\alpha}'). \\end{equation} The EFG tensor is then equal to \\begin{equation}\\label{eq:efg_rs} G_{\\alpha\\beta}({\\bf r}) = \\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3}\\left[ \\delta_{\\alpha\\beta} -3 \\frac{(r_{\\alpha}-r_{\\alpha}')(r_{\\beta}-r_{\\beta}')}{|{\\bf r}-{\\bf r}'|^2}\\right]. \\end{equation} The computation of electric field gradient tensors is less demanding than either shielding or J-coupling tensors as it requires only knowledge of the electronic ground state. The LAPW approach in its implementation within the Wien series of codes\\cite{blaha90} has been widely used and shown to reliably predict Electric Field Gradient (EFG) tensors 3 . The equivalent formalism for the planewave/PAW approach is reported in Ref.~\\cite{profeta03}. The quadrupolar coupling constant, C _Q _Q and the asymmetry parameter, \\eta_Q \\eta_Q can be obtained from the the diagonalized electric field gradient tensor whose eigenvalues are labelled V _{xx} _{xx} , V _{yy} _{yy} , V _{zz} _{zz} , such that |V_{zz}|>|V_{yy}|>|V_{xx}| |V_{zz}|>|V_{yy}|>|V_{xx}| : \\begin{equation} C_{Q}=\\frac{eV_{zz}Q}{h}, \\end{equation} where h is Planck's constant and \\begin{equation} \\eta_Q=\\frac{V_{xx}-V_{yy}}{V_{zz}}. \\end{equation} Helgaker, T.; Jaszunski, M.; Pecul, M.Progress in Nuclear Magnetic Resonance Spectroscopy2008,53, 249 \u2013 268 \u21a9 Joyce, S. A.; Yates, J. R.; Pickard, C. J.; Mauri, F.J. Chem. Phys.2007,127, 204107 \u21a9 Blaha, P.; Sorantin, P.; Ambrosch, C.; Schwarz, K.Hyperfine Interact.1989,51, 917 \u21a9","title":"EFG"},{"location":"documentation/Pseudopotentials/otfg_string/","text":"In addition to Chris' OTFG document, some more description of the OTF string 2|3.1|4.0|2.2|2|3|5|50U3.4:60U3.1:51:52U3.1{6s1.45,5d0.05}(qc=3)[] Quantities in <> are descriptions not literals. All chars outside <> are literal <Local cpt>|<r_c(loc)>|<r_c(nonloc)>|<rinner/rcore>|<COARSE>|<MEDIUM>|<FINE>| <proj1>:<proj2>...<projn>{<config>}(flags)[<test config>] Local cpt : 0,1,2 for s,p,d r_c(loc) : pseudisation radius for local component (atomic units) r_c(nl) : pseudisation radius for nonlocal components (atomic units) (can be overridden as part of projector description) rinner/rcore : Pseudisation radius for augmentation functions and pseudo-core charge COARSE/MEDIUM/FINE : Recommended cutoff energies in atomic units (Hartree) projn : Descriptions of projectors to include, separated by semicolons. Syntax of a projector is in its briefest form <n><l> where digits <n> and <l> denote the atomic quantum numbers eg 30 for 3s In fact this is equivalent to the expanded form \"<n><l>UU\" where the projector flags \"UU\" mean include two ultrasoft beta projectors for this channel. The full form is <n><l>[<type>[<r_c>]][+/-<dE_use>][@<shift>] where anything in brackets [] is optional (here only). <type> can be U - a single ultrasoft projector UU - Two ultrasoft projectors N - a single norm-conserving projector L - use this projector as the local component G - an ultrasoft GIPAW Gamma projector H - an norm-conserving GIPAW Gamma projector P - Dummy: do not make a projector. LG - Make Gammas for local channel (not done by default) <r_c> - the projector specific pseudisation radius. <dE_use> - the reference energy for the projector. A floating-point value beginning with an explicit '=', '+' or '-' in Hartree. '=E' means absolute energy, '+/-E' is relative to AE eigenvalue. <shift> - Add this value to the projector, it shift it in energy. config : Reference configuration used to generate pseudopotential specified in obvious way, eg {3s1,3d0.5}. It is not necessary to explicitly mention all core states - CASTEP figures this out. flags : Options controlling the type of pseudisation applied and parameters. Syntax (flag1,flag2, ) allows multiple, comma separated flags qc=<val> The optmisation parameter - KE for q < qc is minimised in optimised projector scheme. Can also write (qc=3,qc1=3.5) to specify angular momentum channel-specific value of qc. tm Troullier-Martins pseudosation scheme pn polynomial fit pb bessel fit es \"extra soft\" scheme esr=val extra-soft with explicit specification of r_c nonlcc Do not generate of unscreen with a pseudo-core charge. schro Use non-relativistic schroedinger equation for AE calculation (default is scalar relativistic eqn) aug Explicitly turn on augmentation charges scpsp Generate a self-consistent pseudopotential test config : Specify a non-default test configuration eg, [4s1.5,3d0.5].","title":"OTFG string"},{"location":"documentation/Pseudopotentials/overview/","text":"CASTEP has a built-in library of pseudopotentials which is usually updated each release. We refer to CASTEP's build-in pseudopotentials as on-the-fly generated (or OTFG). The default OTFG pseudopotentials are accurate ultrasoft pseudopotentials. These are used if species_pot block is not defined in the cell file - or an empty block is given %block species_pot %endblock species_pot For preliminary investigations and high-throughput calculations you might want to choose the QC5 set of ultrasoftpotentials which are faster, but slightly less accurate than the default set. These are designed to give converged results at 500eV for all elements: %block species_pot QC5 %endblock species_pot For properties that require norm-conserving pseudopotentials, you can select CASTEP's latest OTFG norm-conserving set with the following in the in your .cell file. %block species_pot NCP %endblock species_pot For backwards compatibility you can also select pseudopotentials from earlier versions on the on-the-fly database, e.g. use %block species_pot C17 %endblock species_pot to select the ultrasoft pseudopotentials from CASTEP version 17. You can also specify the pseudopotential on a per-element basis, e.g. %block species_pot Fe C17 O NCP Ba QC5 %endblock species_pot A complete list of the availible OTFG definitions follows: String Description NCP Alias for the most recent set of norm conserving potentials QC5 High through put set (delta=1.7meV, 0.8meV excluding N,O,Cr,Mn) HARD \"Ultimate\" set of HARD pseudopotentials C7 USP definitions as of CASTEP 7.0 (C7) C8 USP definitions as of CASTEP 8.0 (C8) C9 USP definitions as of CASTEP 9.0/16.0 delta=0.5meV NCP9 Set of Norm Conserving pseudopotentials CASTEP 9.0/16.0 (NCP9)(delta=1.1meV) C17 USP definitions, CASTEP 17.0 (C17) NCP19 Set of Norm Conserving pseudopotentials CASTEP 17.0 (NCP17) C18 USP definitions, CASTEP 18.0 (C18) NCP18 Norm Conserving pseudopotentials CASTEP 18.0 (NCP18) C19 USP definitions, CASTEP 19.0 (C19) delta=0.442 meV NCP19 Norm Conserving pseudopotentials CASTEP 19.0 (NCP19) delta=1.098 meV Pseudopotential files CASTEP can also read in pseudopotentials from files Format Origin .usp as generated by CASTEP (note both USP and NCP use this format) .uspso as generated by CASTEP, with spin-orbit coupling .recpot as generated by OPIUM (also legacy CASTEP files) .UPF as generated by Quantum Espresso Note that properties using PAW augmentation will not be available when using file based pseudopotentials (OTFG is required) - this includes all NMR/EPR properties and EELS spectra.","title":"Overview"},{"location":"documentation/Pseudopotentials/overview/#pseudopotential-files","text":"CASTEP can also read in pseudopotentials from files Format Origin .usp as generated by CASTEP (note both USP and NCP use this format) .uspso as generated by CASTEP, with spin-orbit coupling .recpot as generated by OPIUM (also legacy CASTEP files) .UPF as generated by Quantum Espresso Note that properties using PAW augmentation will not be available when using file based pseudopotentials (OTFG is required) - this includes all NMR/EPR properties and EELS spectra.","title":"Pseudopotential files"},{"location":"documentation/Pseudopotentials/reading_headers/","text":"At the start of a calculation CASTEP will generate the require pseudopotentials. A report is written into the start of the .castep file. This page explains what information is contained within this header. Carbon - Ultrasoft ============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.395 qc 0 | | 2 0 0.250 1.395 qc 0 | | 3 1 -0.194 1.395 qc 0 | | 4 1 0.250 1.395 qc 0 | | loc 2 0.000 1.395 pn 0 | | | | Augmentation charge Rinner = 0.983 | | Partial core correction Rc = 0.983 | ------------------------------------------------------------ | \"2|1.4|10|12|13|20:21(qc=7)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ All quantities are given in atomic units - so energies in Hartree (1Ha =26.4eV) and lengths in Bohr (1 bohr = 0.88Ang) Element: This is just the symbol for the element Ionic Charge: Sum of nuclear charge and the core electrons (C Z=6 core=1s2 gives ionic charge as +6-2=+4) Level of theory: The Exchange-Correlation potential used. Atomic-solver: Koelling-Harmon is the default atomic solver. Reference electronic structure. This section describes the valence states included in the calculation. For Carbon these are the 2s and 2p states. Their occupations and energies are given. Pseudopotential Definition (Advanced) The definitions of each of the non-local projector (aka beta projectors) is given here. Beta - the number of the projector l - angular momentum quantum number e - energy of the corresponding orbital Rc - Cutoff (matching) radius for the orbital scheme - pseudization scheme (qc = qc tuned) norm - 1=norm-conserving 0-ultrasoft (norm not conserved) This is a standard Ultrasoft pseudopotential with two beta projectors per angular momentum channel. One projector is from an orbital at the eigen-energy (i.e. -0.505Ha for 2s) while the second projector corresponds to a non-bound orbital at an energy of 0.25Ha. The final line gives the choice of local potential. In this case the local potential is constructed from a l=2 state with the same cutoff radius as for the local projectors. Augmentation charge Rinner . This is specific to the Ultrasoft scheme - and describes the radius outside which the augmentation charge matches the all-electron charge. Partial core correction . As the exchange correlation energy is a non-linear function of charge there is an error introduced if we compute the xc energy of the valence and core electron separately. We therefore include the core charge in the calculation of the xc energy. The core charge is challenging to represent on a grid - and so a pseudized core charge is used. Rc is the cut-off for this pseudized core charge. Carbon - Normconserving ============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.201 qc 1 | | loc 1 -0.194 1.201 qc 1 | | | | No charge augmentation | | Partial core correction Rc = 0.839 | ------------------------------------------------------------ | \"1|1.2|17|20|23|20N:21L(qc=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ Note that the Reference Electronic Structure section is identical to the ultrasoft potential above. This relates to the all-electron atom and is unaffected by the details of the pseudopotential. From the pseudopotential definition we see there is one beta projector for l=0 (s) and the local potential is set to be l=1 (p). For norm-conserving potentials it is common to only need one projector per angular momentum chanel, and for one of the occupied channels to be represented by the local potential. There is no charge augmentation (this is only needed for ultrasofts) however, a non-linear core correction is used. Uranium - J-dependent ============================================================ | Pseudopotential Report - Date of generation 4-07-2020 | ------------------------------------------------------------ | Element: U Ionic charge: 14.00 Level of theory: LDA | | Atomic Solver: Dirac (FR) | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 6s1/2 2.000 -1.748 | | 6p1/2 2.000 -1.101 | | 6p3/2 4.000 -0.776 | | 7s1/2 2.000 -0.161 | | 5f5/2 1.286 -0.147 | | 5f7/2 1.714 -0.116 | | 6d3/2 0.400 -0.103 | | 6d5/2 0.600 -0.085 | | | | Pseudopotential Definition | | Beta l 2j e Rc scheme norm | | 1 0 1 -1.748 2.106 qc 1 | | 2 0 1 -0.161 2.106 qc 1 | | 3 1 3 -0.776 2.106 qc 1 | | 4 1 1 -1.101 2.106 qc 1 | | 5 2 5 -0.085 2.106 qc 1 | | 6 2 3 -0.103 2.106 qc 1 | | 7 3 7 -0.116 2.106 qc 1 | | 8 3 5 -0.147 2.106 qc 1 | | loc 4 0 0.000 2.106 pn 0 | | | | No charge augmentation | | Partial core correction Rc = 1.472 | ------------------------------------------------------------ | \"4|2.1|17|19|22|60N:70N:61N:62N:53N(qc=6,q3=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ This pseudopotential is calculated by using a Dirac equation solver including the spin-orbit interaction (FR=fully relativistic). It is a norm-conserving potential. There are 14 electrons included in the valence (6s2,7s2,6p6,6d1,5f3). Because of the spin orbit splitting states with different j quantum numbers have different energies. States with l>0 are split into j=l+1/2 j=l+1/2 and j=l-1/2 j=l-1/2 (e.g. the 6p states are split into 6p\u00bd and 6p3/2, the 5f into 5f5/2 5f7/2).","title":"Headers"},{"location":"documentation/Pseudopotentials/reading_headers/#carbon-ultrasoft","text":"============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.395 qc 0 | | 2 0 0.250 1.395 qc 0 | | 3 1 -0.194 1.395 qc 0 | | 4 1 0.250 1.395 qc 0 | | loc 2 0.000 1.395 pn 0 | | | | Augmentation charge Rinner = 0.983 | | Partial core correction Rc = 0.983 | ------------------------------------------------------------ | \"2|1.4|10|12|13|20:21(qc=7)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ All quantities are given in atomic units - so energies in Hartree (1Ha =26.4eV) and lengths in Bohr (1 bohr = 0.88Ang) Element: This is just the symbol for the element Ionic Charge: Sum of nuclear charge and the core electrons (C Z=6 core=1s2 gives ionic charge as +6-2=+4) Level of theory: The Exchange-Correlation potential used. Atomic-solver: Koelling-Harmon is the default atomic solver.","title":"Carbon - Ultrasoft"},{"location":"documentation/Pseudopotentials/reading_headers/#reference-electronic-structure","text":"This section describes the valence states included in the calculation. For Carbon these are the 2s and 2p states. Their occupations and energies are given.","title":"Reference electronic structure."},{"location":"documentation/Pseudopotentials/reading_headers/#pseudopotential-definition-advanced","text":"The definitions of each of the non-local projector (aka beta projectors) is given here. Beta - the number of the projector l - angular momentum quantum number e - energy of the corresponding orbital Rc - Cutoff (matching) radius for the orbital scheme - pseudization scheme (qc = qc tuned) norm - 1=norm-conserving 0-ultrasoft (norm not conserved) This is a standard Ultrasoft pseudopotential with two beta projectors per angular momentum channel. One projector is from an orbital at the eigen-energy (i.e. -0.505Ha for 2s) while the second projector corresponds to a non-bound orbital at an energy of 0.25Ha. The final line gives the choice of local potential. In this case the local potential is constructed from a l=2 state with the same cutoff radius as for the local projectors. Augmentation charge Rinner . This is specific to the Ultrasoft scheme - and describes the radius outside which the augmentation charge matches the all-electron charge. Partial core correction . As the exchange correlation energy is a non-linear function of charge there is an error introduced if we compute the xc energy of the valence and core electron separately. We therefore include the core charge in the calculation of the xc energy. The core charge is challenging to represent on a grid - and so a pseudized core charge is used. Rc is the cut-off for this pseudized core charge.","title":"Pseudopotential Definition (Advanced)"},{"location":"documentation/Pseudopotentials/reading_headers/#carbon-normconserving","text":"============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.201 qc 1 | | loc 1 -0.194 1.201 qc 1 | | | | No charge augmentation | | Partial core correction Rc = 0.839 | ------------------------------------------------------------ | \"1|1.2|17|20|23|20N:21L(qc=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ Note that the Reference Electronic Structure section is identical to the ultrasoft potential above. This relates to the all-electron atom and is unaffected by the details of the pseudopotential. From the pseudopotential definition we see there is one beta projector for l=0 (s) and the local potential is set to be l=1 (p). For norm-conserving potentials it is common to only need one projector per angular momentum chanel, and for one of the occupied channels to be represented by the local potential. There is no charge augmentation (this is only needed for ultrasofts) however, a non-linear core correction is used.","title":"Carbon - Normconserving"},{"location":"documentation/Pseudopotentials/reading_headers/#uranium-j-dependent","text":"============================================================ | Pseudopotential Report - Date of generation 4-07-2020 | ------------------------------------------------------------ | Element: U Ionic charge: 14.00 Level of theory: LDA | | Atomic Solver: Dirac (FR) | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 6s1/2 2.000 -1.748 | | 6p1/2 2.000 -1.101 | | 6p3/2 4.000 -0.776 | | 7s1/2 2.000 -0.161 | | 5f5/2 1.286 -0.147 | | 5f7/2 1.714 -0.116 | | 6d3/2 0.400 -0.103 | | 6d5/2 0.600 -0.085 | | | | Pseudopotential Definition | | Beta l 2j e Rc scheme norm | | 1 0 1 -1.748 2.106 qc 1 | | 2 0 1 -0.161 2.106 qc 1 | | 3 1 3 -0.776 2.106 qc 1 | | 4 1 1 -1.101 2.106 qc 1 | | 5 2 5 -0.085 2.106 qc 1 | | 6 2 3 -0.103 2.106 qc 1 | | 7 3 7 -0.116 2.106 qc 1 | | 8 3 5 -0.147 2.106 qc 1 | | loc 4 0 0.000 2.106 pn 0 | | | | No charge augmentation | | Partial core correction Rc = 1.472 | ------------------------------------------------------------ | \"4|2.1|17|19|22|60N:70N:61N:62N:53N(qc=6,q3=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ This pseudopotential is calculated by using a Dirac equation solver including the spin-orbit interaction (FR=fully relativistic). It is a norm-conserving potential. There are 14 electrons included in the valence (6s2,7s2,6p6,6d1,5f3). Because of the spin orbit splitting states with different j quantum numbers have different energies. States with l>0 are split into j=l+1/2 j=l+1/2 and j=l-1/2 j=l-1/2 (e.g. the 6p states are split into 6p\u00bd and 6p3/2, the 5f into 5f5/2 5f7/2).","title":"Uranium - J-dependent"},{"location":"documentation/Pseudopotentials/theory/","text":"The electrons in an atom can be divided into two types --- core electrons and valence electrons. The core electrons are tightly bound to the nucleus, while the valence electrons are more extended. A working definition for core electrons is that they are the ones which play no part in the interactions between atoms, while the valence electrons dictate most of the properties of the material. It is common to make the frozen core approximation; the core electrons are constrained not to differ from their free atomic nature when placed in the solid state environment. This reduces the number of electronic degrees of freedom in an all-electron calculation. It is a very good approximation. A different, but physically related, approach is taken in the pseudopotential approximation. Since, in an all-electron calculation, the valence electron wavefunctions must be orthogonal to the core wavefunctions they necessarily have strong oscillations in the region near the nucleus (see the all-electron wavefunction in Figure~\\ref{fig:wvfn}). Given that a planewave basis set is to be used to describe the wavefunctions, these strong oscillations are undesirable --- requiring many plane waves for an accurate description. Further, these oscillations are of very little consequence for the electronic structure in the solid, since they occur close to the nucleus. In the pseudopotential approach only the valence electrons are explicitly considered, the effects of the core electrons being integrated within a new ionic potential. The valence wavefunctions need no longer be orthogonal to the core states, and so the orthogonality oscillations disappear; hence far fewer plane waves are required to describe the valence wavefunctions. Numerous schemes to produce optimally soft pseudopotentials have been developed. Common choices are the norm-conserving potentials due to Troullier and Martins\\cite{troullier91} and Vanderbilt's ultrasoft scheme.\\cite{vanderbilt90}","title":"Theory"},{"location":"documentation/Spectral/keywords/","text":"SPECTRAL_TASK - determines what will be calculated. All tasks will compute the eigenenergies (aka bands). The list of tasks, and the extra properties calculated are as follows: bandstructure dos band gradients optics optical matrix elements pdos atomic projections coreloss dipole matrix elements with core states Most spectral calculations will involve the calculation of unoccupied states. One of the following parameters should be set to determine the number of states calculated. SPECTRAL_NEXTRA_BANDS number of extra spectral bands SPECTRAL_PERC_EXTRA_BANDS percentage of extra spectral bands SPECTRAL_NBANDS number of bands/k-point in spectral calc It is possible to use a different exchange-correlation functional to the one used for the groundstate. An example might be when a semi-local functional (such as PBE) is used for the groundstate, and a more expensive non-local functional (e.g. PBE0) is used for the spectral calculation. This is an approximation and should be done with cuation. To set the xc functional use one of the two keywords. SPECTRAL_XC_FUNCTIONAL spectral exchange-correlation functional SPECTRAL_XC_DEFINITION spectral exchange-correlation functional To change the convergence tolerance for the eigenvalues set SPECTRAL_EIGENVALUE_TOL ! default: 10E-6 eV SPECTRAL_MAX_ITER maximum iterations in spectral calculation SPECTRAL_MAX_STEPS_PER_ITER maximum steps per iter in spectral calculation","title":"Keywords"},{"location":"documentation/Spectral/overview/","text":"`","title":"Overview"},{"location":"documentation/Spectral/restarts/","text":"Spectral calculations do not write a check file - however, they can write backups to enable restarting an unfinished calculation. The limitation is that a parallel calculation must be restarted on the same number of processors. #Sample param file cut_off_energy : 550 eV fix_occupancy : true task : spectral spectral_task : coreloss %block devel_code SPECTRAL_RESTART %endblock devel_code backup_interval 1800 ! time in seconds The devel_code keyword SPECTRAL_RESTART triggers both the writing an reading of Spectral backup files. backup_interval determines the time between writing backups. Backup will slow down the calculation as they require disk access (which is always slow). If you expect a job to run for several hours backing up every 30min is a reasonable compromise. After completing each k-point the CASTEP will check to see if time since the last backup is greater than backup_interval - is it is a backup will be written - if not CASTEP carries on with the next k-point. Note that a backup is always written (if backup_interval>0) after the final kpoint. This is useful insurance in case there is any problem when CASTEP writes the final output files. Here is an example .castep file with backup ===================================================================== + + + Calculation of Spectral Properties + + + + Calculation re-parallelised over 2 processes. + + Data distributed by G-vector(1-way), k-point(2-way), band(1-way) + + Data distributed by k-point(2-way) + + + ===================================================================== Starting k-point: 1 of 5 on this process |<-- SPEC Starting k-point: 2 of 5 on this process |<-- SPEC Starting k-point: 3 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Starting k-point: 4 of 5 on this process |<-- SPEC Starting k-point: 5 of 5 on this process |<-- SPEC Starting k-point: 1 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Starting k-point: 2 of 5 on this process |<-- SPEC Starting k-point: 3 of 5 on this process |<-- SPEC Starting k-point: 4 of 5 on this process |<-- SPEC We see that backups were written every three k-points. The last backup was done after the 1 st k-point for spin 2. As this calculation was run on two processors, we find two backup files have been created -rw-r--r-- 1 317700 18 Jul 10:53 Si2-core.0001.spec -rw-r--r-- 1 317700 18 Jul 10:53 Si2-core.0002.spec To restart, keep everything the same but add to the param file continuation : xxx.check Where xxx.check is the name of the check file containing the ground-state density etc. This will have been written during the first run - and xxx will be replaced with whatever is the seedname of your run. We now re-run the calculation. CASTEP will read the ground-state from the check file (so there should be no electronic minimisation) Restarting spectral calculation from restart file |<-- SPEC Starting k-point: 2 of 5 on this process |<-- SPEC Starting k-point: 3 of 5 on this process |<-- SPEC Starting k-point: 4 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Starting k-point: 5 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Total time to compute matrix elements 3500.45 sec |<\u2014- SPEC So the calculation did restart from the 2 nd k-point on spin 2.","title":"Restarts"},{"location":"documentation/TDDFT/overview/","text":"","title":"TDDFT Overview"},{"location":"documentation/Transition_State_Search/neb/","text":"Note The NEB functionality in CASTEP was overhauled in version 22, with more efficient algorithms available. In order to use this new functionality, make sure you're using CASTEP 22 or later . Background and theory The nudged elastic band method is a widely-used method for finding a minimum energy pathway between two structures. You can use the method to estimate the barrier for the system to transition between the two structures. In our NEB implementation the update rule for atomic position is given by: x^{k+1}_{n} = x^{k}_n + \\alpha^k [-\\nabla^\\perp V(x^{k}_n) + \\mathbf{\\eta}^{k}_n] x^{k+1}_{n} = x^{k}_n + \\alpha^k [-\\nabla^\\perp V(x^{k}_n) + \\mathbf{\\eta}^{k}_n] where x^{k}_n x^{k}_n are the positions of image n n at iteration k k . \\alpha^k \\alpha^k is the step size, which can either be fixed or chosen in an adaptive manner, \\nabla^\\perp V(x^{k}_n) \\nabla^\\perp V(x^{k}_n) is the gradient of the total energy, projected to remove the component along the reaction path, and \\mathbf{\\eta}^{k}_n = \\mathbf{\\eta}((x^{k}_n)',(x^{k}_n)'') \\mathbf{\\eta}^{k}_n = \\mathbf{\\eta}((x^{k}_n)',(x^{k}_n)'') is the NEB spring force. As a consequence of the projection step, the NEB forces do not have a corresponding energy functional and hence linesearch is not possible, making quasi-Newton searches such as (L)BFGS inapplicable. Standard approaches are either to use simple gradient-only based methods or to add a maximum step size constraint in place of the linesearch. Both of these can exhibit slow convergence; a solution is instead to choose the step size adaptively using a custom time-stepping algorithm. A promising solution to this problem is the ODE12r adaptive scheme introduced in Ref. 3 , which combines two distinct step selection criteria: one based on minimising the change in the residual force from one step to the next as is typically done to control error in adaptive ODE solvers, and a second based on minimising the residual itself. The key idea is that adaptive ODE step selection should be used in the pre-asymptotic regime, while minimising the residual is suitable in the asymptotic regime. We have implemented three optimisation schemes for NEB paths, with the approach to be used controlled by the TSSEARCH_NEB_METHOD parameter: (i) the two point steepest descent scheme of Barzilai and Borwein ; (ii) the fast inertial relaxation engine ( FIRE ) and (iii) the ODE12R scheme discussed above. In all three cases, convergence is controlled by the existing TSSEARCH_FORCE_TOL parameter. To better fit user intuition, the default value of this parameter is now equal to the force tolerance used during geometry optimisation, GEOM_FORCE_TOL . We also provide three alternative algorithms to compute the tangents (x^{k}_n)' (x^{k}_n)' and curvatures (x^{k}_n)'' (x^{k}_n)'' at each image along the path, controlled by the TSSEARCH_NEB_TANGENT_MODE parameter. The three approaches are based on bisection, the improved tangent scheme of Ref 2 , and cubic spline interpolation as used in Ref 3 . The latter was found to be the most robust so has been made the default. Keywords As with other functionality in CASTEP, you can use the built-in help tool to find information on NEB-related keywords. For example, you could run: castep -s tssearch The relevant .param keywords are summarised in the table below: Parameter Default Level Notes TASK SINGLEPOINT Basic Set to TRANSITIONSTATESEARCH to perform a transition state calculation. TSSEARCH_METHOD LSTQST Basic The search method used to locate transition states. Must be set to NEB to perform a NEB calculation. Previous default retained for backwards compatibility. Modifiable: restart only. Allowed values: LSTQST , NEB Default value : LSTQST TSSEARCH_FORCE_TOL Same as GEOM_FORCE_TOL Basic Tolerance for accepting convergence of the maximum |ionic force| during QST search. Modifiable: restart and on the fly TSSEARCH_MAX_PATH_POINTS 20 Intermediate The maximum number of path points for NEB search. Modifiable: restart and on the fly. Allowed values: (any integer) > 0 TSSEARCH_NEB_METHOD ODE12R Intermediate Method used to optimize the NEB shape. Modifiable: restart and on the fly. Allowed values: GRAD_BB , FIRE , ODE12R TSSEARCH_NEB_TANGENT_MODE SPLINE Basic Method used to calculate the tangents of the NEB. Modifiable: restart and on the fly. Allowed values: NONE , BISECT , HIGH_E , SPLINE TSSEARCH_NEB_SPRING_CONSTANT 0.1 eV/ang2 Basic Spring constant used between the images in NEB search. Modifiable: restart and on the fly. Allowed values: (any) > 0.0 TSSEARCH_NEB_CLIMBING FALSE Basic If TRUE then the central bead in NEB search climbs up the potential and TSSEARCH_MAX_PATH_POINTS must be odd (may be increased by +1). If FALSE then the central bead in NEB search slides down the potential. Modifiable: restart only. Allowed values: TRUE or FALSE. Default value: FALSE TSSEARCH_NEB_MAX_ITER 20 Intermediate The maximum number of steps during NEB search. Modifiable: restart and on the fly. Allowed values: (any integer) > 0 TSSEARCH_NEB_NORMED FALSE if TSSEARCH_NEB_TANGENT_MODE = SPLINE , TRUE otherwise Expert If TRUE then the spring forces applied along the tangents in the NEB are normed to the displacement between beads. If FALSE then the spring forces are projected along the tangents in the NEB and may result in null forces if displacements are orthogonal to the NEB tangents. Modifiable: restart only. Allowed values: TRUE or FALSE As a minimum, you need to specify TASK: TRANSITIONSTATESEARCH and TSSEARCH_METHOD: NEB in the .param file and specify the product (final) ionic positions (using e.g. the POSITIONS_ABS_PRODUCT block) in the .cell file, in addition to the normal POSITIONS_ABS block. CASTEP will then linearly interpolate between the initial and product configuration and begin the NEB calculation. However, it's advisable to also: change the number of images used ( TSSEARCH_MAX_PATH_POINTS ), decide on whether you want the climbing image method ( TSSEARCH_NEB_CLIMBING ), and think about the relevant force criterion to be used ( TSSEARCH_FORCE_TOL ). For a practical guide on how to use the NEB method in CASTEP, see the tutorial . Output files In addition to information in the .castep file, a .ts file will be generated during a transition state search calculation. Below is the start of a typical .ts file, with annotations explaing what each line means (you can see these by clicking on the ( ) symbols). Note Like .geom and .md files, .ts files use atomic units (Ha for energies, Bohr for distances and Bohr/Ha for forces etc.). TSTYPE TSConfirmation # (1)! REA 1 0.00000000E+000 # (2)! -1.19447739E+001 -1.19447739E+001 <-- E #(3)! 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h #(4)! 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61419707E+000 8.39780193E+000 5.86117838E+000 <-- R #(5)! H 2 8.15635294E+000 5.72185774E+000 5.85777350E+000 <-- R H 3 5.06964224E+000 5.72278559E+000 5.86095165E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 8.47021636E-007 3.11793289E-005 2.28609226E-005 <-- F #(6)! H 2 1.38512779E-006 -2.45087447E-005 -4.65186359E-005 <-- F H 3 -4.12781162E-005 -4.76763241E-006 1.75643331E-005 <-- F N 1 3.90459667E-005 -1.90295182E-006 6.09338019E-006 <-- F PRO 1 1.00000000E+000 #(7)! -1.19447351E+001 -1.19447351E+001 <-- E 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61608080E+000 8.39796599E+000 7.36585209E+000 <-- R H 2 8.15724653E+000 5.72090835E+000 7.36726384E+000 <-- R H 3 5.07119891E+000 5.72404366E+000 7.37171850E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 6.09749957E-005 4.97392811E-005 -4.85624696E-005 <-- F H 2 6.57602570E-005 -1.92918456E-005 -3.12188543E-005 <-- F H 3 -5.16484028E-005 2.80445001E-005 5.83274956E-005 <-- F N 1 -7.50868499E-005 -5.84919355E-005 2.14538282E-005 <-- F TST 1 1.25000056E-001 #(8)! -1.19415297E+001 -1.19415297E+001 <-- E 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61443264E+000 8.39782206E+000 6.04926187E+000 <-- R H 2 8.15646486E+000 5.72173929E+000 6.04646018E+000 <-- R H 3 5.06983587E+000 5.72294304E+000 6.04979810E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 -9.19085803E-006 2.32501273E-002 -1.04092397E-002 <-- F H 2 2.02903385E-002 -1.17660606E-002 -1.06346944E-002 <-- F H 3 -2.03961322E-002 -1.17795791E-002 -1.05604406E-002 <-- F N 1 1.14984498E-004 2.95512341E-004 3.16043747E-002 <-- F This is a comment line stating what type of calculation was carried out. This is the initial (i.e. the REA ctant) configuration. The integer indicates it is the configuration for the first NEB iteration. As the REActant (and PROduct) configurations are the same for every NEB iteration, they are only printed out once. The float at the end of the line is a measure of where the configuration lies between 0 (reactant) and 1 (product). TODO: be more precise. <-- E is the total energy and enthalpy of the system, in atomic units. <-- h is the unit cell matrix (atomic units). <-- R are the atomic coordinates (Cartesian), in atomic units. <-- F are the forces (atomic units). TODO: do these include NEB forces? This is the end-point (or PRO duct) configuration for the first iteration. As this is the same for every NEB iteration, it is only printed out once. This is the first of the transition state configurations (NEB images) for iteration 1 of the NEB. For example, if you have 7 images, then there will be 7 blocks that start with TST 1 .","title":"Nudged elastic band"},{"location":"documentation/Transition_State_Search/neb/#background-and-theory","text":"The nudged elastic band method is a widely-used method for finding a minimum energy pathway between two structures. You can use the method to estimate the barrier for the system to transition between the two structures. In our NEB implementation the update rule for atomic position is given by: x^{k+1}_{n} = x^{k}_n + \\alpha^k [-\\nabla^\\perp V(x^{k}_n) + \\mathbf{\\eta}^{k}_n] x^{k+1}_{n} = x^{k}_n + \\alpha^k [-\\nabla^\\perp V(x^{k}_n) + \\mathbf{\\eta}^{k}_n] where x^{k}_n x^{k}_n are the positions of image n n at iteration k k . \\alpha^k \\alpha^k is the step size, which can either be fixed or chosen in an adaptive manner, \\nabla^\\perp V(x^{k}_n) \\nabla^\\perp V(x^{k}_n) is the gradient of the total energy, projected to remove the component along the reaction path, and \\mathbf{\\eta}^{k}_n = \\mathbf{\\eta}((x^{k}_n)',(x^{k}_n)'') \\mathbf{\\eta}^{k}_n = \\mathbf{\\eta}((x^{k}_n)',(x^{k}_n)'') is the NEB spring force. As a consequence of the projection step, the NEB forces do not have a corresponding energy functional and hence linesearch is not possible, making quasi-Newton searches such as (L)BFGS inapplicable. Standard approaches are either to use simple gradient-only based methods or to add a maximum step size constraint in place of the linesearch. Both of these can exhibit slow convergence; a solution is instead to choose the step size adaptively using a custom time-stepping algorithm. A promising solution to this problem is the ODE12r adaptive scheme introduced in Ref. 3 , which combines two distinct step selection criteria: one based on minimising the change in the residual force from one step to the next as is typically done to control error in adaptive ODE solvers, and a second based on minimising the residual itself. The key idea is that adaptive ODE step selection should be used in the pre-asymptotic regime, while minimising the residual is suitable in the asymptotic regime. We have implemented three optimisation schemes for NEB paths, with the approach to be used controlled by the TSSEARCH_NEB_METHOD parameter: (i) the two point steepest descent scheme of Barzilai and Borwein ; (ii) the fast inertial relaxation engine ( FIRE ) and (iii) the ODE12R scheme discussed above. In all three cases, convergence is controlled by the existing TSSEARCH_FORCE_TOL parameter. To better fit user intuition, the default value of this parameter is now equal to the force tolerance used during geometry optimisation, GEOM_FORCE_TOL . We also provide three alternative algorithms to compute the tangents (x^{k}_n)' (x^{k}_n)' and curvatures (x^{k}_n)'' (x^{k}_n)'' at each image along the path, controlled by the TSSEARCH_NEB_TANGENT_MODE parameter. The three approaches are based on bisection, the improved tangent scheme of Ref 2 , and cubic spline interpolation as used in Ref 3 . The latter was found to be the most robust so has been made the default.","title":"Background and theory"},{"location":"documentation/Transition_State_Search/neb/#keywords","text":"As with other functionality in CASTEP, you can use the built-in help tool to find information on NEB-related keywords. For example, you could run: castep -s tssearch The relevant .param keywords are summarised in the table below: Parameter Default Level Notes TASK SINGLEPOINT Basic Set to TRANSITIONSTATESEARCH to perform a transition state calculation. TSSEARCH_METHOD LSTQST Basic The search method used to locate transition states. Must be set to NEB to perform a NEB calculation. Previous default retained for backwards compatibility. Modifiable: restart only. Allowed values: LSTQST , NEB Default value : LSTQST TSSEARCH_FORCE_TOL Same as GEOM_FORCE_TOL Basic Tolerance for accepting convergence of the maximum |ionic force| during QST search. Modifiable: restart and on the fly TSSEARCH_MAX_PATH_POINTS 20 Intermediate The maximum number of path points for NEB search. Modifiable: restart and on the fly. Allowed values: (any integer) > 0 TSSEARCH_NEB_METHOD ODE12R Intermediate Method used to optimize the NEB shape. Modifiable: restart and on the fly. Allowed values: GRAD_BB , FIRE , ODE12R TSSEARCH_NEB_TANGENT_MODE SPLINE Basic Method used to calculate the tangents of the NEB. Modifiable: restart and on the fly. Allowed values: NONE , BISECT , HIGH_E , SPLINE TSSEARCH_NEB_SPRING_CONSTANT 0.1 eV/ang2 Basic Spring constant used between the images in NEB search. Modifiable: restart and on the fly. Allowed values: (any) > 0.0 TSSEARCH_NEB_CLIMBING FALSE Basic If TRUE then the central bead in NEB search climbs up the potential and TSSEARCH_MAX_PATH_POINTS must be odd (may be increased by +1). If FALSE then the central bead in NEB search slides down the potential. Modifiable: restart only. Allowed values: TRUE or FALSE. Default value: FALSE TSSEARCH_NEB_MAX_ITER 20 Intermediate The maximum number of steps during NEB search. Modifiable: restart and on the fly. Allowed values: (any integer) > 0 TSSEARCH_NEB_NORMED FALSE if TSSEARCH_NEB_TANGENT_MODE = SPLINE , TRUE otherwise Expert If TRUE then the spring forces applied along the tangents in the NEB are normed to the displacement between beads. If FALSE then the spring forces are projected along the tangents in the NEB and may result in null forces if displacements are orthogonal to the NEB tangents. Modifiable: restart only. Allowed values: TRUE or FALSE As a minimum, you need to specify TASK: TRANSITIONSTATESEARCH and TSSEARCH_METHOD: NEB in the .param file and specify the product (final) ionic positions (using e.g. the POSITIONS_ABS_PRODUCT block) in the .cell file, in addition to the normal POSITIONS_ABS block. CASTEP will then linearly interpolate between the initial and product configuration and begin the NEB calculation. However, it's advisable to also: change the number of images used ( TSSEARCH_MAX_PATH_POINTS ), decide on whether you want the climbing image method ( TSSEARCH_NEB_CLIMBING ), and think about the relevant force criterion to be used ( TSSEARCH_FORCE_TOL ). For a practical guide on how to use the NEB method in CASTEP, see the tutorial .","title":"Keywords"},{"location":"documentation/Transition_State_Search/neb/#output-files","text":"In addition to information in the .castep file, a .ts file will be generated during a transition state search calculation. Below is the start of a typical .ts file, with annotations explaing what each line means (you can see these by clicking on the ( ) symbols). Note Like .geom and .md files, .ts files use atomic units (Ha for energies, Bohr for distances and Bohr/Ha for forces etc.). TSTYPE TSConfirmation # (1)! REA 1 0.00000000E+000 # (2)! -1.19447739E+001 -1.19447739E+001 <-- E #(3)! 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h #(4)! 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61419707E+000 8.39780193E+000 5.86117838E+000 <-- R #(5)! H 2 8.15635294E+000 5.72185774E+000 5.85777350E+000 <-- R H 3 5.06964224E+000 5.72278559E+000 5.86095165E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 8.47021636E-007 3.11793289E-005 2.28609226E-005 <-- F #(6)! H 2 1.38512779E-006 -2.45087447E-005 -4.65186359E-005 <-- F H 3 -4.12781162E-005 -4.76763241E-006 1.75643331E-005 <-- F N 1 3.90459667E-005 -1.90295182E-006 6.09338019E-006 <-- F PRO 1 1.00000000E+000 #(7)! -1.19447351E+001 -1.19447351E+001 <-- E 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61608080E+000 8.39796599E+000 7.36585209E+000 <-- R H 2 8.15724653E+000 5.72090835E+000 7.36726384E+000 <-- R H 3 5.07119891E+000 5.72404366E+000 7.37171850E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 6.09749957E-005 4.97392811E-005 -4.85624696E-005 <-- F H 2 6.57602570E-005 -1.92918456E-005 -3.12188543E-005 <-- F H 3 -5.16484028E-005 2.80445001E-005 5.83274956E-005 <-- F N 1 -7.50868499E-005 -5.84919355E-005 2.14538282E-005 <-- F TST 1 1.25000056E-001 #(8)! -1.19415297E+001 -1.19415297E+001 <-- E 1.32280829E+001 0.00000000E+000 0.00000000E+000 <-- h 8.09986468E-016 1.32280829E+001 0.00000000E+000 <-- h 8.09986468E-016 8.09986468E-016 1.32280829E+001 <-- h H 1 6.61443264E+000 8.39782206E+000 6.04926187E+000 <-- R H 2 8.15646486E+000 5.72173929E+000 6.04646018E+000 <-- R H 3 5.06983587E+000 5.72294304E+000 6.04979810E+000 <-- R N 1 6.61404144E+000 6.61404144E+000 6.61404144E+000 <-- R H 1 -9.19085803E-006 2.32501273E-002 -1.04092397E-002 <-- F H 2 2.02903385E-002 -1.17660606E-002 -1.06346944E-002 <-- F H 3 -2.03961322E-002 -1.17795791E-002 -1.05604406E-002 <-- F N 1 1.14984498E-004 2.95512341E-004 3.16043747E-002 <-- F This is a comment line stating what type of calculation was carried out. This is the initial (i.e. the REA ctant) configuration. The integer indicates it is the configuration for the first NEB iteration. As the REActant (and PROduct) configurations are the same for every NEB iteration, they are only printed out once. The float at the end of the line is a measure of where the configuration lies between 0 (reactant) and 1 (product). TODO: be more precise. <-- E is the total energy and enthalpy of the system, in atomic units. <-- h is the unit cell matrix (atomic units). <-- R are the atomic coordinates (Cartesian), in atomic units. <-- F are the forces (atomic units). TODO: do these include NEB forces? This is the end-point (or PRO duct) configuration for the first iteration. As this is the same for every NEB iteration, it is only printed out once. This is the first of the transition state configurations (NEB images) for iteration 1 of the NEB. For example, if you have 7 images, then there will be 7 blocks that start with TST 1 .","title":"Output files"},{"location":"documentation/Troubleshooting/linux_path/","text":"Command not found When you type castep , Linux doesn't know where that command is, so it looks in the places where programs are usually put (often /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin and /usr/local/sbin ; \"bin\" here is short for \"binary\"). Unless CASTEP is there, it will tell you that it can't find it. Notice in particular that the directory you're in when you type the command is not in Linux's list of usual places to look, which is especially confusing when you first encounter it! Telling Linux where to find CASTEP There are several ways to fix this. If you're on a shared machine, it is usually best to make a subdirectory in your home directory, perhaps called \"bin\": mkdir ~/bin and put CASTEP in there (along with any other programs you compile yourself), e.g. cp ~/CASTEP-22.1/obj/linux_x86_64_gfortran--serial/castep.serial ~/bin This still won't mean that Linux will find CASTEP, because this is also not a place it will look for programs. The places Linux looks in are stored in a special Linux environment variable called the \"path\", and the final step is to add the new directory to this \"path\". Exactly how you do this depends on what kind of command-line interpreter (called a \"shell\") you're using in Linux, but there are only really two main kinds: bash and csh. Type export PATH=${PATH}:~/bin if you're using bash, or setenv PATH ${PATH}:~/bin if you're using csh. These commands tell Linux to look in all the places it's looking in already, and also \"~/bin\". If you don't know which shell you're using, try typing: echo $SHELL and see what it says. If it says something like \"/bin/bash\" then you're using bash, if it's \"/bin/csh\" or \"/bin/tcsh\" then it's csh (or close enough). If it gives something else, just try the line starting \"export\" and if it gives an error, try the \"setenv\" one instead. Now try typing \"castep.serial\" and you should see this: Usage: castep <seedname> : Run files <seedname>.cell [and <seedname>.param] \" [-d|--dryrun] <seedname> : Perform a dryrun calculation on files <seedname>.cell \" [-s|--search] <text> : print list of keywords with <text> match in description \" [-v|--version] : print version information \" [-h|--help] <keyword> : describe specific keyword in <>.cell or <>.param \" \" all : print list of all keywords \" \" basic : print list of basic-level keywords \" \" inter : print list of intermediate-level keywords \" \" expert : print list of expert-level keywords \" \" dummy : print list of dummy keywords Automatically adding to your PATH The changes so far will be lost when you exit the command-line. We need to make sure that your directory is added to the PATH variable every time you log in or open a new terminal. If you're using bash, edit the file ~/.bashrc with a text editor (e.g. gedit), go to the end, and add the line to set the PATH: export PATH=${PATH}:~/bin Note that the file is in your home directory (\"~/\"), and the name starts with a dot (\".\" a full stop). Save and exit, and it should all be set up for you. If you're using csh, edit the file \"~/.cshrc\" instead, and add the appropriate line to set the PATH: setenv PATH ${PATH}:~/bin Save and exit, and it should all be set up for you.","title":"Linux help"},{"location":"documentation/Troubleshooting/linux_path/#command-not-found","text":"When you type castep , Linux doesn't know where that command is, so it looks in the places where programs are usually put (often /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin and /usr/local/sbin ; \"bin\" here is short for \"binary\"). Unless CASTEP is there, it will tell you that it can't find it. Notice in particular that the directory you're in when you type the command is not in Linux's list of usual places to look, which is especially confusing when you first encounter it!","title":"Command not found"},{"location":"documentation/Troubleshooting/linux_path/#telling-linux-where-to-find-castep","text":"There are several ways to fix this. If you're on a shared machine, it is usually best to make a subdirectory in your home directory, perhaps called \"bin\": mkdir ~/bin and put CASTEP in there (along with any other programs you compile yourself), e.g. cp ~/CASTEP-22.1/obj/linux_x86_64_gfortran--serial/castep.serial ~/bin This still won't mean that Linux will find CASTEP, because this is also not a place it will look for programs. The places Linux looks in are stored in a special Linux environment variable called the \"path\", and the final step is to add the new directory to this \"path\". Exactly how you do this depends on what kind of command-line interpreter (called a \"shell\") you're using in Linux, but there are only really two main kinds: bash and csh. Type export PATH=${PATH}:~/bin if you're using bash, or setenv PATH ${PATH}:~/bin if you're using csh. These commands tell Linux to look in all the places it's looking in already, and also \"~/bin\". If you don't know which shell you're using, try typing: echo $SHELL and see what it says. If it says something like \"/bin/bash\" then you're using bash, if it's \"/bin/csh\" or \"/bin/tcsh\" then it's csh (or close enough). If it gives something else, just try the line starting \"export\" and if it gives an error, try the \"setenv\" one instead. Now try typing \"castep.serial\" and you should see this: Usage: castep <seedname> : Run files <seedname>.cell [and <seedname>.param] \" [-d|--dryrun] <seedname> : Perform a dryrun calculation on files <seedname>.cell \" [-s|--search] <text> : print list of keywords with <text> match in description \" [-v|--version] : print version information \" [-h|--help] <keyword> : describe specific keyword in <>.cell or <>.param \" \" all : print list of all keywords \" \" basic : print list of basic-level keywords \" \" inter : print list of intermediate-level keywords \" \" expert : print list of expert-level keywords \" \" dummy : print list of dummy keywords","title":"Telling Linux where to find CASTEP"},{"location":"documentation/Troubleshooting/linux_path/#automatically-adding-to-your-path","text":"The changes so far will be lost when you exit the command-line. We need to make sure that your directory is added to the PATH variable every time you log in or open a new terminal. If you're using bash, edit the file ~/.bashrc with a text editor (e.g. gedit), go to the end, and add the line to set the PATH: export PATH=${PATH}:~/bin Note that the file is in your home directory (\"~/\"), and the name starts with a dot (\".\" a full stop). Save and exit, and it should all be set up for you. If you're using csh, edit the file \"~/.cshrc\" instead, and add the appropriate line to set the PATH: setenv PATH ${PATH}:~/bin Save and exit, and it should all be set up for you.","title":"Automatically adding to your PATH"},{"location":"documentation/Troubleshooting/troubleshooting/","text":"CASTEP fails to start Command not found If you see a message like this on the command-line when you run CASTEP: castep mytest castep: command not found then your computer has not located the CASTEP program. Check that: you've used the correct CASTEP name ( castep.serial or castep.mpi ) the CASTEP program is somewhere your computer expects programs to be See here for details of where Linux looks for programs, and how to change it. CASTEP aborts a calculation If CASTEP detects a serious problem, it will stop and write an error message to a .err file. If you are using the parallel version of CASTEP on many cores, you may see error messages from each of these cores. They are named using the same seedname, but with the process ID added, e.g. if CASTEP is run on 2 cores and a serious problem occurs, you might see the files mytest.0001.err mytest.0002.err These files contain useful information about what went wrong, so it is always worth looking at them. Failed to converge","title":"Common errors"},{"location":"documentation/Troubleshooting/troubleshooting/#castep-fails-to-start","text":"","title":"CASTEP fails to start"},{"location":"documentation/Troubleshooting/troubleshooting/#command-not-found","text":"If you see a message like this on the command-line when you run CASTEP: castep mytest castep: command not found then your computer has not located the CASTEP program. Check that: you've used the correct CASTEP name ( castep.serial or castep.mpi ) the CASTEP program is somewhere your computer expects programs to be See here for details of where Linux looks for programs, and how to change it.","title":"Command not found"},{"location":"documentation/Troubleshooting/troubleshooting/#castep-aborts-a-calculation","text":"If CASTEP detects a serious problem, it will stop and write an error message to a .err file. If you are using the parallel version of CASTEP on many cores, you may see error messages from each of these cores. They are named using the same seedname, but with the process ID added, e.g. if CASTEP is run on 2 cores and a serious problem occurs, you might see the files mytest.0001.err mytest.0002.err These files contain useful information about what went wrong, so it is always worth looking at them.","title":"CASTEP aborts a calculation"},{"location":"documentation/Troubleshooting/troubleshooting/#failed-to-converge","text":"","title":"Failed to converge"},{"location":"documentation/Vibrations/overview/","text":"","title":"Vibrations"},{"location":"documentation/XC/XC/","text":"The exchange and correlation functional used for calculations in CASTEP can be specified in one of two main ways. xc_functional The most straightforward is with the .param file keyword xc_functional . For example to use the PBE functional in the .param file simply use xc_functional : PBE There are a number of standard functionals that can be used in CASTEP with the xc_functional keyword: Local density approximation: LDA LDA-X LDA-C Generalised gradient approximations (GGA): PW91 PBE PBEsol RPBE WC BLYP B86PBE PBE_X PBE_C PBEsol_X PBEsol_C B88_X LYP_C Hybrid (non-local) functionals: HF SHF-LDA PBE0 B3LYP HSE03 HSE06 SPBE0 Meta-GGA functionals: RSCAN MS2 xc_definition The keyword xc_definition in the .param file (used instead of xc_functional) is used when you want to modify the standard behaviour of hybrid functionals, or if you want to construct your own hybrid functionals. The simplest use of xc_definition is to replicate that of xc_functional , for example %block xc_definition PBE 1.0 %endblock xc_definition is the same as xc_functional : PBE The \"1.0\" is what weighted fraction of the functional you want, so in this case 1.0 (i.e. 100% PBE). Recall that hybrids are (usually) a mixture of pure (or screened) non-local Hartree-Fock exchange, some local exchange and local correlation. So you could, for example, build a functional that could be 20% Hartree Fock, 80% LDA exchange and 100% LDA correlation. You can run a CASTEP calculation with this using %block xc_definition HF 0.2 LDA-X 0.8 LDA-C 1.0 %endblock xc_definition Examples: 1. B3LYP Firstly you cansimply use xc_functional : B3LYP , however B3LYP is a hybrid functional consisting of a mixture of Hartree-Fock, LDA and B88 exchange, LYP and LDA correlation. This functional can be specified component by component: %block xc_definition LDA-X 0.08 B88_X 0.72 LYP_C 0.81 LDA-C 0.19 HF 0.20 %endblock xc_definition Using the full specification in xc_definition makes it straightforward to adjust the various component weightings to your own specification. There are other adjustments that can be made within the functional. For example the popular functional HSE06 contains a screened Hartree-Fock component, with a mixture of other local functionals. It can be specified component by component as %block xc_definition SHF 0.25 PBE 1.0 PBE_X_SR -0.25 NLXC_SCREENING_LENGTH 0.11 NLXC_SCREENING_FUNCTION ERRORFUNCTION %endblock xc_definition In this case we have 25% screened Hartree-Fock offsetting -25% screened PBE exchange (and 100% PBE correlation within PBE). The default HF screening is exponential, but this can be changed to an error function as shown in the block. Also the strength of the screening can be altered by the NLXC_SCREENING_LENGTH parameter (natural units). 2. Hybrid functionals are expensive calculations, much(!) more computationally intensive than (semi-)local functionals. They are often used because they are able to give much better electronic band gaps. If we do LDA and SHF-LDA band structure for silicon we can use the cell file %block lattice_cart 2.7 2.7 0.0 2.7 0.0 2.7 0.0 2.7 2.7 %endblock lattice_cart %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac symmetry_generate %block spectral_kpoint_path W G X W L G %endblock spectral_kpoint_path %block species_pot NCP %endblock species_pot and then the .param file for LDA task : spectral spectral_task : BandStructure xc_functional : lda and for screened exchange, task : spectral spectral_task : BandStructure xc_functional : shf-lda If we then plot these two band structures together, the difference in results can be seen, the band gap opens from the LDA value of around 0.5eV to a more realistic 1.","title":"Controlling XC"},{"location":"documentation/XC/XCoverview/","text":"There are many sources of description of the role of exchange and correlation within density functional theory, https://en.wikipedia.org/wiki/Density_functional_theory Here we will look at how to give both a basic control over the XC functional that your calculation will use and well as giving finer control over functionals that have free parameters.","title":"Overview"},{"location":"documentation/XC/libXC/","text":"There are many (many!) XC functionals (of varying quality and applicability). LIBXC ( https://www.tddft.org/programs/libxc/ ) is a maintained library of functionals that is upgraded regularly. The list of functionals available in LIBXC is at https://www.tddft.org/programs/libxc/functionals/ . CASTEP interfaces to this library which can be used instead of CASTEP's in-built library of XC functionals. Prepend the string LIBXC_ to CASTEP's functional name in the parameter keyword xc_functional to use LIBXC. For example: xc_functional : PBE for CASTEP's in-built PBE functional xc_functional : LIBXC_PBE for the LIBXC version of the PBE functional In the LIBXC library there are many functionals, covering LDAs, GGAs, Meta-GGAs, Hybrids, etc. Most of these are separated into exchange and correlation contributions. To use these functionals, build your own combination using CASTEP's xc_definition keyword in the .param file. Firstly at https://www.tddft.org/programs/libxc/functionals/ find the exchange and correlation functionals that you require, note the name LIBXC calls is and then prepend the string LIBXC_ to them. For example to construct Perdew and Zunger's LDA, LDA exchange is called LDA_X and correlation is called LDA_C_PZ. In the .param file use %block xc_definition LIBXC_LDA_X 1.0 LIBXC_LDA_C_PZ 1.0 %endblock xc_definition The \"1.0\" after each is the fraction of how much of each you require to use, in this case 100% of each. Example, construct the PBE functional from LIBXC: In LIBXC, PBE exchange is called GGA_X_PBE and its correlation is called GGA_C_PBE. Prepend with LIBXC_ and construct xc_definition : %block xc_definition LIBXC_GGA_X_PBE 1.0 LIBXC_GGA_C_PBE 1.0 %endblock xc_definition There are a few functional in LIBXC that have combined exchange and correlation parts, so this can be listed in xc_definition on its own. For example the HCTH93 XC functional is called GGA_XC_HCTH_93 in LIBXC hence it can be used in CASTEP with %block xc_definition LIBXC_GGA_XC_HCTH_93 1.0 %endblock xc_definition LIBXC can also be used to construct hybrid (non-local) functionals that contain (screened) Hartree-Fock components. Note that LIBXC does not contain the non-local part of such functionals, just the local part. Construct the functional using CASTEP's non-local functionality. For example, the PBE0 functional is called HYB_GGA_XC_PBE0 in LIBXC, so to construct this use %block xc_definition LIBXC_HYB_GGA_XC_PBE0 1.0 HF 0.25 %endblock xc_definition Note here you need to know (ie. read the HYB_GGA_XC_PBE0 reference given in https://www.tddft.org/programs/libxc/functionals/ ) what fraction of local exchange is in the functional and so infer what the fraction of non-local exchange is required (here 0.25). If you want to vary the fraction of non-local exchange then you need to balance this with offsetting it with the correct fraction of local exchange. For this construct the whole functional yourself. For example PBE0 is 0.25HF + 0.75PBE_X + 1.0PBE_C. Varying the HF component in PBE0 can be done with %block xc_definition HF 0.20 LIBXC_GGA_PBE_X 0.80 LIBXC_GGA_PBE_C_1.0 %endblock xc_definition where here it's set to 20% non-local and 80% local exchange, with 100% PBE correlation. Meta-GGAs are also supported. For example the RSCAN functional can be used with %block xc_definition LIBXC_MGGA_X_RSCAN 1.0 LIBXC_MGGA_C_RSCAN 1.0 %endblock xc_definition (although RSCAN is also natively supported in CASTEP with xc_functional : RSCAN ). The xc_definition keyword in the .param file will allow you to mix and match any of the hundreds of functionals in LIBXC https://www.tddft.org/programs/libxc/functionals/ . DO SO WITH EXTREME CAUTION!","title":"libXC"},{"location":"documentation/XRD/overview/","text":"X-ray Structure Factors Basic Theory The X-ray structure factor (SF) intensities can be measured by diffraction experiments involving either X-rays, \\gamma \\gamma -rays or electron beams. It is directly related to the electron density within the unit cell of a material, n(\\mathbf{r}) n(\\mathbf{r}) , by a Fourier transformation 1 : F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, where \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* is the scattering vector corresponding to the (hkl) (hkl) plane, with \\mathbf{a}^*, \\mathbf{b}^* \\mathbf{a}^*, \\mathbf{b}^* and \\mathbf{c}^* \\mathbf{c}^* being the reciprocal lattice vectors of the conventional unit cell. Computation of the SF is difficult within plane-wave pseudopotential DFT codes since the total \"all-electron'' electron density is not normally directly computed and the FFT grids used to house the pseudised valence electron density do not have enough spatial resolution to capture the rapid oscillations near the atomic cores of the total electron density, requiring large plane-wave energy cutoffs in the order of several thousands of eV. Within CASTEP, we have developed an efficient and accurate approach towards calculating these SFs without having to move to large FFT grids or plane-wave energy cutoffs. Details of this implementation can be found in the paper (CITE PAPER WHEN PUBLISHED) but the key observation that has enabled this development is that the electron density can be separated into atom-centred contributions which can be treated on separate radial grids. The resulting structure factor has the form 2 : F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), where f_j(\\mathbf{H}) f_j(\\mathbf{H}) is an effective atomic scattering factor of atom j j within the unit cell, defined to be the Fourier transform of its effective atomic density \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) : f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}. f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}. Incorporating Thermal Effects Within experiments, thermal vibrations (i.e. phonons) can modify the (time-averaged) electron density and, hence, SFs. Making the approximation that the electron density assigned to each atom \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) directly follows its nuclear motion perfectly, the structure factors can incorporate these thermal vibration effects by including an atomic temperature factor T(\\mathbf{H}) T(\\mathbf{H}) : F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). Taking the vibrations of an atom to follow that of a harmonic oscillator, the temperature factor can be shown to be of the form: T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), where \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle are the averaged, squared, thermal displacements of the atom. For the case where the vibrations are isotropic, this equation reduces to: T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), where B is termed the Debye-Waller factor. Keywords Currently, to enable CASTEP (versions 21 and beyond) to calculate X-ray SFs, the desired SFs must be placed between CALCULATE_XRD_SF: and :ENDCALCULATE_XRD_SF within the devel_code block of the seed.param file. For example, the (111) (111) and (200) (200) and (220) (220) SFs can be calculated by appending the following code to the end of the seed.param file: %block devel_code CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, if no structure factors are listed, as in: %block devel_code CALCULATE_XRD_SF: :ENDCALCULATE_XRD_SF %endblock devel_code then the SFs on the entire FFT grid will be written out. Thermal effects can also be incoporated by placing the desired atomic Debye-Waller (DW) factors between DW_FACTOR: and :ENDDW_FACTOR within the devel_code block of the seed.param file. For isotropic DW factors, the value of the DW factor can be written next to the corresponding atomic symbol as below: %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, the entire anisotropic displacement tensor of each atomic species may be specified as follows: %block devel_code DW_FACTOR: Mg 0.305 0.000 0.000 0.000 0.305 0.000 0.000 0.000 0.305 O 0.340 0.000 0.000 0.000 0.340 0.000 0.000 0.000 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Note Structure factor calculations are a post-processing calculation, so they can be restarted from a previous DFT calculation's .check file by using the CONTINUATION parameter in CASTEP. Output Files The resulting structure factors that have been calculated will be outputted into a file named seed.xrd_sf . For the following inputs: ! MgO.param xc_functional : PBE %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 0 0 2 0 2 2 :ENDCALCULATE_XRD_SF %endblock devel_code ! MgO.cell %BLOCK LATTICE_CART ang 4.2112 0.0 0.0 0.0 4.2112 0.0 0.0 0.0 4.2112 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Mg 0.00 0.00 0.00 Mg 0.50 0.50 0.00 Mg 0.50 0.00 0.50 Mg 0.00 0.50 0.50 O 0.00 0.50 0.00 O 0.50 0.00 0.00 O 0.00 0.00 0.50 O 0.50 0.50 0.50 %ENDBLOCK POSITIONS_FRAC kpoint_mp_grid 8 8 8 SYMMETRY_GENERATE We get a resulting seed.xrd_sf file with the output: h k l Re(F_PAW) Im(F_PAW) Re(F_IAM) Im(F_IAM) Re(F_PP) Im(F_PP) Re(F_core) Im(F_core) Re(F_soft) Im(F_soft) Re(F_aug) Im(F_aug) 1 1 1 11.115757 -0.000000 12.492143 -0.000000 10.926445 -0.000000 0.085890 -0.000000 -9.892234 0.000000 20.922101 -0.000000 0 0 2 52.877502 0.000000 51.830521 -0.000000 52.626486 0.000000 15.464656 -0.000000 15.585172 -0.000000 21.827675 0.000000 0 2 2 41.051122 0.000000 40.948429 -0.000000 40.609195 0.000000 14.950468 -0.000000 7.954567 -0.000000 18.146087 0.000000 After the header, the structure factors are listed along each row based on the order in which they have been listed in the seed.param file. Across the columns along each row, the h, k,l h, k,l vectors are first listed before the real and imaginary components of the SF are listed under Re(F_PAW) and Im(F_PAW) respectively. Several other (less accurate) SFs that are commonly found in literature as well as charge contributions to F_PAW are also listed in columns further to the right, as described below: Label Description F_PAW DFT structure factor with all-electron augmentation charge F_IAM Indepedent atom model structure factor; electron densit formed from superposition of atomic electron densities obtained by numerically solving the Koelling-Harmon equation F_PP DFT structure factor with pseudised (inaccurate) augmentation charge F_core Structure factor contribution to F_PAW due to the (frozen) core electrons F_soft Structure factor contribution to F_PAW due to the soft valence charge (where augmentation charge contribute is removed) F_aug Structure factor contribution due to the all-electron valence augmentation charge P. Coppens, X-Ray Charge Densities and Chemical Bonding (International Union of Crystallography, New York, 1997) \u21a9 U. Shmueli and Internationale Union f\u00fcr Kristallographie, editors , International Tables for Crystallography. Vol. B: Reciprocal Space, 2. ed (Kluwer Acad. Publ, Dordrecht, 2001) \u21a9","title":"XRD"},{"location":"documentation/XRD/overview/#x-ray-structure-factors","text":"","title":"X-ray Structure Factors"},{"location":"documentation/XRD/overview/#basic-theory","text":"The X-ray structure factor (SF) intensities can be measured by diffraction experiments involving either X-rays, \\gamma \\gamma -rays or electron beams. It is directly related to the electron density within the unit cell of a material, n(\\mathbf{r}) n(\\mathbf{r}) , by a Fourier transformation 1 : F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, where \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* is the scattering vector corresponding to the (hkl) (hkl) plane, with \\mathbf{a}^*, \\mathbf{b}^* \\mathbf{a}^*, \\mathbf{b}^* and \\mathbf{c}^* \\mathbf{c}^* being the reciprocal lattice vectors of the conventional unit cell. Computation of the SF is difficult within plane-wave pseudopotential DFT codes since the total \"all-electron'' electron density is not normally directly computed and the FFT grids used to house the pseudised valence electron density do not have enough spatial resolution to capture the rapid oscillations near the atomic cores of the total electron density, requiring large plane-wave energy cutoffs in the order of several thousands of eV. Within CASTEP, we have developed an efficient and accurate approach towards calculating these SFs without having to move to large FFT grids or plane-wave energy cutoffs. Details of this implementation can be found in the paper (CITE PAPER WHEN PUBLISHED) but the key observation that has enabled this development is that the electron density can be separated into atom-centred contributions which can be treated on separate radial grids. The resulting structure factor has the form 2 : F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), where f_j(\\mathbf{H}) f_j(\\mathbf{H}) is an effective atomic scattering factor of atom j j within the unit cell, defined to be the Fourier transform of its effective atomic density \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) : f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}. f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}.","title":"Basic Theory"},{"location":"documentation/XRD/overview/#incorporating-thermal-effects","text":"Within experiments, thermal vibrations (i.e. phonons) can modify the (time-averaged) electron density and, hence, SFs. Making the approximation that the electron density assigned to each atom \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) directly follows its nuclear motion perfectly, the structure factors can incorporate these thermal vibration effects by including an atomic temperature factor T(\\mathbf{H}) T(\\mathbf{H}) : F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). Taking the vibrations of an atom to follow that of a harmonic oscillator, the temperature factor can be shown to be of the form: T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), where \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle are the averaged, squared, thermal displacements of the atom. For the case where the vibrations are isotropic, this equation reduces to: T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), where B is termed the Debye-Waller factor.","title":"Incorporating Thermal Effects"},{"location":"documentation/XRD/overview/#keywords","text":"Currently, to enable CASTEP (versions 21 and beyond) to calculate X-ray SFs, the desired SFs must be placed between CALCULATE_XRD_SF: and :ENDCALCULATE_XRD_SF within the devel_code block of the seed.param file. For example, the (111) (111) and (200) (200) and (220) (220) SFs can be calculated by appending the following code to the end of the seed.param file: %block devel_code CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, if no structure factors are listed, as in: %block devel_code CALCULATE_XRD_SF: :ENDCALCULATE_XRD_SF %endblock devel_code then the SFs on the entire FFT grid will be written out. Thermal effects can also be incoporated by placing the desired atomic Debye-Waller (DW) factors between DW_FACTOR: and :ENDDW_FACTOR within the devel_code block of the seed.param file. For isotropic DW factors, the value of the DW factor can be written next to the corresponding atomic symbol as below: %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, the entire anisotropic displacement tensor of each atomic species may be specified as follows: %block devel_code DW_FACTOR: Mg 0.305 0.000 0.000 0.000 0.305 0.000 0.000 0.000 0.305 O 0.340 0.000 0.000 0.000 0.340 0.000 0.000 0.000 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Note Structure factor calculations are a post-processing calculation, so they can be restarted from a previous DFT calculation's .check file by using the CONTINUATION parameter in CASTEP.","title":"Keywords"},{"location":"documentation/XRD/overview/#output-files","text":"The resulting structure factors that have been calculated will be outputted into a file named seed.xrd_sf . For the following inputs: ! MgO.param xc_functional : PBE %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 0 0 2 0 2 2 :ENDCALCULATE_XRD_SF %endblock devel_code ! MgO.cell %BLOCK LATTICE_CART ang 4.2112 0.0 0.0 0.0 4.2112 0.0 0.0 0.0 4.2112 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Mg 0.00 0.00 0.00 Mg 0.50 0.50 0.00 Mg 0.50 0.00 0.50 Mg 0.00 0.50 0.50 O 0.00 0.50 0.00 O 0.50 0.00 0.00 O 0.00 0.00 0.50 O 0.50 0.50 0.50 %ENDBLOCK POSITIONS_FRAC kpoint_mp_grid 8 8 8 SYMMETRY_GENERATE We get a resulting seed.xrd_sf file with the output: h k l Re(F_PAW) Im(F_PAW) Re(F_IAM) Im(F_IAM) Re(F_PP) Im(F_PP) Re(F_core) Im(F_core) Re(F_soft) Im(F_soft) Re(F_aug) Im(F_aug) 1 1 1 11.115757 -0.000000 12.492143 -0.000000 10.926445 -0.000000 0.085890 -0.000000 -9.892234 0.000000 20.922101 -0.000000 0 0 2 52.877502 0.000000 51.830521 -0.000000 52.626486 0.000000 15.464656 -0.000000 15.585172 -0.000000 21.827675 0.000000 0 2 2 41.051122 0.000000 40.948429 -0.000000 40.609195 0.000000 14.950468 -0.000000 7.954567 -0.000000 18.146087 0.000000 After the header, the structure factors are listed along each row based on the order in which they have been listed in the seed.param file. Across the columns along each row, the h, k,l h, k,l vectors are first listed before the real and imaginary components of the SF are listed under Re(F_PAW) and Im(F_PAW) respectively. Several other (less accurate) SFs that are commonly found in literature as well as charge contributions to F_PAW are also listed in columns further to the right, as described below: Label Description F_PAW DFT structure factor with all-electron augmentation charge F_IAM Indepedent atom model structure factor; electron densit formed from superposition of atomic electron densities obtained by numerically solving the Koelling-Harmon equation F_PP DFT structure factor with pseudised (inaccurate) augmentation charge F_core Structure factor contribution to F_PAW due to the (frozen) core electrons F_soft Structure factor contribution to F_PAW due to the soft valence charge (where augmentation charge contribute is removed) F_aug Structure factor contribution due to the all-electron valence augmentation charge P. Coppens, X-Ray Charge Densities and Chemical Bonding (International Union of Crystallography, New York, 1997) \u21a9 U. Shmueli and Internationale Union f\u00fcr Kristallographie, editors , International Tables for Crystallography. Vol. B: Reciprocal Space, 2. ed (Kluwer Acad. Publ, Dordrecht, 2001) \u21a9","title":"Output Files"},{"location":"tutorials/Bands_and_DOS/magnetic/","text":"Iron ! Fe.cell %BLOCK LATTICE_CART -1.433199999999999 1.433200000000001 1.433200000000001 1.433200000000001 -1.433200000000000 1.433200000000000 1.433200000000000 1.433200000000000 -1.433200000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Fe 0.0000000000000000 0.0000000000000000 0.0000000000000000 %ENDBLOCK POSITIONS_FRAC symmetry_generate ! Kpoint grid for the Groundstate (SCF) calculation kpoint_mp_grid 8 8 8 ! kpoint path through the Brillouin Zone for the Bandstructure %BLOCK spectral_KPOINT_PATH 0.0 0.0 0.0 !G 0.5 0.5 0.5 !H 0.5 0.0 0.0 !N 0.0 0.0 0.0 !G 0.75 0.25 -0.25 !P 0.5 0.0 0.0 !N %ENDBLOCK spectral_KPOINT_PATH In the param file we set spin_polarised true in order to allow the up and down spin electrons to take different configurations. It is important to start the calculation with an initial spin density using e.g. spin: 1 . The value of the initial spin should not affect the final answer - a non-zero value is just needed to break the symmetry between the spin channels. ! Fe.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! grid_scale 2.0 ! opt_strategy speed ! Choose algorithms for best speed spin 1 ! Set the spin in the original cell to 1. spin_polarised true ! Run a spin polarised calculation spectral_nbands 6 ! number of bands to compute during the BS run At the end of the calculation the net spin of the unit cell is reported in the castep file e.g. Integrated Spin Density = 2.15322 hbar/2 Note The band structure has similarities with that of Copper - and other 3d elements - with flat 3d bands and dispersive s bands. We colour code the bands according to their spin chactacter (red=up, blue=down). We can see that there is an almost constant exchange splitting of 1.5eV between the up and down 3d bands. The splitting between the s-like bands is much smaller. More up states lie below the fermi energy than down states - hence the net spin of the unit cell. FeO FeO is an anti-ferromagnetic oxide. We set up the calculation with initial spins on the two Fe atoms pointing in opposite directions. ! FeO.cell %BLOCK LATTICE_CART 1.768531594289456 0.000000000000001 5.002162732258922 -0.884265797144728 1.531593288050063 5.002162732258921 -0.884265797144728 -1.531593288050063 5.002162732258922 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC O 0.75 0.750 -1.250 O -0.75 -0.750 1.250 Fe 0.00 0.000 -0.000 spin=-4.0 Fe 1.50 -0.500 -0.500 spin=4.0 %ENDBLOCK POSITIONS_FRAC kpoints_mp_grid: 6 6 6 symmetry_generate %block spectral_kpoint_path 0.500 0.500 0.000 0.000 0.000 0.000 0.500 0.500 0.500 0.000 0.500 0.000 0.000 0.000 0.000 %endblock spectral_kpoint_path ! FeO.param task : spectral ! The TASK keyword instructs CASTEP what to do xc_functional : PBE ! Which exchange-correlation functional to use. cutoff_energy 600 eV opt_strategy speed ! Choose algorithms for speed. nextra_bands : 6 spin_polarized : true A PBE calculation incorrectly finds FeO to be a metal (bandstructure on left below). Add the following to the cell file to run a PBE+U calculation %block hubbard_u Fe 1 d: 2.5 Fe 2 d: 2.5 %endblock hubbard_u FeO band structure with PBE (left) and with PBE+U (right) Note Adding a Hubbard U term to the calculation opens the band gap and FeO is (correctly) predicted to be an antiferromangetic insulator.","title":"Magnetic Materials"},{"location":"tutorials/Bands_and_DOS/magnetic/#iron","text":"! Fe.cell %BLOCK LATTICE_CART -1.433199999999999 1.433200000000001 1.433200000000001 1.433200000000001 -1.433200000000000 1.433200000000000 1.433200000000000 1.433200000000000 -1.433200000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Fe 0.0000000000000000 0.0000000000000000 0.0000000000000000 %ENDBLOCK POSITIONS_FRAC symmetry_generate ! Kpoint grid for the Groundstate (SCF) calculation kpoint_mp_grid 8 8 8 ! kpoint path through the Brillouin Zone for the Bandstructure %BLOCK spectral_KPOINT_PATH 0.0 0.0 0.0 !G 0.5 0.5 0.5 !H 0.5 0.0 0.0 !N 0.0 0.0 0.0 !G 0.75 0.25 -0.25 !P 0.5 0.0 0.0 !N %ENDBLOCK spectral_KPOINT_PATH In the param file we set spin_polarised true in order to allow the up and down spin electrons to take different configurations. It is important to start the calculation with an initial spin density using e.g. spin: 1 . The value of the initial spin should not affect the final answer - a non-zero value is just needed to break the symmetry between the spin channels. ! Fe.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! grid_scale 2.0 ! opt_strategy speed ! Choose algorithms for best speed spin 1 ! Set the spin in the original cell to 1. spin_polarised true ! Run a spin polarised calculation spectral_nbands 6 ! number of bands to compute during the BS run At the end of the calculation the net spin of the unit cell is reported in the castep file e.g. Integrated Spin Density = 2.15322 hbar/2 Note The band structure has similarities with that of Copper - and other 3d elements - with flat 3d bands and dispersive s bands. We colour code the bands according to their spin chactacter (red=up, blue=down). We can see that there is an almost constant exchange splitting of 1.5eV between the up and down 3d bands. The splitting between the s-like bands is much smaller. More up states lie below the fermi energy than down states - hence the net spin of the unit cell.","title":"Iron"},{"location":"tutorials/Bands_and_DOS/magnetic/#feo","text":"FeO is an anti-ferromagnetic oxide. We set up the calculation with initial spins on the two Fe atoms pointing in opposite directions. ! FeO.cell %BLOCK LATTICE_CART 1.768531594289456 0.000000000000001 5.002162732258922 -0.884265797144728 1.531593288050063 5.002162732258921 -0.884265797144728 -1.531593288050063 5.002162732258922 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC O 0.75 0.750 -1.250 O -0.75 -0.750 1.250 Fe 0.00 0.000 -0.000 spin=-4.0 Fe 1.50 -0.500 -0.500 spin=4.0 %ENDBLOCK POSITIONS_FRAC kpoints_mp_grid: 6 6 6 symmetry_generate %block spectral_kpoint_path 0.500 0.500 0.000 0.000 0.000 0.000 0.500 0.500 0.500 0.000 0.500 0.000 0.000 0.000 0.000 %endblock spectral_kpoint_path ! FeO.param task : spectral ! The TASK keyword instructs CASTEP what to do xc_functional : PBE ! Which exchange-correlation functional to use. cutoff_energy 600 eV opt_strategy speed ! Choose algorithms for speed. nextra_bands : 6 spin_polarized : true A PBE calculation incorrectly finds FeO to be a metal (bandstructure on left below). Add the following to the cell file to run a PBE+U calculation %block hubbard_u Fe 1 d: 2.5 Fe 2 d: 2.5 %endblock hubbard_u FeO band structure with PBE (left) and with PBE+U (right) Note Adding a Hubbard U term to the calculation opens the band gap and FeO is (correctly) predicted to be an antiferromangetic insulator.","title":"FeO"},{"location":"tutorials/Bands_and_DOS/metals/","text":"Here we use CASTEP to calculate the bandstructure of two typical metals. The cell and param files are very similar to the semiconductor examples - the one difference is that we use a finer sampling of the Brillouin Zone with the keyword kpoint_mp_grid . A finer sampling is needed to correctly represent the change in occupancy at the Fermi energy. Aluminium ! Al.cell %BLOCK LATTICE_ABC 2.86 2.86 2.86 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Al 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Al.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Aluminium is a metal - there is no gap energy between the occupied and unoccupied states. The bands are close to parabolic (this is particularly noticeable around Gamma) - the electronic structure of aluminium closely follows a nearly-free electron model. Copper ! Cu.cell %BLOCK LATTICE_ABC 2.55 2.55 2.55 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Cu 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Cu.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed at expense of memory. spectral_nbands 8 ! Note Copper is a metal - there is no gap energy between the occupied and unoccupied states. The bandstructure of copper is typical for a transition metal - we have highly dispersive parabolic bands corresponding to the s electrons, these are crossed by 5 quite flat bands corresponding to more localised 3d electrons. In copper the 3d states are filled, and we see the flat bands lie below the Fermi level.","title":"Metals"},{"location":"tutorials/Bands_and_DOS/metals/#aluminium","text":"! Al.cell %BLOCK LATTICE_ABC 2.86 2.86 2.86 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Al 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Al.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Aluminium is a metal - there is no gap energy between the occupied and unoccupied states. The bands are close to parabolic (this is particularly noticeable around Gamma) - the electronic structure of aluminium closely follows a nearly-free electron model.","title":"Aluminium"},{"location":"tutorials/Bands_and_DOS/metals/#copper","text":"! Cu.cell %BLOCK LATTICE_ABC 2.55 2.55 2.55 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Cu 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Cu.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed at expense of memory. spectral_nbands 8 ! Note Copper is a metal - there is no gap energy between the occupied and unoccupied states. The bandstructure of copper is typical for a transition metal - we have highly dispersive parabolic bands corresponding to the s electrons, these are crossed by 5 quite flat bands corresponding to more localised 3d electrons. In copper the 3d states are filled, and we see the flat bands lie below the Fermi level.","title":"Copper"},{"location":"tutorials/Bands_and_DOS/plotting_perl/","text":"In this tutorial we will walk through plotting a bandstructure and density of states using the perl utilities supplied with CASTEP. We will use Xmgace for plotting - however, the scripts also support gnuplot. Bandstructure Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dispersion.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dispersion.pl -h' castep si-bands dispersion.pl -sym fcc -xg si-bands.bands You should get a plot Density of States Here is a cell file. It is the same as a bandstructure cell file except we have replaced the path through the Brillioun zone with a regular grid of k-points. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a uniform sampling of the Brillouin Zone ! spectral_kpoint_mp_grid 17 17 17 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task dos ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dos.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dos.pl -h' castep si-dos dos.pl -xg si-dos.bands -w 0.3 You should get a plot like Note The procedure above is inefficient as we computed the groundstate of the system twice, once when computing the bandstructure and again when computing the dos. To avoid this we could put the following line in the si-dos.param file continuation: si-bands.check . This will restart the calculation of the dos using the previously computed groundstate.","title":"Plotting - CASTEP tools"},{"location":"tutorials/Bands_and_DOS/plotting_perl/#bandstructure","text":"Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dispersion.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dispersion.pl -h' castep si-bands dispersion.pl -sym fcc -xg si-bands.bands You should get a plot","title":"Bandstructure"},{"location":"tutorials/Bands_and_DOS/plotting_perl/#density-of-states","text":"Here is a cell file. It is the same as a bandstructure cell file except we have replaced the path through the Brillioun zone with a regular grid of k-points. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a uniform sampling of the Brillouin Zone ! spectral_kpoint_mp_grid 17 17 17 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task dos ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dos.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dos.pl -h' castep si-dos dos.pl -xg si-dos.bands -w 0.3 You should get a plot like Note The procedure above is inefficient as we computed the groundstate of the system twice, once when computing the bandstructure and again when computing the dos. To avoid this we could put the following line in the si-dos.param file continuation: si-bands.check . This will restart the calculation of the dos using the previously computed groundstate.","title":"Density of States"},{"location":"tutorials/Bands_and_DOS/plotting_sumo/","text":"This is stub for https://github.com/ajjackson/castep-sumo-tutorial/blob/master/castep-sumo.org","title":"Plotting - SUMO"},{"location":"tutorials/Bands_and_DOS/semiconductors/","text":"In this tutorial we will show you the cell and param files needed to plot bandstructures and density of states plots for various semiconductors. For the commands needed to make the plots refer to earlier tutorials. Silicon ! Si.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path ! Si.cell task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Silicon is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is indirect as the valence band maximum is as Gamma, but the conduction band minimum lies between Gamma and X. Gallium Arsenide The cell file is almost identical to the silicon example above, except that the unitc cell length is slighly larger, and we have replaced one Si atom with Ga, and the other Si with As. ! GaAs.cell %block lattice_abc 4 4 4 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Ga 0.00 0.00 0.00 As 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path The param file is unchanged from the Silicon example ! GaAs.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note GaAs is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is direct both the valence band maximum and conduction band minimum are at Gamma. Compared with Silicon we see that the original bandstructure contains low lying flat bands at around -32eV and -12eV. This is because both the Ga and As pseudopotentials include semi-core states in the valence. The red states are the As 3d and the green are the Ga 3d.","title":"Semiconductors"},{"location":"tutorials/Bands_and_DOS/semiconductors/#silicon","text":"! Si.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path ! Si.cell task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Silicon is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is indirect as the valence band maximum is as Gamma, but the conduction band minimum lies between Gamma and X.","title":"Silicon"},{"location":"tutorials/Bands_and_DOS/semiconductors/#gallium-arsenide","text":"The cell file is almost identical to the silicon example above, except that the unitc cell length is slighly larger, and we have replaced one Si atom with Ga, and the other Si with As. ! GaAs.cell %block lattice_abc 4 4 4 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Ga 0.00 0.00 0.00 As 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path The param file is unchanged from the Silicon example ! GaAs.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note GaAs is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is direct both the valence band maximum and conduction band minimum are at Gamma. Compared with Silicon we see that the original bandstructure contains low lying flat bands at around -32eV and -12eV. This is because both the Ga and As pseudopotentials include semi-core states in the valence. The red states are the As 3d and the green are the Ga 3d.","title":"Gallium Arsenide"},{"location":"tutorials/Bonding_and_Charge/charge_density/","text":"In this tutorial we will walk through plotting a charge density with Vesta https://jp-minerals.org/vesta/en/ Silicon Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 1500 eV #this next line causes the charge to be written in a den_fmt file write_formatted_density : T spin_polarised : false The cutoff energy is somewhat higher than needed for a converged total energy - but it helps when making a smoother looking charge density plot. Run castep. You will see a file called silicon.den_fmt this contains the charge density in a formatted (i.e. a human readable, ASCII file). We need to change this file into a format Vesta can read. Copy it to a file called silicon.charg_frm cp silicon.den_fmt silicon.charg_frm Now edit the file silicon.charg_frm with a text editor to remove the first 11 lines. The file should now begin with 1 1 1 and a number. You can now open silicon.charg_frm with Vesta. Note that Vesta needs both the cell and charge_frm files to make a plot. If you are working on a remote machine you will need to copy both of these back to your local machine to view with Vesta. You can find a walkthrough video of this process at https://youtu.be/_c2Hk4jxmm4 An alternative way to plot charge densities (and much more besides) is c2x https://www.c2x.org.uk","title":"Plotting Charge Density"},{"location":"tutorials/Bonding_and_Charge/charge_density/#silicon","text":"Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 1500 eV #this next line causes the charge to be written in a den_fmt file write_formatted_density : T spin_polarised : false The cutoff energy is somewhat higher than needed for a converged total energy - but it helps when making a smoother looking charge density plot. Run castep. You will see a file called silicon.den_fmt this contains the charge density in a formatted (i.e. a human readable, ASCII file). We need to change this file into a format Vesta can read. Copy it to a file called silicon.charg_frm cp silicon.den_fmt silicon.charg_frm Now edit the file silicon.charg_frm with a text editor to remove the first 11 lines. The file should now begin with 1 1 1 and a number. You can now open silicon.charg_frm with Vesta. Note that Vesta needs both the cell and charge_frm files to make a plot. If you are working on a remote machine you will need to copy both of these back to your local machine to view with Vesta. You can find a walkthrough video of this process at https://youtu.be/_c2Hk4jxmm4 An alternative way to plot charge densities (and much more besides) is c2x https://www.c2x.org.uk","title":"Silicon"},{"location":"tutorials/Bonding_and_Charge/mulliken_population/","text":"By default castep will calculate the Mulliken Population analysis at the end of every calculation (the keyword popn_calculate is set to true by default). Silicon Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 500 eV spin_polarised : false Run castep. Toward the end of the file silicon.castep you will find Atomic Populations (Mulliken) ----------------------------- Species Ion s p d f Total Charge (e) ========================================================================== Si 1 1.356 2.644 0.000 0.000 4.000 0.000 Si 2 1.356 2.644 0.000 0.000 4.000 0.000 ========================================================================== Bond Population Length (A) ====================================================================== Si 1 -- Si 2 2.99 2.32702 ====================================================================== The atoms are not charged overall, and there is a large bond population. This is all indicative of a strong covalent bond. To finish","title":"Population Analysis"},{"location":"tutorials/Bonding_and_Charge/mulliken_population/#silicon","text":"Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 500 eV spin_polarised : false Run castep. Toward the end of the file silicon.castep you will find Atomic Populations (Mulliken) ----------------------------- Species Ion s p d f Total Charge (e) ========================================================================== Si 1 1.356 2.644 0.000 0.000 4.000 0.000 Si 2 1.356 2.644 0.000 0.000 4.000 0.000 ========================================================================== Bond Population Length (A) ====================================================================== Si 1 -- Si 2 2.99 2.32702 ====================================================================== The atoms are not charged overall, and there is a large bond population. This is all indicative of a strong covalent bond.","title":"Silicon"},{"location":"tutorials/Bonding_and_Charge/mulliken_population/#to-finish","text":"","title":"To finish"},{"location":"tutorials/Delta_SCF/lin_ex_delta_scf/","text":"Electronic excitations of NO on Ni(001) ATTENTION: These calculations are done using standard on-the-fly pseudopotentials from CASTEP-6.0.1 For this example we calculate a charge neutral HOMO->LUMO excitation and a charge transfer excitation between a nickel substrate and a NO molecule In the following, the required input files are: no-on-ni001.param, no-on-ni001.cell, no-on-ni001.deltascf, gasphase.cell, gasphase.param, gasphase.check no-on-ni001.param #%BLOCK DEVEL_CODE #DeltaSCF #%ENDBLOCK DEVEL_CODE #reuse: default task: SinglePoint spin_polarized : True cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay mix_history_length : 7 nextra_bands : 50 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.15 xc_functional : RPBE no-on-ni001.cell %BLOCK LATTICE_CART 3.5240000000 0.0000000000 0.0000000000 0.0000000000 3.5240000000 0.0000000000 0.0000000000 0.0000000000 23.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS Ni 1.762000 0.000000 1.762000 Ni 0.000000 1.762000 1.762000 Ni 0.000000 0.000000 3.524000 Ni 1.762000 1.762000 3.524000 Ni 1.762000 0.000000 5.286000 Ni 0.000000 1.762000 5.286000 N 1.7620 0.0000 7.0196 O 1.7620 -0.0000 8.1902 %ENDBLOCK POSITIONS_ABS %BLOCK IONIC_CONSTRAINTS 1 Ni 1 1 0 0 2 Ni 1 0 1 0 3 Ni 1 0 0 1 4 Ni 2 1 0 0 5 Ni 2 0 1 0 6 Ni 2 0 0 1 7 Ni 3 1 0 0 8 Ni 3 0 1 0 9 Ni 3 0 0 1 10 Ni 4 1 0 0 11 Ni 4 0 1 0 12 Ni 4 0 0 1 13 Ni 5 1 0 0 14 Ni 5 0 1 0 15 Ni 5 0 0 1 16 Ni 6 1 0 0 17 Ni 6 0 1 0 18 Ni 6 0 0 1 %ENDBLOCK IONIC_CONSTRAINTS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 no-on-ni001.deltascf deltascf_file : gasphase.check deltascf_iprint : 1 deltascf_mode : 3 deltascf_constraint : 5 0.0000 1 deltascf_constraint : 6 1.0000 2 gasphase.cell %BLOCK LATTICE_CART 3.5240000000 0.0000000000 0.0000000000 0.0000000000 3.5240000000 0.0000000000 0.0000000000 0.0000000000 23.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS N 1.7620 0.0000 7.0196 O 1.7620 -0.0000 8.1902 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 gasphase.param task: SinglePoint spin_polarized : True cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 10 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : RPBE The workflow is as follows: Calculate reference states (gasphase.check). These can be ground state Kohn-Sham states or themselves excited KS states Calculate the ground state of NO on Ni(001) Final energy, E = -7867.950085034 eV Calculate the leDeltaSCF excitation We calculate a charge transfer from the molecule to the surface by removing an electron from the HOMO in the majority spin channel deltascf_constraint : 5 0.0000 1 WARNING : A sufficient number of virtual states in the calculation, controlled by the keyword nextra_states, is very important. The more virtual states are used explicitly, the more complete is the projection onto the space of KS states. Sometimes states are almost degenerate and we also need to constrain the occupation of the other state to ensure that the population doesn\\'t just switch between the two. In some cases, convergence can be very slow and a large number of SCF steps is necessary. The resulting excitation energy is 0.46 eV. Final energy, E = -7867.487338823 eV We can calculate an intramolecular triplet excitation from HOMO to LUMO with the following constraint sequence in \\<seed>.deltascf. This excites 1 electron from the HOMO in the majority spin channel to the LUMO in the minority spin channel. deltascf_constraint : 5 0.0000 1 deltascf_constraint : 6 1.0000 2 The resulting excitation energy is 9.17 eV. Final energy, E = -7858.779610351 eV","title":"Linear expansion DeltaSCF"},{"location":"tutorials/Delta_SCF/lin_ex_delta_scf/#electronic-excitations-of-no-on-ni001","text":"ATTENTION: These calculations are done using standard on-the-fly pseudopotentials from CASTEP-6.0.1 For this example we calculate a charge neutral HOMO->LUMO excitation and a charge transfer excitation between a nickel substrate and a NO molecule In the following, the required input files are: no-on-ni001.param, no-on-ni001.cell, no-on-ni001.deltascf, gasphase.cell, gasphase.param, gasphase.check no-on-ni001.param #%BLOCK DEVEL_CODE #DeltaSCF #%ENDBLOCK DEVEL_CODE #reuse: default task: SinglePoint spin_polarized : True cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay mix_history_length : 7 nextra_bands : 50 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.15 xc_functional : RPBE no-on-ni001.cell %BLOCK LATTICE_CART 3.5240000000 0.0000000000 0.0000000000 0.0000000000 3.5240000000 0.0000000000 0.0000000000 0.0000000000 23.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS Ni 1.762000 0.000000 1.762000 Ni 0.000000 1.762000 1.762000 Ni 0.000000 0.000000 3.524000 Ni 1.762000 1.762000 3.524000 Ni 1.762000 0.000000 5.286000 Ni 0.000000 1.762000 5.286000 N 1.7620 0.0000 7.0196 O 1.7620 -0.0000 8.1902 %ENDBLOCK POSITIONS_ABS %BLOCK IONIC_CONSTRAINTS 1 Ni 1 1 0 0 2 Ni 1 0 1 0 3 Ni 1 0 0 1 4 Ni 2 1 0 0 5 Ni 2 0 1 0 6 Ni 2 0 0 1 7 Ni 3 1 0 0 8 Ni 3 0 1 0 9 Ni 3 0 0 1 10 Ni 4 1 0 0 11 Ni 4 0 1 0 12 Ni 4 0 0 1 13 Ni 5 1 0 0 14 Ni 5 0 1 0 15 Ni 5 0 0 1 16 Ni 6 1 0 0 17 Ni 6 0 1 0 18 Ni 6 0 0 1 %ENDBLOCK IONIC_CONSTRAINTS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 no-on-ni001.deltascf deltascf_file : gasphase.check deltascf_iprint : 1 deltascf_mode : 3 deltascf_constraint : 5 0.0000 1 deltascf_constraint : 6 1.0000 2 gasphase.cell %BLOCK LATTICE_CART 3.5240000000 0.0000000000 0.0000000000 0.0000000000 3.5240000000 0.0000000000 0.0000000000 0.0000000000 23.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS N 1.7620 0.0000 7.0196 O 1.7620 -0.0000 8.1902 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 gasphase.param task: SinglePoint spin_polarized : True cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 10 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : RPBE The workflow is as follows: Calculate reference states (gasphase.check). These can be ground state Kohn-Sham states or themselves excited KS states Calculate the ground state of NO on Ni(001) Final energy, E = -7867.950085034 eV Calculate the leDeltaSCF excitation We calculate a charge transfer from the molecule to the surface by removing an electron from the HOMO in the majority spin channel deltascf_constraint : 5 0.0000 1 WARNING : A sufficient number of virtual states in the calculation, controlled by the keyword nextra_states, is very important. The more virtual states are used explicitly, the more complete is the projection onto the space of KS states. Sometimes states are almost degenerate and we also need to constrain the occupation of the other state to ensure that the population doesn\\'t just switch between the two. In some cases, convergence can be very slow and a large number of SCF steps is necessary. The resulting excitation energy is 0.46 eV. Final energy, E = -7867.487338823 eV We can calculate an intramolecular triplet excitation from HOMO to LUMO with the following constraint sequence in \\<seed>.deltascf. This excites 1 electron from the HOMO in the majority spin channel to the LUMO in the minority spin channel. deltascf_constraint : 5 0.0000 1 deltascf_constraint : 6 1.0000 2 The resulting excitation energy is 9.17 eV. Final energy, E = -7858.779610351 eV","title":"Electronic excitations of NO on Ni(001)"},{"location":"tutorials/Delta_SCF/molpdos/","text":"NO molecule on Ni(001) For this example we calculate the projected MOs of a NO molecule on a Ni(001) slab. In the following the required input files are: no-on-ni001.param, no-on-ni001.cell, no-on-ni001.deltascf, no-on-ni001.molpdos, gasphase.cell, gasphase.param, gasphase.check no-on-ni001.param %BLOCK DEVEL_CODE MolPDOS %ENDBLOCK DEVEL_CODE task: SinglePoint spin_polarized : True cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 10 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : RPBE no-on-ni001.cell %BLOCK LATTICE_CART 3.5240000000 0.0000000000 0.0000000000 0.0000000000 3.5240000000 0.0000000000 0.0000000000 0.0000000000 23.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS Ni 1.762000 0.000000 1.762000 Ni 0.000000 1.762000 1.762000 Ni 0.000000 0.000000 3.524000 Ni 1.762000 1.762000 3.524000 Ni 1.762000 0.000000 5.286000 Ni 0.000000 1.762000 5.286000 N 1.7620 0.0000 7.0196 O 1.7620 -0.0000 8.1902 %ENDBLOCK POSITIONS_ABS %BLOCK IONIC_CONSTRAINTS 1 Ni 1 1 0 0 2 Ni 1 0 1 0 3 Ni 1 0 0 1 4 Ni 2 1 0 0 5 Ni 2 0 1 0 6 Ni 2 0 0 1 7 Ni 3 1 0 0 8 Ni 3 0 1 0 9 Ni 3 0 0 1 10 Ni 4 1 0 0 11 Ni 4 0 1 0 12 Ni 4 0 0 1 13 Ni 5 1 0 0 14 Ni 5 0 1 0 15 Ni 5 0 0 1 16 Ni 6 1 0 0 17 Ni 6 0 1 0 18 Ni 6 0 0 1 %ENDBLOCK IONIC_CONSTRAINTS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 no-on-ni001.deltascf deltascf_file : gasphase molpdos_state : 4 1 molpdos_state : 5 1 molpdos_state : 6 1 molpdos_state : 4 2 molpdos_state : 5 2 molpdos_state : 6 2 no-on-ni001.molpdos molpdos_state : 4 1 molpdos_state : 5 1 molpdos_state : 6 1 molpdos_state : 4 2 molpdos_state : 5 2 molpdos_state : 6 2 molpdos_bin_width : 0.01 molpdos_smearing : 0.10 molpdos_scaling : 1.00 axis_energy_margin : 2.00 output_filename : MolPDOS.dat gasphase.cell %BLOCK LATTICE_CART 3.5240000000 0.0000000000 0.0000000000 0.0000000000 3.5240000000 0.0000000000 0.0000000000 0.0000000000 23.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS N 1.7620 0.0000 7.0196 O 1.7620 -0.0000 8.1902 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 gasphase.param task: SinglePoint spin_polarized : True cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 10 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : RPBE After generating gasphase.check by running CASTEP on the gasphase.param and gasphase.cell files, we execute CASTEP and post-process with MolPDOS. This will write x-y data files for the Total DOS, the separate spin channels, and the MolPDOS peaks. The following image shows the Total DOS and the two spin channels. {.align-center} The next picture shows the frontier orbitals of spin channel 1 projected on the total DOS. Especially the LUMO shows strong hybridization with the Nickel d-bands and also is partially occupied. The left scale refers to the total DOS, whereas the right y-scale shows the peak height of the projected MOs. {.align-center} ---------------------------------------Example 5: Putting it all together: CO on Cu(100) --------------------------------------- For this example we analyze the electronic structure of a CO molecule in a c(2x2) overlayer on Cu(100), before we use this information to calculate the correct electronic transitions. In the following, the required input files are: co-on-cu100.param, co-on-cu100.cell, co-on-cu100.deltascf, gasphase.cell, gasphase.param, gasphase.deltascf co-on-cu100.param #%BLOCK DEVEL_CODE #DEVEL_CODE : DeltaSCF #%ENDBLOCK DEVEL_CODE #reuse: default task: SinglePoint spin_polarized : False cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 50 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : PBE co-on-cu100.cell %BLOCK LATTICE_CART 0.0000000000000000 -3.6320000000000001 0.0000000000000000 3.6320000000000001 0.0000000000000000 0.0000000000000000 0.0000000000 0.0000000000 23.614900000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS Cu 0.02575600 -3.70271100 -7.26400000 Cu 1.84175600 -1.88671100 -7.26400000 Cu 0.02575600 -1.88671100 -5.44800000 Cu 1.84175600 -3.70271100 -5.44800000 Cu 0.02575600 -3.70271100 -3.63200000 Cu 1.84175600 -1.88671100 -3.63200000 Cu 0.02575600 -1.88671100 -1.81600000 Cu 1.84175600 -3.70271100 -1.81600000 Cu 0.02575600 -3.70271100 0.00000000 Cu 1.84175600 -1.88671100 0.00000000 C 0.02575600 -3.70271100 1.90000000 O 0.02575600 -3.70271100 3.00000000 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 co-on-cu100.deltascf deltascf_iprint : 1 deltascf_mode : 3 deltascf_file : gasphase.check deltascf_constraint : 5 0.5000 1 deltascf_constraint : 6 0.5000 2 gasphase.param #reuse: default task: SinglePoint spin_polarized : False cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 50 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : PBE gasphase.cell %BLOCK LATTICE_CART 0.0000000000000000 -3.6320000000000001 0.0000000000000000 3.6320000000000001 0.0000000000000000 0.0000000000000000 0.0000000000 0.0000000000 23.614900000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS C 0.02575600 -3.70271100 1.90000000 O 0.02575600 -3.70271100 3.00000000 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 gasphase.deltascf deltascf_mode : 1 deltascf_iprint : 1 deltascf_constraint : 5 0.5000 1 5 5 deltascf_constraint : 6 0.5000 1 6 6 deltascf_smearing : 0.01 We start out by calculating the groundstate of the adsorbed molecule and the ground state of the gasphase molecule and by analyzing the MOlPDOS of CO on Cu(100). GOOD TO KNOW : If you ever forget the correct input for \\<seed>.deltascf or \\<seed>.molpdos, just run the MolPDOS tool without seed. The printed information is all you need! TO DO","title":"Molecular Projected DOS"},{"location":"tutorials/Delta_SCF/molpdos/#no-molecule-on-ni001","text":"For this example we calculate the projected MOs of a NO molecule on a Ni(001) slab. In the following the required input files are: no-on-ni001.param, no-on-ni001.cell, no-on-ni001.deltascf, no-on-ni001.molpdos, gasphase.cell, gasphase.param, gasphase.check no-on-ni001.param %BLOCK DEVEL_CODE MolPDOS %ENDBLOCK DEVEL_CODE task: SinglePoint spin_polarized : True cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 10 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : RPBE no-on-ni001.cell %BLOCK LATTICE_CART 3.5240000000 0.0000000000 0.0000000000 0.0000000000 3.5240000000 0.0000000000 0.0000000000 0.0000000000 23.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS Ni 1.762000 0.000000 1.762000 Ni 0.000000 1.762000 1.762000 Ni 0.000000 0.000000 3.524000 Ni 1.762000 1.762000 3.524000 Ni 1.762000 0.000000 5.286000 Ni 0.000000 1.762000 5.286000 N 1.7620 0.0000 7.0196 O 1.7620 -0.0000 8.1902 %ENDBLOCK POSITIONS_ABS %BLOCK IONIC_CONSTRAINTS 1 Ni 1 1 0 0 2 Ni 1 0 1 0 3 Ni 1 0 0 1 4 Ni 2 1 0 0 5 Ni 2 0 1 0 6 Ni 2 0 0 1 7 Ni 3 1 0 0 8 Ni 3 0 1 0 9 Ni 3 0 0 1 10 Ni 4 1 0 0 11 Ni 4 0 1 0 12 Ni 4 0 0 1 13 Ni 5 1 0 0 14 Ni 5 0 1 0 15 Ni 5 0 0 1 16 Ni 6 1 0 0 17 Ni 6 0 1 0 18 Ni 6 0 0 1 %ENDBLOCK IONIC_CONSTRAINTS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 no-on-ni001.deltascf deltascf_file : gasphase molpdos_state : 4 1 molpdos_state : 5 1 molpdos_state : 6 1 molpdos_state : 4 2 molpdos_state : 5 2 molpdos_state : 6 2 no-on-ni001.molpdos molpdos_state : 4 1 molpdos_state : 5 1 molpdos_state : 6 1 molpdos_state : 4 2 molpdos_state : 5 2 molpdos_state : 6 2 molpdos_bin_width : 0.01 molpdos_smearing : 0.10 molpdos_scaling : 1.00 axis_energy_margin : 2.00 output_filename : MolPDOS.dat gasphase.cell %BLOCK LATTICE_CART 3.5240000000 0.0000000000 0.0000000000 0.0000000000 3.5240000000 0.0000000000 0.0000000000 0.0000000000 23.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS N 1.7620 0.0000 7.0196 O 1.7620 -0.0000 8.1902 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 gasphase.param task: SinglePoint spin_polarized : True cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 10 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : RPBE After generating gasphase.check by running CASTEP on the gasphase.param and gasphase.cell files, we execute CASTEP and post-process with MolPDOS. This will write x-y data files for the Total DOS, the separate spin channels, and the MolPDOS peaks. The following image shows the Total DOS and the two spin channels. {.align-center} The next picture shows the frontier orbitals of spin channel 1 projected on the total DOS. Especially the LUMO shows strong hybridization with the Nickel d-bands and also is partially occupied. The left scale refers to the total DOS, whereas the right y-scale shows the peak height of the projected MOs. {.align-center} ---------------------------------------Example 5: Putting it all together: CO on Cu(100) --------------------------------------- For this example we analyze the electronic structure of a CO molecule in a c(2x2) overlayer on Cu(100), before we use this information to calculate the correct electronic transitions. In the following, the required input files are: co-on-cu100.param, co-on-cu100.cell, co-on-cu100.deltascf, gasphase.cell, gasphase.param, gasphase.deltascf co-on-cu100.param #%BLOCK DEVEL_CODE #DEVEL_CODE : DeltaSCF #%ENDBLOCK DEVEL_CODE #reuse: default task: SinglePoint spin_polarized : False cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 50 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : PBE co-on-cu100.cell %BLOCK LATTICE_CART 0.0000000000000000 -3.6320000000000001 0.0000000000000000 3.6320000000000001 0.0000000000000000 0.0000000000000000 0.0000000000 0.0000000000 23.614900000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS Cu 0.02575600 -3.70271100 -7.26400000 Cu 1.84175600 -1.88671100 -7.26400000 Cu 0.02575600 -1.88671100 -5.44800000 Cu 1.84175600 -3.70271100 -5.44800000 Cu 0.02575600 -3.70271100 -3.63200000 Cu 1.84175600 -1.88671100 -3.63200000 Cu 0.02575600 -1.88671100 -1.81600000 Cu 1.84175600 -3.70271100 -1.81600000 Cu 0.02575600 -3.70271100 0.00000000 Cu 1.84175600 -1.88671100 0.00000000 C 0.02575600 -3.70271100 1.90000000 O 0.02575600 -3.70271100 3.00000000 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 co-on-cu100.deltascf deltascf_iprint : 1 deltascf_mode : 3 deltascf_file : gasphase.check deltascf_constraint : 5 0.5000 1 deltascf_constraint : 6 0.5000 2 gasphase.param #reuse: default task: SinglePoint spin_polarized : False cut_off_energy : 400.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 50 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : PBE gasphase.cell %BLOCK LATTICE_CART 0.0000000000000000 -3.6320000000000001 0.0000000000000000 3.6320000000000001 0.0000000000000000 0.0000000000000000 0.0000000000 0.0000000000 23.614900000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS C 0.02575600 -3.70271100 1.90000000 O 0.02575600 -3.70271100 3.00000000 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 2 2 1 KPOINTS_MP_OFFSET : 0.25 0.25 0.25 gasphase.deltascf deltascf_mode : 1 deltascf_iprint : 1 deltascf_constraint : 5 0.5000 1 5 5 deltascf_constraint : 6 0.5000 1 6 6 deltascf_smearing : 0.01 We start out by calculating the groundstate of the adsorbed molecule and the ground state of the gasphase molecule and by analyzing the MOlPDOS of CO on Cu(100). GOOD TO KNOW : If you ever forget the correct input for \\<seed>.deltascf or \\<seed>.molpdos, just run the MolPDOS tool without seed. The printed information is all you need! TO DO","title":"NO molecule on Ni(001)"},{"location":"tutorials/Delta_SCF/simple_delta_scf/","text":"Electronic excitations of the Azobenzene molecule In this example we calculate the first two electronic excited states of E-Azobenzene in a supercell. The required files are azo.cell, azo.param, azo.deltascf azo.param task: SinglePoint %BLOCK DEVEL_CODE DeltaSCF %ENDBLOCK DEVEL_CODE reuse: default spin_polarized : False cut_off_energy : 350.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 10 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : PBE azo.cell %BLOCK LATTICE_CART 10.0000000 0.0000000000 0.0000000000 0.0000000000 20.0000000 0.0000000000 0.0000000000 0.0000000000 10.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS C -6.72081 -1.66625 0.00000 C -6.64967 -0.26964 0.00000 C -5.40647 0.36858 -0.00000 C -4.23175 -0.38857 -0.00000 C -4.29745 -1.78579 -0.00000 C -5.54882 -2.43430 -0.00000 H -7.68820 -2.15296 0.00000 H -7.55879 0.31772 0.00000 H -5.35348 1.44963 -0.00000 H -3.26966 0.10734 -0.00000 H -3.37789 -2.35693 -0.00000 N -5.65342 -3.85046 -0.00000 N -4.64259 -4.58194 -0.00000 C -4.75058 -5.99808 -0.00000 C -6.00434 -6.64214 -0.00000 C -6.07567 -8.03881 -0.00000 C -4.90409 -8.80053 -0.00000 C -3.65828 -8.16721 -0.00000 C -3.58139 -6.77065 -0.00000 H -2.61200 -6.28795 -0.00000 H -6.92178 -6.06761 -0.00000 H -7.03986 -8.53061 -0.00000 H -4.96168 -9.88134 -0.00000 H -2.75170 -8.75849 -0.00000 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 1 1 1 azo.deltascf deltascf_mode : 1 deltascf_iprint : 1 # mode 1 constraints ## # band occ spin from_band to_band deltascf_constraint : 34 0.5000 1 34 34 deltascf_constraint : 35 0.5000 1 35 35 We start by calculating the total DFT ground state energy as Final energy, E = -2597.665647686 eV Now we reuse the calculated wavefunctions and switch to the DeltaSCF calculation %BLOCK DEVEL_CODE DeltaSCF %ENDBLOCK DEVEL_CODE There are 68 valence electrons. Therefore, for this non-spin-polarized system the HOMO orbital is orbital no. 34. The LUMO is orbital no. 35. The first two excited states of azobenzene are known to be S1(n->pi*) and S2(pi->pi*) transitions between the HOMO and LUMO and the HOMO-1 and the LUMO. The corresponding constraint sequence in azo.deltascf for the S1 excitation is deltascf_constraint : 34 0.5000 1 34 34 deltascf_constraint : 35 0.5000 1 35 35 WARNING : When running non-spin-polarized calculations, orbital occupations range from 0 to 1. !!When running a spin-polarized calculation, they also range from 0 to 1, although they contain 0 to 2 electrons. In this (non-spin-polarized) case, if we want to transfer an electron from the HOMO(34) to LUMO(35) we need to enforce the occupation of both to be 0.50. Feel free to increase the print level with deltascf_iprint to study the output in more detail. The corresponding total energy is Final energy, E = -2595.702720896 eV This corresponds to an S1 excitation energy of 1.96 eV. The constraint sequence for an S2 excitation is deltascf_constraint : 33 0.5000 1 33 33 deltascf_constraint : 35 0.5000 1 35 35 The resulting final energy is Final energy, E = -2594.762182241 eV The corresponding S2 excitation energy is 2.90 eV.","title":"Simple Delta SCF"},{"location":"tutorials/Delta_SCF/simple_delta_scf/#electronic-excitations-of-the-azobenzene-molecule","text":"In this example we calculate the first two electronic excited states of E-Azobenzene in a supercell. The required files are azo.cell, azo.param, azo.deltascf azo.param task: SinglePoint %BLOCK DEVEL_CODE DeltaSCF %ENDBLOCK DEVEL_CODE reuse: default spin_polarized : False cut_off_energy : 350.0 elec_energy_tol : 1e-07 fix_occupancy : False iprint : 1 max_scf_cycles : 200 metals_method : dm mixing_scheme : Pulay nextra_bands : 10 num_dump_cycles : 0 opt_strategy_bias : 3 smearing_scheme : Gaussian smearing_width : 0.1 xc_functional : PBE azo.cell %BLOCK LATTICE_CART 10.0000000 0.0000000000 0.0000000000 0.0000000000 20.0000000 0.0000000000 0.0000000000 0.0000000000 10.0000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_ABS C -6.72081 -1.66625 0.00000 C -6.64967 -0.26964 0.00000 C -5.40647 0.36858 -0.00000 C -4.23175 -0.38857 -0.00000 C -4.29745 -1.78579 -0.00000 C -5.54882 -2.43430 -0.00000 H -7.68820 -2.15296 0.00000 H -7.55879 0.31772 0.00000 H -5.35348 1.44963 -0.00000 H -3.26966 0.10734 -0.00000 H -3.37789 -2.35693 -0.00000 N -5.65342 -3.85046 -0.00000 N -4.64259 -4.58194 -0.00000 C -4.75058 -5.99808 -0.00000 C -6.00434 -6.64214 -0.00000 C -6.07567 -8.03881 -0.00000 C -4.90409 -8.80053 -0.00000 C -3.65828 -8.16721 -0.00000 C -3.58139 -6.77065 -0.00000 H -2.61200 -6.28795 -0.00000 H -6.92178 -6.06761 -0.00000 H -7.03986 -8.53061 -0.00000 H -4.96168 -9.88134 -0.00000 H -2.75170 -8.75849 -0.00000 %ENDBLOCK POSITIONS_ABS FIX_ALL_CELL : True KPOINTS_MP_GRID : 1 1 1 azo.deltascf deltascf_mode : 1 deltascf_iprint : 1 # mode 1 constraints ## # band occ spin from_band to_band deltascf_constraint : 34 0.5000 1 34 34 deltascf_constraint : 35 0.5000 1 35 35 We start by calculating the total DFT ground state energy as Final energy, E = -2597.665647686 eV Now we reuse the calculated wavefunctions and switch to the DeltaSCF calculation %BLOCK DEVEL_CODE DeltaSCF %ENDBLOCK DEVEL_CODE There are 68 valence electrons. Therefore, for this non-spin-polarized system the HOMO orbital is orbital no. 34. The LUMO is orbital no. 35. The first two excited states of azobenzene are known to be S1(n->pi*) and S2(pi->pi*) transitions between the HOMO and LUMO and the HOMO-1 and the LUMO. The corresponding constraint sequence in azo.deltascf for the S1 excitation is deltascf_constraint : 34 0.5000 1 34 34 deltascf_constraint : 35 0.5000 1 35 35 WARNING : When running non-spin-polarized calculations, orbital occupations range from 0 to 1. !!When running a spin-polarized calculation, they also range from 0 to 1, although they contain 0 to 2 electrons. In this (non-spin-polarized) case, if we want to transfer an electron from the HOMO(34) to LUMO(35) we need to enforce the occupation of both to be 0.50. Feel free to increase the print level with deltascf_iprint to study the output in more detail. The corresponding total energy is Final energy, E = -2595.702720896 eV This corresponds to an S1 excitation energy of 1.96 eV. The constraint sequence for an S2 excitation is deltascf_constraint : 33 0.5000 1 33 33 deltascf_constraint : 35 0.5000 1 35 35 The resulting final energy is Final energy, E = -2594.762182241 eV The corresponding S2 excitation energy is 2.90 eV.","title":"Electronic excitations of the Azobenzene molecule"},{"location":"tutorials/NEB/neb_tutorial/","text":"Nudged elastic band tutorial Overview and background The nudged elastic band (NEB) approach is a widely-used method for finding a minimum energy pathway between two configurations of atoms. You can use the method to estimate the barrier for the system to transition between the two structures. The technique starts with two fixed end points which are fully relaxed (local) minima: the initial and final configurations. It then connects these end points with a series of \"images\" via fictitious springs that \"pull\" the structures taut over one or more intermediate transition states. In this tutorial, we will use the well-known example of an ammonia molecule's pyramidal inversion We will cover: How to set up the initial, final (and intermediate) structures How to actually run the NEB calculation efficiently How to analyse the results Other tips and tricks Files You can find all the files needed for this tutorial here: neb_tutorial.tar.gz Setting up the structures Setting up the initial and final states These are the local minima structures you want to find the barrier between. They can be equivalent structures, e.g. differing by a symmetry operation, such reflection through a mirror plane, or they can be configurations with different energies (in which case your forward and reverse barriers will not be the same!). Two crucial conditions must be met before running the NEB calculation : The end point structures must be fully relaxed (geometry optimised) before you start the NEB. Note that both the initial relaxations and the actual NEB calculation must use consistent parameters (e.g. basis set, pseudopotentials, k-points, XC functional etc.). The atoms must be in the correct order. A common mistake is to use a software tool to generate the final state from the initial state and end up with atoms that don't match the initial atom order. Atoms then \"pass through each other\" when CASTEP interpolates between the two structures, causing the calculation to blow up. Always check that the atoms connect up in the way you expect. The initial state is specified in the same way as a normal .cell file, e.g.: %BLOCK positions_frac H 0.500011764912384 0.634846485697942 0.443086003907125 H 0.616593728396204 0.432553816946042 0.442828605918639 H 0.383248448613152 0.432623959245757 0.443068863520867 N 0.500000000000000 0.500000000000000 0.500000000000000 %ENDBLOCK positions_frac The final state is specified using a similar block in the same .cell file but with _product appended to the name of the block, e.g.: %BLOCK positions_frac_product H 0.500154169007758 0.634858887961251 0.556834437330747 H 0.616661280589956 0.432482046338754 0.556941161085851 H 0.383366127862304 0.432719065607707 0.557277918851780 N 0.500000000000000 0.500000000000000 0.500000000000000 %ENDBLOCK positions_frac_product Setting up the transition state guess CASTEP will linearly interpolate between the initial and final structures provided to generate the first guess of the minimum energy pathway. This works well in many cases. However, if your minimum energy pathway contains e.g. a rotation of a (group of) atom(s) around a bond or something similar, then the linear path between initial and final configurations may be a bad starting guess/non-physical structure. For example, if your end points correspond to a C2 rotation, then a linearly interpolated intermediate structure would not be a physical one. It's important to visualise or otherwise check all of your structures before running a calculation. Intermediate structures can also be chosen in such a way as to bias your results to one pathway over another. CASTEP allows you to provide one intermediate structure between the initial and final configurations in order to get the NEB on the right track. The intermediate configuration is added using, e.g.: %BLOCK POSITIONS_ABS_INTERMEDIATE ang N 3.500000 3.500000 3.500000 H 3.500000 4.443968 3.500000 H 4.316393 3.027626 3.500000 H 2.683149 3.028701 3.501215 %ENDBLOCK POSITIONS_ABS_INTERMEDIATE How many images do I need? It depends... It's usually preferable to start with a small number of images and increase the number if you need to. Starting small can quickly give you a rough sense of the energy landscape and that will determine the actual number of images needed. In addition, if you start with too many images then you might never get close to the converged TS because the optimisation takes too long. If you instead start with a small number and get a reasonable TS structure, you can then use that as your initial intermediate structure in a restarted calculation with more images. Using many (i.e. > 15) will result in slow convergence, but may lead to a more accurate minimum energy pathway for complex barriers. If you do find a particularly complex pathway, however, you might be better off splitting the work up into more than one NEB calculation, each with fewer images. Just remember to always fully relax the end points (even if the end point is a meta-stable local minimum)! Using too few (i.e. < 5) might fail to find the minimum energy pathway if the energy landscape is complex. TODO: add guidance on odd vs even number of images (touching on how the spacing is calculated) and on how many you need for this simple example -- maybe an exercise for the user? You can actually get the same barrier height with just one image in this simple case! Some questions to help answer how many images you need: How complex is the landscape between the initial and final state? For example, if you expect more than one maximum between the end points, you probably need more images than for the single peak example we look at here. Note The number of images is the number of structures between the end points. The total number of structures in the path (i.e. including the end points) is therefore the number of images + 2. Constraints We can often dramatically improve the efficiency of the transition state search by imposing constraints on the atomic positions, although this must be done with care so as not to introduce artifacts. For example, when looking at NEB barriers for adsorbates on a surface slab, we can usefully constrain the bottom slab layers, but probably want the top layer(s) unconstrained. In the ammonia case, we can constrain the N atom position without affecting the physical set up by adding the block: %BLOCK IONIC_CONSTRAINTS 1 N 1 1 0 0 2 N 1 0 1 0 3 N 1 0 0 1 %ENDBLOCK IONIC_CONSTRAINTS to the nh3.cell file. [Isn't there a more compact way now to specify a fixed atom?] You should then see something like: --- Initialising NEB constraints --- Fixed 3 degrees of freedom in the .castep output file. Do I need climbing NEB? The climbing NEB method modifies the force on the highest-energy image such that it tries to climb up the barrier. This is very useful to get accurate barrier estimates, but care must be taken when more complex pathways (i.e. with multiple maxima) are found. [Don't get this!] In our example the path is quite straightforward and it makes sense to use the climbing image method. We therefore set: TSSEARCH_NEB_CLIMBING: TRUE in the .param file. TODO: clarify what happens when you set climbing to true. TODO: include advice/explanation about starting with regular NEB and turning on climbing image after a few steps. Running the NEB Parallelisation Because the NEB calculation essentially involves N independent CASTEP calculations (where N is the number of images), we can make very efficient use of high-performance computers. This is done via \"task farming\", running the calculations for the N images independently. For example, if one CASTEP calculation fits on one node, and you have 7 images, then you could run on a total of 7 nodes by setting the keyword: NUM_FARMS: 7 in the .param file. A good rule of thumb is to aim for NUM_FARMS = number of NEB images. That way each 'farm' is responsible for one NEB image. Since each farm will effectively run a series of single-point calculations on each NEB image they are responsible for, the compute resources of that farm should be appropriately sized for such calculations. Too small and you could get an out-of-memory error, too large and you might end up over-parallelising, leading to reduced overall performance. i.e. you should aim to run on a total of NUM_FARMS times as many cores as you would use for a single-point calculation on one of the structures. This also assumes that your available compute resources can be neatly split into NUM_FARMS . The easy case is when each farm can run on a single node; i.e. NUM_FARMS = number of NEB images = number of nodes. Note that the total number of cores available must be divisible by NUM_FARMS . If you choose NUM_FARMS < number of images, each of the images will run sequentially on one farm as soon as that farm becomes available. If the number of images is not a multiple of NUM_FARMS , some farms will end up being responsible for more images than others, leading poor overall efficiency. If you choose NUM_FARMS > number of images, then some farms will be left with nothing to do, resulting in poor overall efficiency. Setting NUM_FARMS = 1 is equivalent to not setting NUM_FARMS . You will notice that if you enable task farming, the seedname.castep output file will look relatively empty, as most output is split into the different task farm .castep files. The first indexed one contains the most important information (for example, the \"Max NEB force\") and will be called e.g. seedname_farm001.castep . Is the calculation converging? You can monitor the convergence by searching for \"Max NEB force\" within the .castep output file. Common convergence issues include: Not having consistent order in the initial and final structures, i.e. non-physical initial path Too many (or too few) images [As above - not clear what this means, so looks odd.] Initial or final state (endpoints) not being fully relaxed structures Restarting / Continuing Sometimes the calculation will run out of time/number of iterations before the NEB calculation is finished. You will probably see a \"Failed to converge\" message in the .castep output in that case; always read through your output files! [Not obvious in .ts file? Shouldn't need to positively check for unconverged results.] If you re-run the calculation without changing anything, it will simply start from the beginning again -- probably not what you want! In order restart the NEB from the last checkpointed state, you need to explicitly set the name of the .check file you want to continue from in your .param file. In our example that would be: continuation: nh3.check In the .castep output you would then see: Coordinates of NEB images loaded from checkpoint file . Warning Unlike other CASTEP tasks, setting continuation: default does not seem to work for continuing/restarting NEB calculations! You must explicitly set the name of checkpoint file. Analysis Once you have a converged NEB, the provided Python utility readTS can be used to parse and analyse the NEB. To add the readTS module to your PYTHONPATH, you can find a setup.py script in the castep/Utilities/readts directory of your CASTEP source directory. Running python setup.py should install the module to your path. You can also manually add it by inserting the following line into your ~/.bashrc or equivalent and restarting the terminal: export PYTHONPATH = \"/path/to/castep/Utilities/readts: $PYTHONPATH \" (changing the /path/to/castep/ bit to wherever CASTEP is on your machine). You can then extract the NEB path using something like this python code: [This looks sufficiently general that you could supply the analysis.py script?] ## get this by adding castep/Utilities/readts to your PYTHONPATH from readts import TSFile from ase.neb import NEBTools def get_images ( tsfile ): ''' Function to extract the final NEB images from a tsfile object Args: tsfile (TSFile): tsfile object Returns: images (list): list of ASE atoms objects ''' diam_tst = tsfile . blocks [ 'TST' ] diam_i = tsfile . blocks [ 'REA' ][ 1 ][ 0 ] diam_f = tsfile . blocks [ 'PRO' ][ 1 ][ 0 ] nbeads = len ( diam_tst [ 1 ]) max_idx = diam_tst . last_index images = [ diam_i . atoms ] images += [ diam_tst [ max_idx ][ i ] . atoms for i in range ( 0 , nbeads , 1 )] images . append ( diam_f . atoms ) return images def plot_band ( images , filename = 'neb.png' ): nt = NEBTools ( images ) energies = nt . get_barrier () print ( f 'Barrier height: { energies [ 0 ] : 16.5f } eV' ) print ( f 'E_final - E_initial: { energies [ 1 ] : 16.5f } eV' ) nebplot = nt . plot_band () nebplot . savefig ( filename ) if __name__ == '__main__' : import sys seedname = sys . argv [ 1 ] path = './' tolerant = False if len ( sys . argv ) > 2 : tolerant = bool ( sys . argv [ 2 ]) tsfile = TSFile ( seedname , path = path , tolerant = tolerant ) images = get_images ( tsfile ) plot_band ( images ) # we can use ASE to write out the structure # in whatever format we want print ( 'Image \\t\\t Energy (eV)' ) for i , atoms in enumerate ( images ): print ( f ' { i : 03d } \\t { atoms . get_potential_energy () : 16.5f } eV' ) ## this format includes the energy of the image atoms . write ( f 'image- { i : 03d } .xyz' ) ## We can also use the ASE GUI to ## view the images and analyse the NEB path. ## Select Tools -> NEB Plot # from ase.visualize import view # view(images) If we save this script as analysis.py and run it in the directory containing both the nh3.cell and nh3.ts files like this: python analysis.py nh3 we will get an .xyz file for each structure in the optimised NEB path and the energy of each image. We will also get the barrier estimate and a NEB plot showing the barrier. The ASE GUI can also be used to plot the NEB band (uncomment the last two lines in the above script and Select Tools \u2192 NEB Plot from the GUI). The ASE-generated plot looks like this: The green lines show the tangents at those points; these can be useful indicators of convergence. The barrier we obtained is about 0.23 eV, which compares well with the value of 0.25 eV (24.2 kJ/mol) from Wikipedia . We might also notice the slight difference in energy between the two end-points of the path (about 1 meV). These should be identical, so any difference can be used as a very rough guide for the amount of numerical noise in the geometry optimisations. If equivalent structures (the end-points in this example) were found to have very different energies, you would need to go back and tighten up your convergence criteria or force/energy tolerances in the initial geometry optimisations and re-run the NEB calculation with these tightened parameters. Using our favourite visualisation software (here we used the ASE POV-Ray interface ), we can then look at how the structure evolves along the minimum energy pathway found via the NEB. Zero-point energy corrections In many cases, particularly when lighter atoms are involved, the energy barrier estimates obtained above need to be corrected for quantum-nuclear effects. The simplest way to do this is in the harmonic approximation. You need to estimate the harmonic zero-point energy at the start, transition and final configurations. TODO: replace the section on zero-point energy corrections by a note that highlights that the NEB will provide a Delta E (this is exact), while the transition rates will depend on Delta E_0. TODO: add instructions for harmonic ZPE corrections.","title":"Nudged elastic band"},{"location":"tutorials/NEB/neb_tutorial/#nudged-elastic-band-tutorial","text":"","title":"Nudged elastic band tutorial"},{"location":"tutorials/NEB/neb_tutorial/#overview-and-background","text":"The nudged elastic band (NEB) approach is a widely-used method for finding a minimum energy pathway between two configurations of atoms. You can use the method to estimate the barrier for the system to transition between the two structures. The technique starts with two fixed end points which are fully relaxed (local) minima: the initial and final configurations. It then connects these end points with a series of \"images\" via fictitious springs that \"pull\" the structures taut over one or more intermediate transition states. In this tutorial, we will use the well-known example of an ammonia molecule's pyramidal inversion We will cover: How to set up the initial, final (and intermediate) structures How to actually run the NEB calculation efficiently How to analyse the results Other tips and tricks","title":"Overview and background"},{"location":"tutorials/NEB/neb_tutorial/#files","text":"You can find all the files needed for this tutorial here: neb_tutorial.tar.gz","title":"Files"},{"location":"tutorials/NEB/neb_tutorial/#setting-up-the-structures","text":"","title":"Setting up the structures"},{"location":"tutorials/NEB/neb_tutorial/#setting-up-the-initial-and-final-states","text":"These are the local minima structures you want to find the barrier between. They can be equivalent structures, e.g. differing by a symmetry operation, such reflection through a mirror plane, or they can be configurations with different energies (in which case your forward and reverse barriers will not be the same!). Two crucial conditions must be met before running the NEB calculation : The end point structures must be fully relaxed (geometry optimised) before you start the NEB. Note that both the initial relaxations and the actual NEB calculation must use consistent parameters (e.g. basis set, pseudopotentials, k-points, XC functional etc.). The atoms must be in the correct order. A common mistake is to use a software tool to generate the final state from the initial state and end up with atoms that don't match the initial atom order. Atoms then \"pass through each other\" when CASTEP interpolates between the two structures, causing the calculation to blow up. Always check that the atoms connect up in the way you expect. The initial state is specified in the same way as a normal .cell file, e.g.: %BLOCK positions_frac H 0.500011764912384 0.634846485697942 0.443086003907125 H 0.616593728396204 0.432553816946042 0.442828605918639 H 0.383248448613152 0.432623959245757 0.443068863520867 N 0.500000000000000 0.500000000000000 0.500000000000000 %ENDBLOCK positions_frac The final state is specified using a similar block in the same .cell file but with _product appended to the name of the block, e.g.: %BLOCK positions_frac_product H 0.500154169007758 0.634858887961251 0.556834437330747 H 0.616661280589956 0.432482046338754 0.556941161085851 H 0.383366127862304 0.432719065607707 0.557277918851780 N 0.500000000000000 0.500000000000000 0.500000000000000 %ENDBLOCK positions_frac_product","title":"Setting up the initial and final states"},{"location":"tutorials/NEB/neb_tutorial/#setting-up-the-transition-state-guess","text":"CASTEP will linearly interpolate between the initial and final structures provided to generate the first guess of the minimum energy pathway. This works well in many cases. However, if your minimum energy pathway contains e.g. a rotation of a (group of) atom(s) around a bond or something similar, then the linear path between initial and final configurations may be a bad starting guess/non-physical structure. For example, if your end points correspond to a C2 rotation, then a linearly interpolated intermediate structure would not be a physical one. It's important to visualise or otherwise check all of your structures before running a calculation. Intermediate structures can also be chosen in such a way as to bias your results to one pathway over another. CASTEP allows you to provide one intermediate structure between the initial and final configurations in order to get the NEB on the right track. The intermediate configuration is added using, e.g.: %BLOCK POSITIONS_ABS_INTERMEDIATE ang N 3.500000 3.500000 3.500000 H 3.500000 4.443968 3.500000 H 4.316393 3.027626 3.500000 H 2.683149 3.028701 3.501215 %ENDBLOCK POSITIONS_ABS_INTERMEDIATE","title":"Setting up the transition state guess"},{"location":"tutorials/NEB/neb_tutorial/#how-many-images-do-i-need","text":"It depends... It's usually preferable to start with a small number of images and increase the number if you need to. Starting small can quickly give you a rough sense of the energy landscape and that will determine the actual number of images needed. In addition, if you start with too many images then you might never get close to the converged TS because the optimisation takes too long. If you instead start with a small number and get a reasonable TS structure, you can then use that as your initial intermediate structure in a restarted calculation with more images. Using many (i.e. > 15) will result in slow convergence, but may lead to a more accurate minimum energy pathway for complex barriers. If you do find a particularly complex pathway, however, you might be better off splitting the work up into more than one NEB calculation, each with fewer images. Just remember to always fully relax the end points (even if the end point is a meta-stable local minimum)! Using too few (i.e. < 5) might fail to find the minimum energy pathway if the energy landscape is complex. TODO: add guidance on odd vs even number of images (touching on how the spacing is calculated) and on how many you need for this simple example -- maybe an exercise for the user? You can actually get the same barrier height with just one image in this simple case! Some questions to help answer how many images you need: How complex is the landscape between the initial and final state? For example, if you expect more than one maximum between the end points, you probably need more images than for the single peak example we look at here. Note The number of images is the number of structures between the end points. The total number of structures in the path (i.e. including the end points) is therefore the number of images + 2.","title":"How many images do I need?"},{"location":"tutorials/NEB/neb_tutorial/#constraints","text":"We can often dramatically improve the efficiency of the transition state search by imposing constraints on the atomic positions, although this must be done with care so as not to introduce artifacts. For example, when looking at NEB barriers for adsorbates on a surface slab, we can usefully constrain the bottom slab layers, but probably want the top layer(s) unconstrained. In the ammonia case, we can constrain the N atom position without affecting the physical set up by adding the block: %BLOCK IONIC_CONSTRAINTS 1 N 1 1 0 0 2 N 1 0 1 0 3 N 1 0 0 1 %ENDBLOCK IONIC_CONSTRAINTS to the nh3.cell file. [Isn't there a more compact way now to specify a fixed atom?] You should then see something like: --- Initialising NEB constraints --- Fixed 3 degrees of freedom in the .castep output file.","title":"Constraints"},{"location":"tutorials/NEB/neb_tutorial/#do-i-need-climbing-neb","text":"The climbing NEB method modifies the force on the highest-energy image such that it tries to climb up the barrier. This is very useful to get accurate barrier estimates, but care must be taken when more complex pathways (i.e. with multiple maxima) are found. [Don't get this!] In our example the path is quite straightforward and it makes sense to use the climbing image method. We therefore set: TSSEARCH_NEB_CLIMBING: TRUE in the .param file. TODO: clarify what happens when you set climbing to true. TODO: include advice/explanation about starting with regular NEB and turning on climbing image after a few steps.","title":"Do I need climbing NEB?"},{"location":"tutorials/NEB/neb_tutorial/#running-the-neb","text":"","title":"Running the NEB"},{"location":"tutorials/NEB/neb_tutorial/#parallelisation","text":"Because the NEB calculation essentially involves N independent CASTEP calculations (where N is the number of images), we can make very efficient use of high-performance computers. This is done via \"task farming\", running the calculations for the N images independently. For example, if one CASTEP calculation fits on one node, and you have 7 images, then you could run on a total of 7 nodes by setting the keyword: NUM_FARMS: 7 in the .param file. A good rule of thumb is to aim for NUM_FARMS = number of NEB images. That way each 'farm' is responsible for one NEB image. Since each farm will effectively run a series of single-point calculations on each NEB image they are responsible for, the compute resources of that farm should be appropriately sized for such calculations. Too small and you could get an out-of-memory error, too large and you might end up over-parallelising, leading to reduced overall performance. i.e. you should aim to run on a total of NUM_FARMS times as many cores as you would use for a single-point calculation on one of the structures. This also assumes that your available compute resources can be neatly split into NUM_FARMS . The easy case is when each farm can run on a single node; i.e. NUM_FARMS = number of NEB images = number of nodes. Note that the total number of cores available must be divisible by NUM_FARMS . If you choose NUM_FARMS < number of images, each of the images will run sequentially on one farm as soon as that farm becomes available. If the number of images is not a multiple of NUM_FARMS , some farms will end up being responsible for more images than others, leading poor overall efficiency. If you choose NUM_FARMS > number of images, then some farms will be left with nothing to do, resulting in poor overall efficiency. Setting NUM_FARMS = 1 is equivalent to not setting NUM_FARMS . You will notice that if you enable task farming, the seedname.castep output file will look relatively empty, as most output is split into the different task farm .castep files. The first indexed one contains the most important information (for example, the \"Max NEB force\") and will be called e.g. seedname_farm001.castep .","title":"Parallelisation"},{"location":"tutorials/NEB/neb_tutorial/#is-the-calculation-converging","text":"You can monitor the convergence by searching for \"Max NEB force\" within the .castep output file. Common convergence issues include: Not having consistent order in the initial and final structures, i.e. non-physical initial path Too many (or too few) images [As above - not clear what this means, so looks odd.] Initial or final state (endpoints) not being fully relaxed structures","title":"Is the calculation converging?"},{"location":"tutorials/NEB/neb_tutorial/#restarting-continuing","text":"Sometimes the calculation will run out of time/number of iterations before the NEB calculation is finished. You will probably see a \"Failed to converge\" message in the .castep output in that case; always read through your output files! [Not obvious in .ts file? Shouldn't need to positively check for unconverged results.] If you re-run the calculation without changing anything, it will simply start from the beginning again -- probably not what you want! In order restart the NEB from the last checkpointed state, you need to explicitly set the name of the .check file you want to continue from in your .param file. In our example that would be: continuation: nh3.check In the .castep output you would then see: Coordinates of NEB images loaded from checkpoint file . Warning Unlike other CASTEP tasks, setting continuation: default does not seem to work for continuing/restarting NEB calculations! You must explicitly set the name of checkpoint file.","title":"Restarting / Continuing"},{"location":"tutorials/NEB/neb_tutorial/#analysis","text":"Once you have a converged NEB, the provided Python utility readTS can be used to parse and analyse the NEB. To add the readTS module to your PYTHONPATH, you can find a setup.py script in the castep/Utilities/readts directory of your CASTEP source directory. Running python setup.py should install the module to your path. You can also manually add it by inserting the following line into your ~/.bashrc or equivalent and restarting the terminal: export PYTHONPATH = \"/path/to/castep/Utilities/readts: $PYTHONPATH \" (changing the /path/to/castep/ bit to wherever CASTEP is on your machine). You can then extract the NEB path using something like this python code: [This looks sufficiently general that you could supply the analysis.py script?] ## get this by adding castep/Utilities/readts to your PYTHONPATH from readts import TSFile from ase.neb import NEBTools def get_images ( tsfile ): ''' Function to extract the final NEB images from a tsfile object Args: tsfile (TSFile): tsfile object Returns: images (list): list of ASE atoms objects ''' diam_tst = tsfile . blocks [ 'TST' ] diam_i = tsfile . blocks [ 'REA' ][ 1 ][ 0 ] diam_f = tsfile . blocks [ 'PRO' ][ 1 ][ 0 ] nbeads = len ( diam_tst [ 1 ]) max_idx = diam_tst . last_index images = [ diam_i . atoms ] images += [ diam_tst [ max_idx ][ i ] . atoms for i in range ( 0 , nbeads , 1 )] images . append ( diam_f . atoms ) return images def plot_band ( images , filename = 'neb.png' ): nt = NEBTools ( images ) energies = nt . get_barrier () print ( f 'Barrier height: { energies [ 0 ] : 16.5f } eV' ) print ( f 'E_final - E_initial: { energies [ 1 ] : 16.5f } eV' ) nebplot = nt . plot_band () nebplot . savefig ( filename ) if __name__ == '__main__' : import sys seedname = sys . argv [ 1 ] path = './' tolerant = False if len ( sys . argv ) > 2 : tolerant = bool ( sys . argv [ 2 ]) tsfile = TSFile ( seedname , path = path , tolerant = tolerant ) images = get_images ( tsfile ) plot_band ( images ) # we can use ASE to write out the structure # in whatever format we want print ( 'Image \\t\\t Energy (eV)' ) for i , atoms in enumerate ( images ): print ( f ' { i : 03d } \\t { atoms . get_potential_energy () : 16.5f } eV' ) ## this format includes the energy of the image atoms . write ( f 'image- { i : 03d } .xyz' ) ## We can also use the ASE GUI to ## view the images and analyse the NEB path. ## Select Tools -> NEB Plot # from ase.visualize import view # view(images) If we save this script as analysis.py and run it in the directory containing both the nh3.cell and nh3.ts files like this: python analysis.py nh3 we will get an .xyz file for each structure in the optimised NEB path and the energy of each image. We will also get the barrier estimate and a NEB plot showing the barrier. The ASE GUI can also be used to plot the NEB band (uncomment the last two lines in the above script and Select Tools \u2192 NEB Plot from the GUI). The ASE-generated plot looks like this: The green lines show the tangents at those points; these can be useful indicators of convergence. The barrier we obtained is about 0.23 eV, which compares well with the value of 0.25 eV (24.2 kJ/mol) from Wikipedia . We might also notice the slight difference in energy between the two end-points of the path (about 1 meV). These should be identical, so any difference can be used as a very rough guide for the amount of numerical noise in the geometry optimisations. If equivalent structures (the end-points in this example) were found to have very different energies, you would need to go back and tighten up your convergence criteria or force/energy tolerances in the initial geometry optimisations and re-run the NEB calculation with these tightened parameters. Using our favourite visualisation software (here we used the ASE POV-Ray interface ), we can then look at how the structure evolves along the minimum energy pathway found via the NEB.","title":"Analysis"},{"location":"tutorials/NEB/neb_tutorial/#zero-point-energy-corrections","text":"In many cases, particularly when lighter atoms are involved, the energy barrier estimates obtained above need to be corrected for quantum-nuclear effects. The simplest way to do this is in the harmonic approximation. You need to estimate the harmonic zero-point energy at the start, transition and final configurations. TODO: replace the section on zero-point energy corrections by a note that highlights that the NEB will provide a Delta E (this is exact), while the transition rates will depend on Delta E_0. TODO: add instructions for harmonic ZPE corrections.","title":"Zero-point energy corrections"},{"location":"tutorials/NMR/NMR_shielding/","text":"Example 1 - Ethanol CH 3 CH 2 OH {width =\"300\"} Fig1. Proton spectrum of ethanol The discovery that one could actually see chemical shifts in hydrogen spectra was made in 1951 at Stanford University by Packard, Arnold, Dharmatti (shown in Fig 1). We will try to reproduce this result. FILES: ethanol.cell %BLOCK LATTICE_ABC 6 6 6 90 90 90 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS H 3.980599 4.178342 3.295079 H 5.033394 3.43043 4.504759 H 5.71907 4.552257 3.315353 H 3.720235 5.329505 5.509909 H 4.412171 6.433572 4.317001 H 5.911611 5.032284 6.242202 C 4.84694 4.350631 3.941136 C 4.603025 5.518738 4.882532 O 5.746254 5.812705 5.6871 %ENDBLOCK POSITIONS_ABS %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST ethanol.param xcfunctional = PBE fix_occupancy = true opt_strate.g.y : speed task = magres cut_off_energy = 20 ry OBJECTIVES: Examine the convergence of the chemical shieldings with planewave cutoff Compare to experiment. INSTRUCTIONS: Look at the cell and param file. Note that the only special keyword is task = magres Run castep. castepsub -n 4 ethanol Look at the output file. At the end the isotropic chemical shielding, anisotropy, and asymmetry are reported (here we are only interested in the isotropic value.) This information, plus the full tensors is also given in the file ethanol.magres You might wish to transfer the *.magres file back to your desktop to visualise with MagresView . Examine the effect of increasing the cutoff energy (say 20-50 Ryd in steps of 10 Ryd). It always helps to plot a graph of the convergence (e.g. with gnuplot or xmgrace on the cluster - or with excel on the pc) Find the \"converged\" hydrogen (or proton in NMR language) shieldings. We will compare them to experiment. The three methyl (CH 3 ) protons undergo fast exchange; they \"rotate\" faster than the nuclear magnetic moment processes. The magnetic moment will therefore \"see\" an average chemical shielding. The same is true of the CH 2 protons. Average the CH 3 and CH 2 chemical shieldings. This will give you 3 unique chemical shieldings. We now need to convert the chemical shieldings \u03c3 iso to chemical shifts \u03b4 iso on the experimental scale. We use the relation: \u03b4 iso =\u03c3 ref -\u03c3 A suitable \u03c3 ref for 1H is 30.97ppm. {width =\"300\"} Fig2. 1H NMR spectrum of liquid ethanol Fig. 2 shows a modern high-resolution 1H spectrum for liquid ethanol. Note that the peaks are split due to J-coupling - the interaction of the 1H magnetic moments - but let's ignore that for now. The three peaks are roughly at 1.2ppm, 3.7ppm and 5ppm. You should find that your computed values agree for two sites. Do you know why the other site has such a large disagreement with experiment?","title":"J coupling"},{"location":"tutorials/NMR/NMR_shielding/#example-1-ethanol-ch3ch2oh","text":"{width =\"300\"} Fig1. Proton spectrum of ethanol The discovery that one could actually see chemical shifts in hydrogen spectra was made in 1951 at Stanford University by Packard, Arnold, Dharmatti (shown in Fig 1). We will try to reproduce this result. FILES: ethanol.cell %BLOCK LATTICE_ABC 6 6 6 90 90 90 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS H 3.980599 4.178342 3.295079 H 5.033394 3.43043 4.504759 H 5.71907 4.552257 3.315353 H 3.720235 5.329505 5.509909 H 4.412171 6.433572 4.317001 H 5.911611 5.032284 6.242202 C 4.84694 4.350631 3.941136 C 4.603025 5.518738 4.882532 O 5.746254 5.812705 5.6871 %ENDBLOCK POSITIONS_ABS %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST ethanol.param xcfunctional = PBE fix_occupancy = true opt_strate.g.y : speed task = magres cut_off_energy = 20 ry OBJECTIVES: Examine the convergence of the chemical shieldings with planewave cutoff Compare to experiment. INSTRUCTIONS: Look at the cell and param file. Note that the only special keyword is task = magres Run castep. castepsub -n 4 ethanol Look at the output file. At the end the isotropic chemical shielding, anisotropy, and asymmetry are reported (here we are only interested in the isotropic value.) This information, plus the full tensors is also given in the file ethanol.magres You might wish to transfer the *.magres file back to your desktop to visualise with MagresView . Examine the effect of increasing the cutoff energy (say 20-50 Ryd in steps of 10 Ryd). It always helps to plot a graph of the convergence (e.g. with gnuplot or xmgrace on the cluster - or with excel on the pc) Find the \"converged\" hydrogen (or proton in NMR language) shieldings. We will compare them to experiment. The three methyl (CH 3 ) protons undergo fast exchange; they \"rotate\" faster than the nuclear magnetic moment processes. The magnetic moment will therefore \"see\" an average chemical shielding. The same is true of the CH 2 protons. Average the CH 3 and CH 2 chemical shieldings. This will give you 3 unique chemical shieldings. We now need to convert the chemical shieldings \u03c3 iso to chemical shifts \u03b4 iso on the experimental scale. We use the relation: \u03b4 iso =\u03c3 ref -\u03c3 A suitable \u03c3 ref for 1H is 30.97ppm. {width =\"300\"} Fig2. 1H NMR spectrum of liquid ethanol Fig. 2 shows a modern high-resolution 1H spectrum for liquid ethanol. Note that the peaks are split due to J-coupling - the interaction of the 1H magnetic moments - but let's ignore that for now. The three peaks are roughly at 1.2ppm, 3.7ppm and 5ppm. You should find that your computed values agree for two sites. Do you know why the other site has such a large disagreement with experiment?","title":"Example 1 - Ethanol CH3CH2OH"},{"location":"tutorials/Tools/elastic_constants/","text":"Andrew Walker (building on work by Dan Wilson) provides some python scripts for calculating elastic constants using CASTEP, available from https://github.com/andreww/elastic-constants . The tool comes in two parts - first is generate_strain.py, this takes the results of a successful variable cell geometry optimisation and creates a set of input files to be run through CASTEP. The second part is elastics.py, which takes the CASTEP results and constructs the matrix of elastic constants, Young's modulus, Poisson's ratios and bulk and shear moduli. Usage information for each script can be obtained by using the --help option. For this exercise we will use rutile - titanium dioxide. Below are example .cell and .param files to start from. It is assumed that the scripts generate_strain.py and elastics.py are in your PATH and that python is installed. #TiO2.cell %BLOCK lattice_cart 4.594 0.000 0.000 0.000 4.594 0.000 0.000 0.000 2.959 %ENDBLOCK lattice_cart %BLOCK positions_frac Ti 0.000 0.000 0.000 Ti 0.500 0.500 0.500 O 0.305 0.305 0.000 O -0.305 -0.305 0.000 O 0.805 0.195 0.500 O -0.805 -0.195 0.500 %ENDBLOCK positions_frac symmetry_generate kpoint_mp_grid 3 3 3 #TiO2.param task : geometryoptimisation cutoff_energy : 700 eV xc_functional : PBE max_scf_cycles : 100 calculate_stress : true opt_strategy : speed num_dump_cycles : 0 Task 1: Perform a variable cell geometry optimisation and make sure to include calculate_stress : true in your param file. Test the kinetic energy cut-off and k-point grid such that the stress is converged to within the default geom_stress_tol value. (Hint: Use CASTEP's built-in help utility to find the default.) Task 2: Use the generate_strain.py script to generate a set of .cell files deformed according to the appropriate strain pattern. The command generate_strain.py TiO2 should be sufficient. You should now have twelve (in this case) sets of input files - individual .cell files and corresponding .param , symbolically linked to the original TiO2.param file. Notice that the new .cell files all have the FIX_ALL_CELL true option set. Task 3: Run CASTEP on each of the 12 sets of input files. Note that the cell distortions can break the symmetry of the crystal, hence changing the number of k-points in the symmetry reduced sample. The -dryrun option of CASTEP can be used to do a quick check for how many k-points are required. This can help when selecting how many cores to run the calculation on if you are running CASTEP in parallel. Task 4: Run the elastics.py script to obtain the elastic constants. The command elastics.py TiO2 will print the results to the terminal. The --latex option generates a LaTeX formatted summary of the results and the --graphics option produces a graphical representation of the stress-strain fits in a .png file. Task 5: Investigate how the results and their errors change with smaller values of the elec_energy_tol parameter. Also investigate the effect of changing the --strain option to generate_strain.py . Move any old *cij*.castep files to another directory - the elastics.py script only checks the first set of data in a concatenated .castep file.","title":"Elastic Constants"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/","text":"Interlayer binding energy of graphite Here we'll explore the van der Waals interaction that holds sheets of graphene together to form graphite. We will see how a standard semi-local density functional approximation fails to predict the correct interlayer binding energy in graphite and how we can do better using semi-empirical dispersion corrections in CASTEP. For this tutorial we will use the CASTEP-ASE interface to setup and run many short calculations and analyse the results, though you can of course adapt the content here to use a scripting language of your choice. I have broken up the parts of the script to add clarification in places, but you can download the jupyter notebook with all the cells here . We start by importing several python libraries. For more information on using the atomic simulation environment (ASE) with CASTEP, see the documentation here . # ASE version 3.22.1 from ase.io import read , write from ase.calculators.castep import Castep from ase.io.castep import read_seed from ase.visualize import view # pandas version 1.3.4 import pandas as pd # castep.mpi on path already, version 21.11 castep_cmd = 'mpirun -n 4 castep.mpi' # plotting from matplotlib import pyplot as plt % matplotlib inline # Python version: 3.9.5 For this tutorial I will use CASTEP version 21.11. See here for a list of the different dispersion correction schemes and which version of CASTEP they are available from. Separation of layers: setup and run the calculations The script below loops over several different dispersion corrections schemes and, for each one, calculates the total energy of a 4-atom graphite cell at several different values of the c lattice constant. This effectively increases the interlayer spacing between the sheets of graphene. By separating them far enough apart, we can estimate the interlayer binding energy predicte by each method. The script took about 10 minutes to run using 4 cores on a relatively powerful laptop. You can decrease the k-point sampling or basis set precision, or loop over fewer methods or c parameters in order to speed things up. # run in this directorsy directory = 'separate-layers-tutorial/' # k-point grid # -- try coarser grid if this is too slow, # but higher if you want more reliable results! kpts = [ 13 , 13 , 5 ] # xc functional to use xc = 'PBE' # range of unit c parameters in Angstroms (interlayer spacings are half these!) crange = [ 4 , 5 , 6 , 6.25 , 6.5 , 6.75 , 7 , 7.25 , 7.5 , 8.5 , 10 , 14 , 16 ] #SEDC correction schemes to try: schemes = [ '' , 'G06' , 'D3' , 'D3-BJ' , 'TS' , 'MBD' , 'XDM' ] # pandas dataframe to store the results df = pd . DataFrame ({ 'crange' : crange }) # loop over the different correction schemes for sedc_scheme in schemes : print ( ' \\n ' , 50 * '=' ) print ( f ' { xc } + { sedc_scheme } \\n ' ) # list to temporarily hold the total energy for each calculation energies = [] # loop over c parameters: for c in crange : label = f ' { xc } - { sedc_scheme } - { c : 3.2f } ' try : graphite = read_seed ( directory + label ) except : # if the calculation doesn't already exist, we set it up and # run it # read in cif file (taken from here: https://materialsproject.org/materials/mp-48 ) graphite = read ( 'C_mp-48_primitive.cif' ) # we could make a supercell to get more accurate results for TS, MBD and XDM schemes. # graphite = graphite * (3,3,1) # scale c parameter to new value cellpar = graphite . cell . cellpar () cellpar [ 2 ] = c graphite . set_cell ( cellpar , scale_atoms = True ) # set up castep calculator calc = Castep ( xc = xc , kpts = kpts , label = label , castep_command = castep_cmd , basis_precision = 'precise' , # switch to something cheaper (e.g. FINE) to speed things up for this example.. directory = directory , write_checkpoint = 'None' , # don't need the checkpoint files now write_cst_esp = False , # don't need the electrostatic potential file now write_bands = False , # don't need the bands file now _rename_existing_dir = False , # allows us to write all these calculations to the same directory... symmetry_generate = True , # use symmetry to speed up the calculation snap_to_symmetry = True , # enforce symmetry ) # Switch on the SEDC flags if sedc_scheme != '' : calc . param . sedc_apply = True calc . param . sedc_scheme = sedc_scheme # For the XDM scheme we need to set this manually # otherwise the calculation crashes... if sedc_scheme == 'XDM' : calc . param . SEDC_SC_XDM = 1.0 graphite . set_calculator ( calc ) e = graphite . get_potential_energy () energies . append ( e ) print ( f ' { c : 8.3f } A \\t { e : 12.8f } eV' ) # save the energy wrt to furthest energy: energies = [ e - energies [ - 1 ] for e in energies ] df [ f ' { xc } - { sedc_scheme } ' ] = energies # Save to a .csv file: df . to_csv ( 'graphite_layer_separation.csv' ) The .param files generated look something like this: WRITE_CST_ESP: FALSE WRITE_BANDS: FALSE WRITE_CHECKPOINT: None XC_FUNCTIONAL: PBE SEDC_APPLY: TRUE SEDC_SCHEME: D3 # or TS or D3-BJ etc. BASIS_PRECISION: precise The task defaults to SINGLEPOINT (which is what we want in this case). The .cell files simply have the crystal structure in which the cell is scaled in the c direction. Read in and analyse the results We can now read in and analyse the results from the previous step. Reading the data into a pandas dataframe object is convenient. df = pd . read_csv ( './graphite_layer_separation.csv' ) # scale by 1000 / 4 to get the energies per atom and in units of meV dfdiff = ( df . iloc [:, 1 :]) * 1000 / 4 # energy per atom in meV # the c parmeter is 2x the interlayer spacing, d dfdiff [ 'c/2' ] = df [ 'crange' ] / 2 styles = [ f ' { m } -' for m in [ \"o\" , \"v\" , \"^\" , \"s\" , \"+\" , \"x\" , \"D\" ]] # compared to this refence (and many others!) https://doi.org/10.1039/C3RA47187J ax = dfdiff . plot ( x = 'c/2' , y = [ 'PBE-' , 'PBE-G06' , 'PBE-D3' , 'PBE-D3-BJ' , 'PBE-TS' , 'PBE-MBD' , 'PBE-XDM' ], ylabel = 'energy/atom (meV)' , ylim = ( - 100 , 80 ), xlabel = r 'interlayer spacing d ( = c/2) (${\\AA}$)' , figsize = ( 16 , 10 ), style = styles , ) ax . axhline ( 0 , color = '0.3' ) ax . axvline ( 3.355 , ls = '--' , color = '0.4' ) # Experimental binding energies reported shown in the figure are 31 \u00b1 2, 43, 52 \u00b1 5 and 35 (+15 to \u201310) meV per atom ax . axhspan ( ymin =- 57 , ymax =- 25 , color = '0.8' , alpha = 0.5 ) ax . set_title ( 'graphite interlayer binding energy' ) plt . savefig ( 'graphite-interlayer-binding-castep-dispersions.png' ) which produces the following figure: where the dashed vertical line is the experimental interlayer spacing and the shaded grey region is the range of experimentally obtained interlayer binding energies. Please note that these are not fully converged calculations and so do not represent the actual performance of these methods but is simply a guide for how to use them with CASTEP. We can see that the plain PBE functional severely underestimates the binding energy of graphite and that many of the dispersion-corrected results are in much better agreement. The TS scheme strongly overbinds graphite, but has been found to be accurate for other types of systems. Testing such methods carefully is always required when you encounter a new system. Further suggestions CASTEP writes out a warning for the TS, MBD and XDM schemes about the unit cell being too small for accurate corrections. Try repeat the above calculations for these three methods using a larger supercell to see what the effect is and what sized supercell you would need to converge the dispersion correction. For the D3 and D3-BJ methods, try to switch on the three-body interaction term by setting: %BLOCK devel_code d3_threebody TRUE %ENDBLOCK devel_code in the .param file. What effect does this have on the interlayer binding energy in graphite? (You may also want to set IPRINT = 2 to see more information about the dispersion correction parameters.) Compare to other XC functionals with and without the dispersion corrections (though note that of the corrections are only parameterised for a few functionals .)","title":"Dispersion corrections"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#interlayer-binding-energy-of-graphite","text":"Here we'll explore the van der Waals interaction that holds sheets of graphene together to form graphite. We will see how a standard semi-local density functional approximation fails to predict the correct interlayer binding energy in graphite and how we can do better using semi-empirical dispersion corrections in CASTEP. For this tutorial we will use the CASTEP-ASE interface to setup and run many short calculations and analyse the results, though you can of course adapt the content here to use a scripting language of your choice. I have broken up the parts of the script to add clarification in places, but you can download the jupyter notebook with all the cells here . We start by importing several python libraries. For more information on using the atomic simulation environment (ASE) with CASTEP, see the documentation here . # ASE version 3.22.1 from ase.io import read , write from ase.calculators.castep import Castep from ase.io.castep import read_seed from ase.visualize import view # pandas version 1.3.4 import pandas as pd # castep.mpi on path already, version 21.11 castep_cmd = 'mpirun -n 4 castep.mpi' # plotting from matplotlib import pyplot as plt % matplotlib inline # Python version: 3.9.5 For this tutorial I will use CASTEP version 21.11. See here for a list of the different dispersion correction schemes and which version of CASTEP they are available from.","title":"Interlayer binding energy of graphite"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#separation-of-layers-setup-and-run-the-calculations","text":"The script below loops over several different dispersion corrections schemes and, for each one, calculates the total energy of a 4-atom graphite cell at several different values of the c lattice constant. This effectively increases the interlayer spacing between the sheets of graphene. By separating them far enough apart, we can estimate the interlayer binding energy predicte by each method. The script took about 10 minutes to run using 4 cores on a relatively powerful laptop. You can decrease the k-point sampling or basis set precision, or loop over fewer methods or c parameters in order to speed things up. # run in this directorsy directory = 'separate-layers-tutorial/' # k-point grid # -- try coarser grid if this is too slow, # but higher if you want more reliable results! kpts = [ 13 , 13 , 5 ] # xc functional to use xc = 'PBE' # range of unit c parameters in Angstroms (interlayer spacings are half these!) crange = [ 4 , 5 , 6 , 6.25 , 6.5 , 6.75 , 7 , 7.25 , 7.5 , 8.5 , 10 , 14 , 16 ] #SEDC correction schemes to try: schemes = [ '' , 'G06' , 'D3' , 'D3-BJ' , 'TS' , 'MBD' , 'XDM' ] # pandas dataframe to store the results df = pd . DataFrame ({ 'crange' : crange }) # loop over the different correction schemes for sedc_scheme in schemes : print ( ' \\n ' , 50 * '=' ) print ( f ' { xc } + { sedc_scheme } \\n ' ) # list to temporarily hold the total energy for each calculation energies = [] # loop over c parameters: for c in crange : label = f ' { xc } - { sedc_scheme } - { c : 3.2f } ' try : graphite = read_seed ( directory + label ) except : # if the calculation doesn't already exist, we set it up and # run it # read in cif file (taken from here: https://materialsproject.org/materials/mp-48 ) graphite = read ( 'C_mp-48_primitive.cif' ) # we could make a supercell to get more accurate results for TS, MBD and XDM schemes. # graphite = graphite * (3,3,1) # scale c parameter to new value cellpar = graphite . cell . cellpar () cellpar [ 2 ] = c graphite . set_cell ( cellpar , scale_atoms = True ) # set up castep calculator calc = Castep ( xc = xc , kpts = kpts , label = label , castep_command = castep_cmd , basis_precision = 'precise' , # switch to something cheaper (e.g. FINE) to speed things up for this example.. directory = directory , write_checkpoint = 'None' , # don't need the checkpoint files now write_cst_esp = False , # don't need the electrostatic potential file now write_bands = False , # don't need the bands file now _rename_existing_dir = False , # allows us to write all these calculations to the same directory... symmetry_generate = True , # use symmetry to speed up the calculation snap_to_symmetry = True , # enforce symmetry ) # Switch on the SEDC flags if sedc_scheme != '' : calc . param . sedc_apply = True calc . param . sedc_scheme = sedc_scheme # For the XDM scheme we need to set this manually # otherwise the calculation crashes... if sedc_scheme == 'XDM' : calc . param . SEDC_SC_XDM = 1.0 graphite . set_calculator ( calc ) e = graphite . get_potential_energy () energies . append ( e ) print ( f ' { c : 8.3f } A \\t { e : 12.8f } eV' ) # save the energy wrt to furthest energy: energies = [ e - energies [ - 1 ] for e in energies ] df [ f ' { xc } - { sedc_scheme } ' ] = energies # Save to a .csv file: df . to_csv ( 'graphite_layer_separation.csv' ) The .param files generated look something like this: WRITE_CST_ESP: FALSE WRITE_BANDS: FALSE WRITE_CHECKPOINT: None XC_FUNCTIONAL: PBE SEDC_APPLY: TRUE SEDC_SCHEME: D3 # or TS or D3-BJ etc. BASIS_PRECISION: precise The task defaults to SINGLEPOINT (which is what we want in this case). The .cell files simply have the crystal structure in which the cell is scaled in the c direction.","title":"Separation of layers: setup and run the calculations"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#read-in-and-analyse-the-results","text":"We can now read in and analyse the results from the previous step. Reading the data into a pandas dataframe object is convenient. df = pd . read_csv ( './graphite_layer_separation.csv' ) # scale by 1000 / 4 to get the energies per atom and in units of meV dfdiff = ( df . iloc [:, 1 :]) * 1000 / 4 # energy per atom in meV # the c parmeter is 2x the interlayer spacing, d dfdiff [ 'c/2' ] = df [ 'crange' ] / 2 styles = [ f ' { m } -' for m in [ \"o\" , \"v\" , \"^\" , \"s\" , \"+\" , \"x\" , \"D\" ]] # compared to this refence (and many others!) https://doi.org/10.1039/C3RA47187J ax = dfdiff . plot ( x = 'c/2' , y = [ 'PBE-' , 'PBE-G06' , 'PBE-D3' , 'PBE-D3-BJ' , 'PBE-TS' , 'PBE-MBD' , 'PBE-XDM' ], ylabel = 'energy/atom (meV)' , ylim = ( - 100 , 80 ), xlabel = r 'interlayer spacing d ( = c/2) (${\\AA}$)' , figsize = ( 16 , 10 ), style = styles , ) ax . axhline ( 0 , color = '0.3' ) ax . axvline ( 3.355 , ls = '--' , color = '0.4' ) # Experimental binding energies reported shown in the figure are 31 \u00b1 2, 43, 52 \u00b1 5 and 35 (+15 to \u201310) meV per atom ax . axhspan ( ymin =- 57 , ymax =- 25 , color = '0.8' , alpha = 0.5 ) ax . set_title ( 'graphite interlayer binding energy' ) plt . savefig ( 'graphite-interlayer-binding-castep-dispersions.png' ) which produces the following figure: where the dashed vertical line is the experimental interlayer spacing and the shaded grey region is the range of experimentally obtained interlayer binding energies. Please note that these are not fully converged calculations and so do not represent the actual performance of these methods but is simply a guide for how to use them with CASTEP. We can see that the plain PBE functional severely underestimates the binding energy of graphite and that many of the dispersion-corrected results are in much better agreement. The TS scheme strongly overbinds graphite, but has been found to be accurate for other types of systems. Testing such methods carefully is always required when you encounter a new system.","title":"Read in and analyse the results"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#further-suggestions","text":"CASTEP writes out a warning for the TS, MBD and XDM schemes about the unit cell being too small for accurate corrections. Try repeat the above calculations for these three methods using a larger supercell to see what the effect is and what sized supercell you would need to converge the dispersion correction. For the D3 and D3-BJ methods, try to switch on the three-body interaction term by setting: %BLOCK devel_code d3_threebody TRUE %ENDBLOCK devel_code in the .param file. What effect does this have on the interlayer binding energy in graphite? (You may also want to set IPRINT = 2 to see more information about the dispersion correction parameters.) Compare to other XC functionals with and without the dispersion corrections (though note that of the corrections are only parameterised for a few functionals .)","title":"Further suggestions"}]}